-- MySQL dump 10.13  Distrib 8.0.30, for Linux (x86_64)
--
-- Host: 43.156.106.129    Database: MaxPort
-- ------------------------------------------------------
-- Server version	8.0.29

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `article`
--

DROP TABLE IF EXISTS `article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `article` (
  `id` int(10) unsigned zerofill NOT NULL AUTO_INCREMENT,
  `title` varchar(100) NOT NULL,
  `intro` varchar(200) DEFAULT NULL,
  `body` mediumtext,
  `time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `author` int(10) unsigned zerofill NOT NULL,
  `tag` varchar(45) DEFAULT NULL,
  `visit` int DEFAULT '0',
  PRIMARY KEY (`id`),
  KEY `fk_article_1_idx` (`author`),
  CONSTRAINT `fk_article_1` FOREIGN KEY (`author`) REFERENCES `people` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=92 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article`
--

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article` VALUES (0000000001,'近 20 人爆肝数周，写给初中级前端的万字高级进阶指南','笔者在学会 JS 以及框架的应用后，有一段时间不知道该如何深入下去，活能干，就是不知道该学啥。相信这个问题也会有很多读者朋友遇到。\n\n当然笔者目前已经突破了这个瓶颈，也成为了知名公司基础架构组的成员。因此想通过自己成长的经历及积累的资料整理出一系列的学习路线及资料推荐，帮助各位读者朋友解决这个问题。','? 这是什么？\n\n笔者在学会 JS 以及框架的应用后，有一段时间不知道该如何深入下去，活能干，就是不知道该学啥。相信这个问题也会有很多读者朋友遇到。\n\n当然笔者目前已经突破了这个瓶颈，也成为了知名公司基础架构组的成员。因此想通过自己成长的经历及积累的资料整理出**一系列的学习路线及资料推荐**，帮助各位读者朋友解决这个问题。\n\n> 仓库内容笔者为主要贡献者，另外还拉了将近 20 位资深前端开发做内容共建及审核，多数人员任职一线大厂 P6、P7，第一版耗时数周，大家国庆假期也没停歇，内容绝对让各位看官满意。\n\n**此资料适用于小白入门、初中级进阶、高级查漏补缺。**\n\n**内容每天都在更新，大家可以持续关注。**\n\n这里是 [Github 链接](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FKieSun%2Ffucking-frontend \"https://github.com/KieSun/fucking-frontend\")，最新内容都会首先更新在 Github，如果你觉得内容对你有帮助，可以点个 Star。\n\n## ? 如何使用\n\n如果你是初中级工程师来说，笔者也推荐先行学习「前端核心学习路径」，主要是巩固基础，之后再挑选感兴趣的主题。\n\n如果你是高级工程化，笔者推荐跳过「前端核心学习路径」，直接挑选感兴趣的主题学习即可。\n\n以下所有知识点笔者都会帮助读者朋友们将知识连贯起来，从而建立自己的知识体系而不是单独记忆松散的知识点。\n\n## 如何获取本文资料\n\n**笔者已经将仓库内容里的重要资料整理好了， 另外还附赠了前端 10 万字的面试攻略，已经帮助上千人拿到 offer。大家可以关注【[公众号](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FKieSun%2Fall-of-frontend%23%25E5%25A6%2582%25E4%25BD%2595%25E8%258E%25B7%25E5%258F%2596%25E6%259C%25AC%25E4%25BB%2593%25E5%25BA%2593%25E8%25B5%2584%25E6%2596%2599 \"https://github.com/KieSun/all-of-frontend#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%9C%AC%E4%BB%93%E5%BA%93%E8%B5%84%E6%96%99\")】发送「资料」获取。**\n\n## ? 目录\n\n因为掘金的 `header` 标签并不支持跳转，因此大家只能受累自己划文章到感兴趣的地方了，或者读者朋友也可以前往 [Github](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FKieSun%2Ffucking-frontend \"https://github.com/KieSun/fucking-frontend\") 浏览目录。\n\n## 如何高效自学\n\n![Z0qdJz](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7823cf5008814505ac7cd700ebfb9174~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n自学是每个工程师都需要掌握的一项技能。这个学习方法笔者百试百灵，学习任何技术都会用上这个思路。另外我们还能通过这个思路拓宽自己的技术栈，将各个知识联系起来建立自己的知识体系，并且通过这种学习方式学到的知识也不容易遗忘。\n\n## 书籍推荐\n\n以下书籍主要还是推荐了 JS 方面的，其它比如说框架、TS 等等技术会在各自章节为大家介绍。\n\n### 初级\n\n- [JavaScript 高级程序设计（第 4 版）](https://link.juejin.cn?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F35175321%2F \"https://book.douban.com/subject/35175321/\")\n\n### 进阶\n\n- [JavaScript 忍者秘籍（第 2 版）](https://link.juejin.cn?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F30143702%2F \"https://book.douban.com/subject/30143702/\")\n- [你不知道的 JS 三卷](https://link.juejin.cn?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F26351021%2F \"https://book.douban.com/subject/26351021/\")，该书英文版是开源的，并且作者已经在写第二版，有能力阅读英文的读者推荐直接看 [原著](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgetify%2FYou-Dont-Know-JS \"https://github.com/getify/You-Dont-Know-JS\")\n\n### 高级\n\n- [JavaScript 悟道](https://link.juejin.cn?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F35469273%2F \"https://book.douban.com/subject/35469273/\")\n- [JavaScript 语言精髓与编程实践（第 3 版）](https://link.juejin.cn?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F35085910%2F \"https://book.douban.com/subject/35085910/\")\n\n**上述书籍大家可以关注【[公众号](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FKieSun%2Ffucking-frontend%23%25E4%25BD%259C%25E8%2580%2585%25E4%25BF%25A1%25E6%2581%25AF \"https://github.com/KieSun/fucking-frontend#%E4%BD%9C%E8%80%85%E4%BF%A1%E6%81%AF\")】发送「资料」获取， 另外还附赠了前端 10 万字的面试攻略，已经帮助上千人拿到 offer。**\n\n## 前端核心学习路径\n\n前端知识点很多这是公认的事情，但是我们确实没必要把所有知识都去学习，那样只会贪多嚼不烂。我们能把核心知识点、热门技术以及工作中需要用到的知识学好就已经能打败大部分前端工程师了，剩下的大家可以自行根据兴趣选择学习内容。\n\n**但是在学习其他内容之前，笔者强烈推荐各位务必一定一定先把基础打扎实了，基础不好真的不可能把自己技术往上拔高的。**\n\n> 为了保证大家学到的知识是正确的，下文中的文档资料笔者都使用了英文版本。因为在审核资料的过程中笔者发现不少中文文档都存在翻译错误或者过时的情况。\n\n如果你还是一位初学者，推荐先自行完整阅读一至二本书后再按照该计划学习，因为以下计划并没有囊括 JS 的所有知识，而是列出了所有核心知识点。\n\n关于书籍笔者推荐以下两本：\n\n- [JavaScript 高级程序设计（第 4 版）](https://link.juejin.cn?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F35175321%2F \"https://book.douban.com/subject/35175321/\")\n- [JavaScript 忍者秘籍（第 2 版）](https://link.juejin.cn?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F30143702%2F \"https://book.douban.com/subject/30143702/\")\n\n### JS 核心知识点\n\n#### 数据类型\n\nJS 数据类型分为两大类及八种数据类型，注意别漏了 ES6 新增的 `bigint`。\n\n- 文档：\n  - [JavaScript 数据类型和数据结构](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FData_structures \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures\")\n\n#### 类型判断\n\n类型判断有好几种方式，分别为：\n\n- `typeof`\n  \n- `instanceof`\n  \n- `Object.prototype.toString`\n  \n- `isXXX`，比如 `isArray`\n  \n- 文档\n  \n  - [typeof](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Ftypeof \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\")\n  - [instanceof](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Finstanceof \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\")\n  - [Object.prototype.toString](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FObject%2FtoString%23using_tostring_to_detect_object_class \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#using_tostring_to_detect_object_class\")\n- 推荐文章，Issue 也挺重要\n  \n  - [JavaScript 专题之类型判断(上)](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F28 \"https://github.com/mqyqingfeng/Blog/issues/28\")\n  - [JavaScript 专题之类型判断(下)](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F30 \"https://github.com/mqyqingfeng/Blog/issues/30\")\n\n#### 类型转换\n\n类型转换算是 JS 中情况繁杂且容易出错，但是开发中还经常会遇到的知识点。强行全部记忆容易遗忘，推荐记忆及练习开发中的常见情况。\n\n- 文档\n  - [ES 标准](https://link.juejin.cn?target=https%3A%2F%2Ftc39.es%2Fecma262%2F%23sec-abstract-operations \"https://tc39.es/ecma262/#sec-abstract-operations\")\n    - 标准并不好读，如果读者英文水平欠佳，可以只阅读该小节内的表格内容。\n  - [双等判断](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FEquality \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality\")\n- 推荐文章\n  - [You Don\'t Know JS 书中关于类型转换的一章节](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fweiqinl%2FYou-Dont-Know-JS-CN%2Fblob%2Fmaster%2Ftypes%2520%2526%2520grammar%2Fch4.md \"https://github.com/weiqinl/You-Dont-Know-JS-CN/blob/master/types%20%26%20grammar/ch4.md\")\n  - [几种基本类型简单的类型转换](https://link.juejin.cn?target=https%3A%2F%2Fzh.javascript.info%2Ftype-conversions \"https://zh.javascript.info/type-conversions\")\n  - [JavaScript 深入之头疼的类型转换(上)](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F159 \"https://github.com/mqyqingfeng/Blog/issues/159\")\n  - [JavaScript 深入之头疼的类型转换(下)](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F164 \"https://github.com/mqyqingfeng/Blog/issues/164\")\n\n#### this\n\n`this` 算是不少初学者容易搞混的一个知识点，但是它很重要，务必掌握。\n\n- 文档\n  - [this](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fthis \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\")\n- 推荐文章\n  - [You Don\'t Know JS 书中关于 this 的第一章节](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgetify%2FYou-Dont-Know-JS%2Fblob%2F1st-ed%2Fthis%2520%2526%2520object%2520prototypes%2Fch1.md \"https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/this%20%26%20object%20prototypes/ch1.md\")\n  - [You Don\'t Know JS 书中关于 this 的第二章节](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgetify%2FYou-Dont-Know-JS%2Fblob%2F1st-ed%2Fthis%2520%2526%2520object%2520prototypes%2Fch2.md \"https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/this%20%26%20object%20prototypes/ch2.md\")\n  - [深入理解 js this 绑定 ( 无需死记硬背，尾部有总结和面试题解析 )](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000011194676 \"https://segmentfault.com/a/1190000011194676\")\n\n#### 闭包\n\n闭包特别常用，但是其实挺多工程师对于闭包的理解是错误的。\n\n- 文档\n  - [闭包](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FClosures \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\")\n- 推荐文章\n  - [You Don\'t Know JS 第二版中对于闭包的解释](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgetify%2FYou-Dont-Know-JS%2Fblob%2F2nd-ed%2Fscope-closures%2Fch7.md \"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch7.md\")，该版本暂无中文翻译，读者可用 [DeepL](https://link.juejin.cn?target=https%3A%2F%2Fwww.deepl.com%2Ftranslator \"https://www.deepl.com/translator\") 进行翻译。\n  - [JavaScript 的静态作用域链与“动态”闭包链](https://juejin.cn/post/6957913856488243237 \"https://juejin.cn/post/6957913856488243237\")\n  - [知乎中关于闭包的讨论](https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F34210214 \"https://www.zhihu.com/question/34210214\")\n\n#### 作用域\n\n作用域是指程序中定义变量的区域，该位置决定了变量的生命周期，也就是变量和函数的可访问范围。\n\n- 文档\n  - [作用域](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FGlossary%2FScope \"https://developer.mozilla.org/en-US/docs/Glossary/Scope\")\n  - [块作用域](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FGlossary%2FBlock%2FScripting \"https://developer.mozilla.org/en-US/docs/Glossary/Block/Scripting\")\n- 推荐文章\n  - [JavaScript 深入之词法作用域和动态作用域](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F3 \"https://github.com/mqyqingfeng/Blog/issues/3\")\n  - [JavaScript 深入之作用域链](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F6 \"https://github.com/mqyqingfeng/Blog/issues/6\")\n  - [Variable scope, closure](https://link.juejin.cn?target=https%3A%2F%2Fjavascript.info%2Fclosure \"https://javascript.info/closure\")，另有 [中文翻译版](https://link.juejin.cn?target=https%3A%2F%2Fzh.javascript.info%2Fclosure \"https://zh.javascript.info/closure\")\n  - [You Don\'t Know JS Yet: Scope & Closures](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgetify%2FYou-Dont-Know-JS%2Ftree%2F2nd-ed%2Fscope-closures \"https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed/scope-closures\")\n  - [The battle between function scope and block scope](https://link.juejin.cn?target=https%3A%2F%2Fwww.deadcoderising.com%2F2017-04-11-es6-var-let-and-const-the-battle-between-function-scope-and-block-scope%2F \"https://www.deadcoderising.com/2017-04-11-es6-var-let-and-const-the-battle-between-function-scope-and-block-scope/\")\n\n#### 变量提升\n\n变量提升（Hoisting）可以将变量和函数在编译阶段放入内存，从而在执行阶段时在声明前使用。\n\n- 文档\n  - [JS 变量提升](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FGlossary%2FHoisting \"https://developer.mozilla.org/en-US/docs/Glossary/Hoisting\")，变量提升的概念\n- 推荐文章\n  - [JavsScript 变量提升和函数提升](https://link.juejin.cn?target=https%3A%2F%2Ftowind.fun%2F2021%2F05%2F10%2Fjs-hoisting%2F \"https://towind.fun/2021/05/10/js-hoisting/\")，深度解析变量提升和函数提升，举例说明各种情况下的变量提升\n  - [我用了两个月的时间才理解 let](https://link.juejin.cn?target=https%3A%2F%2Ffangyinghang.com%2Flet-in-js%2F \"https://fangyinghang.com/let-in-js/\")，深度理解解析 let 和 val 的区别，和 let 的暂时死区\n  - [JavaScript Scoping and Hoisting](https://link.juejin.cn?target=http%3A%2F%2Fwww.adequatelygood.com%2FJavaScript-Scoping-and-Hoisting.html \"http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html\")，JavaScript 中的作用域和函数声明和变量声明的提升\n\n#### new\n\n`new` 操作符可以帮助我们构建出一个实例，并且绑定上 `this`。\n\n- 文档\n  - [new](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fnew \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new\")\n- 推荐文章\n  - [JS 的 new 到底是干什么的？](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F23987456 \"https://zhuanlan.zhihu.com/p/23987456\")\n  - [JavaScript 深入之 new 的模拟实现](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F13 \"https://github.com/mqyqingfeng/Blog/issues/13\")\n\n#### call、apply、bind\n\n- 文档\n  - [call](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fcall \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call\")，call 的概念\n  - [apply](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fapply \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\")，apply 的概念\n  - [bind](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fbind \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\")，bind 的概念\n- 推荐文章\n  - [JS 中的 call、apply、bind 方法详解](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000018270750 \"https://segmentfault.com/a/1190000018270750\")，对这三个方法的使用、面试题及具体实现做了详解\n  - [call 和 apply 的模拟实现](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F11 \"https://github.com/mqyqingfeng/Blog/issues/11\")，模拟实现 call 和 apply，帮助更好理解\n  - [bind 的模拟实现](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F12 \"https://github.com/mqyqingfeng/Blog/issues/12\")，模拟实现 bind，帮助更好理解\n\n#### 原型\n\n通过原型这种机制，JavaScript 中的对象从其他对象继承功能特性。\n\n- 文档\n  - [原型](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FLearn%2FJavaScript%2FObjects%2FObject_prototypes \"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes\")\n- 推荐文章\n  - [You Don\'t Know JS: this & Object Prototypes](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgetify%2FYou-Dont-Know-JS%2Fblob%2F1st-ed%2Fthis%2520%2526%2520object%2520prototypes%2Fch5.md \"https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/this%20%26%20object%20prototypes/ch5.md\")\n  - [深入理解 JavaScript 原型](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F1UDILezroK5wrcK-Z5bHOg \"https://mp.weixin.qq.com/s/1UDILezroK5wrcK-Z5bHOg\")\n  - [深度解析原型中的各个难点](https://juejin.cn/post/6844903575974313992 \"https://juejin.cn/post/6844903575974313992\")\n  - [Prototypes in JavaScript](https://link.juejin.cn?target=https%3A%2F%2Fbetterprogramming.pub%2Fprototypes-in-javascript-5bba2990e04b \"https://betterprogramming.pub/prototypes-in-javascript-5bba2990e04b\") 需自备梯子\n\n#### Class\n\n`class` 只是原型链的语法糖，与其它语言中的类不是同一样东西。\n\n- 文档\n  - [Class](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FGlossary%2FClass \"https://developer.mozilla.org/en-US/docs/Glossary/Class\")\n- 推荐文章\n  - [理解 JavaScript 的类](https://link.juejin.cn?target=https%3A%2F%2Fwww.digitalocean.com%2Fcommunity%2Ftutorials%2Funderstanding-classes-in-javascript \"https://www.digitalocean.com/community/tutorials/understanding-classes-in-javascript\")\n  - [Babel 是如何编译 Class 上](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F105 \"https://github.com/mqyqingfeng/Blog/issues/105\")\n  - [Babel 是如何编译 Class 下](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F106 \"https://github.com/mqyqingfeng/Blog/issues/106\")\n  - [给 ES6 class 说句公道话](https://juejin.cn/post/6924108426125508616 \"https://juejin.cn/post/6924108426125508616\")\n  - [应该在 JavaScript 中使用 Class 吗？](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F158956514 \"https://zhuanlan.zhihu.com/p/158956514\")\n\n#### 继承\n\n继承是面向对象语言（Object-Oriented Language）三大特征之一，在 JS 中也占有非常重要的地位。而想要实现继承有多种方式，它们都有各自的优缺点。\n\n- 文档\n  - [继承](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FLearn%2FJavaScript%2FObjects%2FInheritance \"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance\")\n- 推荐文章\n  - [JavaScript 深入之继承的多种方式和优缺点](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F16 \"https://github.com/mqyqingfeng/Blog/issues/16\")\n  - [JavaScript 中的继承](https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2F%40happymishra66%2Finheritance-in-javascript-21d2b82ffa6f \"https://medium.com/@happymishra66/inheritance-in-javascript-21d2b82ffa6f\")，需自备梯子\n  - [JS 类继承](https://link.juejin.cn?target=https%3A%2F%2Fjavascript.info%2Fclass-inheritance \"https://javascript.info/class-inheritance\")，另有 [中文翻译版](https://link.juejin.cn?target=https%3A%2F%2Fzh.javascript.info%2Fclass-inheritance \"https://zh.javascript.info/class-inheritance\")\n\n#### 模块化\n\n这块知识必会，最好了解下模块化的前世今生以及对 ES6 的原生模块化有个深入的理解。\n\n- 文档\n  - [Modules](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FModules \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules\")\n- 推荐文章\n  - [【深度全面】前端 JavaScript 模块化规范进化论](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000023711059 \"https://segmentfault.com/a/1190000023711059\")，记录了 JS 模块化的进化之路\n  - [JavaScript modules](https://link.juejin.cn?target=https%3A%2F%2Fv8.dev%2Ffeatures%2Fmodules \"https://v8.dev/features/modules\")，由浅入深解释 JS 模块化\n  - [ES modules: A cartoon deep-dive](https://link.juejin.cn?target=https%3A%2F%2Fhacks.mozilla.org%2F2018%2F03%2Fes-modules-a-cartoon-deep-dive%2F \"https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/\")，一篇对 JS 模块化深入解释的文章，另有 [中文版](https://juejin.cn/post/6844903591979778061 \"https://juejin.cn/post/6844903591979778061\")\n\n#### Promise\n\n- 文档\n  - [Promise](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FPromise \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\")\n  - [Promises/A+ 规范](https://link.juejin.cn?target=https%3A%2F%2Fpromisesaplus.com%2F \"https://promisesaplus.com/\")\n- 推荐文章\n- [Callbacks Vs Promises and basics of JS](https://link.juejin.cn?target=https%3A%2F%2Ftheflyingmantis.medium.com%2Fcallbacks-vs-promises-and-basics-of-js-80d3d1515e81 \"https://theflyingmantis.medium.com/callbacks-vs-promises-and-basics-of-js-80d3d1515e81\")，需自备梯子\n- [最简实现 Promise，支持异步链式调用（20 行）](https://juejin.cn/post/6844904094079926286 \"https://juejin.cn/post/6844904094079926286\")\n- [100 行代码实现 Promises/A+ 规范](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FqdJ0Xd8zTgtetFdlJL3P1g \"https://mp.weixin.qq.com/s/qdJ0Xd8zTgtetFdlJL3P1g\")\n- Github\n- [promise-fun](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsindresorhus%2Fpromise-fun \"https://github.com/sindresorhus/promise-fun\")\n\n#### 迭代器与生成器\n\n- 文档\n  - [迭代器与生成器](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FIterators_and_Generators \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators\")\n- 推荐文章\n  - [\\[译\\] 什么是 JavaScript 生成器？如何使用生成器？](https://juejin.cn/post/6844903616357072910 \"https://juejin.cn/post/6844903616357072910\")\n  - [Understanding Generators in ES6 JavaScript with Examples](https://link.juejin.cn?target=https%3A%2F%2Fcodeburst.io%2Funderstanding-generators-in-es6-javascript-with-examples-6728834016d5 \"https://codeburst.io/understanding-generators-in-es6-javascript-with-examples-6728834016d5\")，需自备梯子\n  - [A Simple Guide to ES6 Iterators in JavaScript with Examples](https://link.juejin.cn?target=https%3A%2F%2Fcodeburst.io%2Fa-simple-guide-to-es6-iterators-in-javascript-with-examples-189d052c3d8e \"https://codeburst.io/a-simple-guide-to-es6-iterators-in-javascript-with-examples-189d052c3d8e\")，需自备梯子\n\n#### async await\n\n- 文档\n  - [async](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Fasync_function \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\")\n  - [await](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fawait \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await\")\n- 推荐文章\n  - [手写 async await 的最简实现（20 行）](https://juejin.cn/post/6844904102053281806 \"https://juejin.cn/post/6844904102053281806\")\n  - [Babel 将 Generator 编译成了什么样子](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F102 \"https://github.com/mqyqingfeng/Blog/issues/102\")\n\n#### 事件循环\n\n大家都知道 JS 是一门单线程的非阻塞的脚本语言。这也就意味着，代码在执行的任何时候只有一个主线程来处理所有的任务。所以弄懂事件循环机制对我们学习 JS 至关重要。\n\n- 文档\n  - [事件循环](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FEventLoop \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\")\n- 推荐文章\n  - [这一次，彻底弄懂 JavaScript 执行机制](https://juejin.cn/post/6844903512845860872 \"https://juejin.cn/post/6844903512845860872\")\n  - [一次弄懂 Event Loop](https://juejin.cn/post/6844903764202094606 \"https://juejin.cn/post/6844903764202094606\")\n  - [JavaScript 的工作原理](https://link.juejin.cn?target=https%3A%2F%2Fblog.sessionstack.com%2Fhow-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5 \"https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5\")，需自备梯子，另有 [中文翻译版](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FTroland%2Fhow-javascript-works%2Fblob%2Fmaster%2Fevent-loop.md \"https://github.com/Troland/how-javascript-works/blob/master/event-loop.md\")。\n- 事件循环可视化\n  - [Loupe](https://link.juejin.cn?target=http%3A%2F%2Flatentflip.com%2Floupe%2F%3Fcode%3DJC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%253D \"http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D\")\n\n#### 节流与防抖\n\n节流指连续触发事件的情况下，在某个时间段内，函数只会执行一次。 防抖指在事件被触发一定时间后再执行回调函数，如果在一定时间内该事件又被重复触发，则重启计时。\n\n- 推荐文章\n  - [函数防抖与函数节流](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F38313717 \"https://zhuanlan.zhihu.com/p/38313717\")\n  - [浅谈 JS 防抖和节流](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000018428170 \"https://segmentfault.com/a/1190000018428170\")\n  - [Debounce – How to Delay a Function in JavaScript](https://link.juejin.cn?target=https%3A%2F%2Fwww.freecodecamp.org%2Fnews%2Fjavascript-debounce-example \"https://www.freecodecamp.org/news/javascript-debounce-example\")\n  - [Debouncing and Throttling in JavaScript](https://link.juejin.cn?target=https%3A%2F%2Fwww.telerik.com%2Fblogs%2Fdebouncing-and-throttling-in-javascript \"https://www.telerik.com/blogs/debouncing-and-throttling-in-javascript\")\n\n#### 柯里化\n\n柯里化就是将接收多个参数的函数转换成接收一个参数的函数。\n\n- 推荐文章\n  - [柯里化（Currying）](https://link.juejin.cn?target=https%3A%2F%2Fzh.javascript.info%2Fcurrying-partials \"https://zh.javascript.info/currying-partials\")\n  - [JavaScript 专题之函数柯里化](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F42 \"https://github.com/mqyqingfeng/Blog/issues/42\")\n  - [Understanding Currying in JavaScript](https://link.juejin.cn?target=https%3A%2F%2Fblog.bitsrc.io%2Funderstanding-currying-in-javascript-ceb2188c339 \"https://blog.bitsrc.io/understanding-currying-in-javascript-ceb2188c339\")，需自备梯子，另有 [中文翻译版](https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2FGeniusLyzh%2Fp%2F9937829.html \"https://www.cnblogs.com/GeniusLyzh/p/9937829.html\")\n\n#### 垃圾回收\n\nJavaScrip 在变量被创建时分配内存，并在对象不再使用时自动释放内存，这个过程被称为垃圾回收。另外我们主要学习 V8 引擎下的垃圾回收机制。\n\n- 文档\n  - [内存管理 & 垃圾回收](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FMemory_Management \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management\")\n- 推荐文章\n  - [深入理解 Chrome V8 垃圾回收机制](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyacan8%2Fblog%2Fissues%2F33 \"https://github.com/yacan8/blog/issues/33\")，该文章的参考文献也可阅读下\n  - [GC in v8](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flrlna%2Fsketchin%2Fblob%2Fmaster%2Fguides%2Fgarbage-collection-in-v8.md \"https://github.com/lrlna/sketchin/blob/master/guides/garbage-collection-in-v8.md\")\n  - [JavaScript 工作原理：内存管理 + 处理常见的 4 种内存泄漏](https://link.juejin.cn?target=https%3A%2F%2Fblog.sessionstack.com%2Fhow-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec \"https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec\")，另有[中文版](https://juejin.cn/post/6844903519078580238 \"https://juejin.cn/post/6844903519078580238\")\n\n#### 其他零散但重要的知识点\n\n- [0.1 + 0.2 !== 0.3](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F225490777 \"https://zhuanlan.zhihu.com/p/225490777\")，JS 浮点数会造成的问题\n\n**如果你觉得以上内容对你有帮助，可以前往 [Github](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FKieSun%2Ffucking-frontend \"https://github.com/KieSun/fucking-frontend\") 点个 Star 支持一下。**\n\n### HTML\n\n#### 语义化\n\nhtml 语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析。在没有引入样式 CCS 样式的时候也能以一种可以分辨出来大致表示内容的文档格式显示，并且是容易阅读的。 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。\n\n- 文档\n  - [HTML 中的语义](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FGlossary%2FSemantics%23semantics_in_html \"https://developer.mozilla.org/en-US/docs/Glossary/Semantics#semantics_in_html\")，什么是 HTML 语义化，HTML 语义化有什么好处\n- 推荐文章\n  - [IFE-NOTE：页面结构语义化](https://link.juejin.cn?target=https%3A%2F%2Frainylog.com%2Fpost%2Fife-note-1%2F \"https://rainylog.com/post/ife-note-1/\")，HTML5 语义化中的页面结构语义化的一些经验和理解\n  - [关于 HTML 语义和前端架构](https://link.juejin.cn?target=http%3A%2F%2Fnicolasgallagher.com%2Fabout-html-semantics-front-end-architecture%2F \"http://nicolasgallagher.com/about-html-semantics-front-end-architecture/\")，HTML 语义化在开发中配合 CSS 结构化类名的使用构建可重用和可组合的组件\n\n### CSS\n\n- 推荐文章\n  - [一文梳理 CSS 必会知识点](https://juejin.cn/post/6854573212337078285 \"https://juejin.cn/post/6854573212337078285\")\n\n#### 盒子模型\n\n在 CSS 中，所有的元素都被一个个的“盒子（box）”包围着，我们广泛地使用两种“盒子” —— 块级盒子 (block box) 和 内联盒子 (inline box)，理解这些“盒子”的基本原理，是我们使用 CSS 实现准确布局、处理元素排列的关键。\n\n- 文档\n  - [CSS 盒子模型](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FLearn%2FCSS%2FBuilding_blocks%2FThe_box_model \"https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model\")，官方文档深入了解 CSS 盒子模型\n- 推荐文章\n  - [CSS 盒模型之内边距、边框、外边距 十九问](https://juejin.cn/post/6880111680153059341 \"https://juejin.cn/post/6880111680153059341\")，通过举例说明盒子模型各种常见形态和问题\n  - [CSS Box Model](https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FTR%2Fcss-box-3%2F \"https://www.w3.org/TR/css-box-3/\")，盒子模型的一些规范介绍\n  - [CSS 盒模型详解（图文教程）](https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fqianguyihao%2Fp%2F7256371.html \"https://www.cnblogs.com/qianguyihao/p/7256371.html\")，通过图片和例子说明盒子模型的各个部分和在页面上的表现形式\n\n#### 选择器\n\nCSS 中，选择器用来指定网页上我们想要样式化的 HTML 元素。CSS 选择器提供了很多种方法，所以在选择要样式化的元素时，我们可以做到很精细的地步。\n\nCSS 选择器是 CSS 规则的第一部分。它是元素和其他部分组合起来告诉浏览器哪个 HTML 元素应当是被选为应用规则中的 CSS 属性值的方式。选择器所选择的元素，叫做“选择器的对象”。\n\n- 文档\n  - [CSS 选择器](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FLearn%2FCSS%2FBuilding_blocks%2FSelectors \"https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors\")，官方文档详细地讲授选择器的不同使用方式，并了解它们的工作原理。\n- 推荐文章\n  - [30 个你必须熟记的 CSS 选择器](https://link.juejin.cn?target=https%3A%2F%2Fcode.tutsplus.com%2Fzh-hans%2Ftutorials%2Fthe-30-css-selectors-you-must-memorize--net-16048 \"https://code.tutsplus.com/zh-hans/tutorials/the-30-css-selectors-you-must-memorize--net-16048\")，开发中常用的 CSS 选择器，熟练掌握以后可以很大程度提高 CSS 的编码体验\n  - [深入解析 CSS 样式优先级](https://link.juejin.cn?target=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2Farticle%2F1545341 \"https://cloud.tencent.com/developer/article/1545341\")，详细介绍了 CSS 样式的权重优先级，避免写重复样式和样式被覆盖不生效的问题\n\n#### Flex\n\n- 文档\n  - [flexbox](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FCSS%2FCSS_Flexible_Box_Layout%2FBasic_Concepts_of_Flexbox \"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox\")\n- 推荐文章\n  - [A Complete Guide to Flexbox](https://link.juejin.cn?target=https%3A%2F%2Fcss-tricks.com%2Fsnippets%2Fcss%2Fa-guide-to-flexbox%2F \"https://css-tricks.com/snippets/css/a-guide-to-flexbox/\")\n  - [Flexbox 布局中不为人知的细节](https://juejin.cn/post/6938292463605907492 \"https://juejin.cn/post/6938292463605907492\")\n- 实战\n  - [FLEXBOX FROGGY](https://link.juejin.cn?target=https%3A%2F%2Fflexboxfroggy.com%2F \"https://flexboxfroggy.com/\") 一个趣味性小游戏学习 Flex 的网站\n\n#### grid\n\n- 文档\n  - [grid](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FCSS%2FCSS_Grid_Layout%2FBasic_Concepts_of_Grid_Layout \"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout\")\n- 推荐文档\n  - [A Complete Guide to Grid](https://link.juejin.cn?target=https%3A%2F%2Fcss-tricks.com%2Fsnippets%2Fcss%2Fcomplete-guide-grid%2F \"https://css-tricks.com/snippets/css/complete-guide-grid/\")\n  - [最强大的 CSS 布局 —— Grid 布局](https://juejin.cn/post/6854573220306255880 \"https://juejin.cn/post/6854573220306255880\")\n\n#### 其他\n\n- 推荐文档\n  - [详谈层合成（composite)](https://link.juejin.cn?target=http%3A%2F%2Fjartto.wang%2F2017%2F09%2F29%2Fexpand-on-performance-composite%2F \"http://jartto.wang/2017/09/29/expand-on-performance-composite/\")\n  - [移动设备如何实现真正 1px 的线？](https://link.juejin.cn?target=https%3A%2F%2Fjinlong.github.io%2F2015%2F05%2F24%2Fcss-retina-hairlines%2F \"https://jinlong.github.io/2015/05/24/css-retina-hairlines/\")\n\n## 框架\n\n框架一般选其一深入学习即可。\n\n### 虚拟 DOM\n\nVirtual DOM 也就是虚拟节点。通过 JS 的 Object 对象模拟 DOM 中的真实节点对象，再通过特定的 render 方法将其渲染成真实的 DOM 节点。\n\n- 文档\n  - [React 官网介绍](https://link.juejin.cn?target=https%3A%2F%2Freactjs.org%2Fdocs%2Ffaq-internals.html \"https://reactjs.org/docs/faq-internals.html\")\n- 推荐文章\n  - [Virtual Dom 和 Diff 算法在 React 中是如何工作的？](https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2F%40gethylgeorge%2Fhow-virtual-dom-and-diffing-works-in-react-6fc805f9f84e \"https://medium.com/@gethylgeorge/how-virtual-dom-and-diffing-works-in-react-6fc805f9f84e\")，需自备梯子\n  - [React 核心知识点 -- Virtual Dom 与 Diff](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fpfan123%2FArticles%2Fissues%2F62 \"https://github.com/pfan123/Articles/issues/62\")\n\n### 路由\n\n路由在 SPA 架构中都有被用到，实际原理就是运用 `hash` 及 `history` 相关的 API 实现。\n\n- 文档\n  - [hashchange](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FWindow%2Fhashchange_event \"https://developer.mozilla.org/en-US/docs/Web/API/Window/hashchange_event\")\n  - [history](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FHistory \"https://developer.mozilla.org/en-US/docs/Web/API/History\")\n- 推荐文章\n  - [前端路由简介以及 vue-router 实现原理](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F37730038 \"https://zhuanlan.zhihu.com/p/37730038\")，对前端路由及 Vue-Route 库原理做了解释，**几个框架的路由库原理都一致**\n\n## React\n\n学习框架务必从[文档](https://link.juejin.cn?target=https%3A%2F%2Freactjs.org%2F \"https://reactjs.org/\")出发，起码熟读一遍及自己写过一些初步的 Demo 之后再考虑学习别的资料。\n\n### React 推荐学习路径\n\n![reactStudypng](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec39552dd0c84985bedb861ba7cb09f5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n大家可以跟着以上学习路径学习，其中除了概念相关的内容是必须学习之外，生态相关的内容大家可以在使用时再学习。\n\n### React 推荐学习资料\n\n- [React 学习之道](https://link.juejin.cn?target=https%3A%2F%2Fleanpub.com%2Fthe-road-to-learn-react-chinese%2F \"https://leanpub.com/the-road-to-learn-react-chinese/\")，可以 0 元购买\n- [React 生命周期](https://link.juejin.cn?target=https%3A%2F%2Fprojects.wojtekmaj.pl%2Freact-lifecycle-methods-diagram%2F \"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\")\n\n### 如何编写一个组件\n\n- 文档\n  - [React 官方文档](https://link.juejin.cn?target=https%3A%2F%2Freactjs.org%2Fdocs%2Fcomponents-and-props.html \"https://reactjs.org/docs/components-and-props.html\")\n- 推荐文章\n  - [\\[译\\]React 函数组件和类组件的差异](https://link.juejin.cn?target=https%3A%2F%2Fjishuin.proginn.com%2Fp%2F763bfbd4cad4 \"https://jishuin.proginn.com/p/763bfbd4cad4\")\n  - [寫 React Components 該注意的 6 個地方與技巧](https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2F%40chihsuan%2F%25E5%25AF%25AB-react-components-%25E8%25A9%25B2%25E6%25B3%25A8%25E6%2584%258F%25E7%259A%25846%25E5%2580%258B%25E5%259C%25B0%25E6%2596%25B9%25E8%2588%2587%25E6%258A%2580%25E5%25B7%25A7-faa2bb87a18e \"https://medium.com/@chihsuan/%E5%AF%AB-react-components-%E8%A9%B2%E6%B3%A8%E6%84%8F%E7%9A%846%E5%80%8B%E5%9C%B0%E6%96%B9%E8%88%87%E6%8A%80%E5%B7%A7-faa2bb87a18e\")\n  - [编写高效且可读组件的 5 个最佳实践](https://link.juejin.cn?target=https%3A%2F%2Fwww.infoq.cn%2Farticle%2Fry4icky5crb1pokvi0ql \"https://www.infoq.cn/article/ry4icky5crb1pokvi0ql\")\n  - [designing-react-components-best-practices](https://link.juejin.cn?target=https%3A%2F%2Fwww.thisdot.co%2Fblog%2Fdesigning-react-components-best-practices \"https://www.thisdot.co/blog/designing-react-components-best-practices\")\n  - [React 复合组件](https://link.juejin.cn?target=https%3A%2F%2Fwww.smashingmagazine.com%2F2021%2F08%2Fcompound-components-react%2F \"https://www.smashingmagazine.com/2021/08/compound-components-react/\")\n\n### 受控组件和非受控组件\n\n- 受控组件：在 HTML 中，表单元素（如 input、 textarea 和 select ）通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState() 或者 props 来更新\n  \n- 非受控组件：是一个存储其自己的内部状态，并且您使用查询 DOM ref，当你需要它来找到它的当前值，这有点像传统的 HTML\n  \n- 文档\n  \n  - [React 官方文档](https://link.juejin.cn?target=https%3A%2F%2Freactjs.org%2Fdocs%2Funcontrolled-components.html \"https://reactjs.org/docs/uncontrolled-components.html\")\n- 推荐文章\n  \n  - [受控和非受控组件真的那么难理解吗](https://juejin.cn/post/6858276396968951822 \"https://juejin.cn/post/6858276396968951822\")\n  - [\\[译\\]受控组件 & 非受控组件](https://link.juejin.cn?target=https%3A%2F%2Fwww.baobangdong.cn%2Fcontrolled-components-and-uncontrolled-components%2F \"https://www.baobangdong.cn/controlled-components-and-uncontrolled-components/\")\n\n### 高阶组件（HOC）\n\n高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。\n\n具体而言，高阶组件是参数为组件，返回值为新组件的函数。\n\n- 文档\n  - [React 官方文档](https://link.juejin.cn?target=https%3A%2F%2Freactjs.org%2Fdocs%2Fhigher-order-components.html \"https://reactjs.org/docs/higher-order-components.html\")\n- 推荐文章\n  - [React 高阶组件(HOC)入门指南](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FMrErHu%2Fblog%2Fissues%2F4 \"https://github.com/MrErHu/blog/issues/4\")\n  - [hoc 库 recompose](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Facdlite%2Frecompose \"https://github.com/acdlite/recompose\")\n  - [精读 React 高阶组件](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F27434557 \"https://zhuanlan.zhihu.com/p/27434557\")\n\n### Hooks\n\nHook 是 React 16.8 的新增特性。它可以让你在不编写类组件的情况下使用 React 的特性。\n\n- 文档\n  - [React Hooks 官方文档](https://link.juejin.cn?target=https%3A%2F%2Fzh-hans.reactjs.org%2Fdocs%2Fhooks-intro.html \"https://zh-hans.reactjs.org/docs/hooks-intro.html\")\n- 推荐文章\n  - [彻底理解 React hook useCallback 和 useMemo 的区别](https://juejin.cn/post/6844904032113278990 \"https://juejin.cn/post/6844904032113278990\")\n  - [React hooks 最佳实践](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F0sykIHDM_Ih3W3md-DwFkw \"https://mp.weixin.qq.com/s/0sykIHDM_Ih3W3md-DwFkw\")\n\n### 合成事件\n\n合成事件（SyntheticEvent）是 React 模拟原生 DOM 事件所有能力的一个事件对象，即浏览器原生事件的跨浏览器包装器。React 根据 [W3C 规范](https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FTR%2FDOM-Level-3-Events%2F \"https://www.w3.org/TR/DOM-Level-3-Events/\") 定义了合成事件。需要注意的是 v16 和 17 版本中的合成事件有差异。\n\n- 文档\n  - [React 官方文档](https://link.juejin.cn?target=https%3A%2F%2Freactjs.org%2Fdocs%2Fevents.html \"https://reactjs.org/docs/events.html\")\n- 推荐文章\n  - [探索 React 合成事件](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000038251163 \"https://segmentfault.com/a/1190000038251163\")\n  - [大佬，怎么办？升级 React17，Toast 组件不能用了](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F380941094 \"https://zhuanlan.zhihu.com/p/380941094\")\n  - [What’s the Difference Between Synthetic React Events and JavaScript Events?](https://link.juejin.cn?target=https%3A%2F%2Fbetterprogramming.pub%2Fwhats-the-difference-between-synthetic-react-events-and-javascript-events-ba7dbc742294 \"https://betterprogramming.pub/whats-the-difference-between-synthetic-react-events-and-javascript-events-ba7dbc742294\")，需自备梯子\n  - [React 17 removes event pooling in the modern browsers](https://link.juejin.cn?target=https%3A%2F%2Fblog.saeloun.com%2F2021%2F04%2F06%2Freact-17-removes-event-pooling-in-modern-system.html \"https://blog.saeloun.com/2021/04/06/react-17-removes-event-pooling-in-modern-system.html\")\n\n### React 路由\n\n- [react-router](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fremix-run%2Freact-router \"https://github.com/remix-run/react-router\")，React 声明式路由\n- [reach router](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Freach%2Frouter \"https://github.com/reach/router\")，下一代的 React 路由\n\n### React 状态管理\n\nReact 状态管理可谓百花齐放百家争鸣，远远不止笔者列的这些库。但是实际上很多项目完全是不需要用到状态管理的，反而是增加编码复杂度，其实利用 React Context 或者 [react-query](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftannerlinsley%2Freact-query \"https://github.com/tannerlinsley/react-query\") 这类接口请求库就能很好地满足需求了。\n\n- [redux](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Freduxjs%2Fredux \"https://github.com/reduxjs/redux\")，JS 应用的状态容器，提供可预测的状态管理\n- [mobx](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmobxjs%2Fmobx \"https://github.com/mobxjs/mobx\")，简单，可扩展的状态管理库\n- [recoil](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebookexperimental%2FRecoil \"https://github.com/facebookexperimental/Recoil\")，React 状态管理库\n- [xstate](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fstatelyai%2Fxstate \"https://github.com/statelyai/xstate\")，有限状态机\n- [zustand](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fpmndrs%2Fzustand \"https://github.com/pmndrs/zustand\")，简单、快速和可扩展的骨状态管理解决方案\n\n### React 接口请求\n\n- [axios](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faxios%2Faxios \"https://github.com/axios/axios\")，传统接口请求库\n- [react-query](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftannerlinsley%2Freact-query \"https://github.com/tannerlinsley/react-query\")，用于获取、缓存和更新 React 中异步数据的 Hooks 接口请求库\n- [swr](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvercel%2Fswr \"https://github.com/vercel/swr\")，用于数据请求的 React Hooks 库\n\n### React SSR\n\n- [nest.js](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fnestjs%2Fnest \"https://github.com/nestjs/nest\")，一个渐进式的 Node.js 框架，用于构建高效、可靠和可扩展的服务端应用。\n\n### React 单测\n\n- [jest](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Fjest \"https://github.com/facebook/jest\")，优雅、简洁的 JavaScript 测试框架，单测必选项\n- [react-testing-library](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftesting-library%2Freact-testing-library \"https://github.com/testing-library/react-testing-library\")，简单且完整的 React DOM 测试工具\n\n### React CSS 方案\n\n- [styled-components](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fstyled-components%2Fstyled-components \"https://github.com/styled-components/styled-components\")，CSS in JS 方案\n- [tailwindcss](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftailwindlabs%2Ftailwindcss \"https://github.com/tailwindlabs/tailwindcss\")，Atom CSS 方案\n\n### React 原理\n\n- [react-source-code-debug](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fneroneroffy%2Freact-source-code-debug \"https://github.com/neroneroffy/react-source-code-debug\")，学习如何调试源码\n- [react-illustration-series](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2F7kms%2Freact-illustration-series \"https://github.com/7kms/react-illustration-series\")，图解 react 源码，用大量配图的方式，致力于将 react 原理表述清楚\n- [just-react](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FBetaSu%2Fjust-react \"https://github.com/BetaSu/just-react\")，「React 技术揭秘」，一本自顶向下的 React 源码分析书\n- [tiny-react](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FPiNengShaoNian%2Ftiny-react \"https://github.com/PiNengShaoNian/tiny-react\")，基于 React17 精简而来的最小版实现\n\n### Blog 推荐\n\n- [Dan Abramov](https://link.juejin.cn?target=https%3A%2F%2Foverreacted.io%2F \"https://overreacted.io/\")，React 核心开发者的 Blog\n\n## Vue\n\n学习框架务必从[文档](https://link.juejin.cn?target=https%3A%2F%2Fvuejs.org%2F \"https://vuejs.org/\")出发，起码熟读一遍及自己写过一些初步的 Demo 之后再考虑学习别的资料。\n\n对于 Vue 来说，官方文档内容相当齐全，并且全家桶也都是官方出的，因此无需头疼技术栈选型。\n\n### Vue 推荐学习路径\n\n目前 3.0 生态并不完善，在公司内部基本需要先熟悉 2.0 的写法，因此推荐新手先学习 2.0 的内容。\n\n- [新手向：Vue 2.0 的建议学习顺序](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F23134551 \"https://zhuanlan.zhihu.com/p/23134551\")，尤雨溪自己写的学习路径，时至今日也不过时\n\n### Vue 推荐学习资料\n\n- [awesome-vue](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fawesome-vue \"https://github.com/vuejs/awesome-vue\")\n- [vue-patterns](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flearn-vuejs%2Fvue-patterns \"https://github.com/learn-vuejs/vue-patterns\")，有用的 Vue 模式、技巧、提示以及有帮助的精选链接\n\n### Vue 原理\n\n- [vue-analysis](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fustbhuangyi%2Fvue-analysis \"https://github.com/ustbhuangyi/vue-analysis\")，黄老师出品\n- [vue-design](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FHcySunYang%2Fvue-design \"https://github.com/HcySunYang/vue-design\")，官方人员出品，域名已过期，需要大家自行在仓库内浏览内容。虽然麻烦了点，但是质量绝对过关\n\n## 浏览器\n\n一般说到浏览器，常指的都是 Chrome。浏览器作为前端不可或缺的载体，我们势必需要好好学习及掌握其相关的知识。\n\n**另外浏览器中涉及到的知识面很多，与 JS 执行机制、网络、性能优化、安全等领域都有关联，因此大家在学习这部分的内容时需要多与之前学习的知识联系起来。**\n\n### 架构\n\n- [Inside look at modern web browser](https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2018%2F09%2Finside-browser-part1 \"https://developers.google.com/web/updates/2018/09/inside-browser-part1\")，这是一个 Google 出的系列专栏，共有四篇文章，内容上到浏览器的整体架构，下至页面的渲染规则都说了一遍，另有 [中文翻译](https://link.juejin.cn?target=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2Farticle%2F1806716 \"https://cloud.tencent.com/developer/article/1806716\")\n\n### 整体流程\n\n- [浏览器的工作原理：新式网络浏览器幕后揭秘](https://link.juejin.cn?target=https%3A%2F%2Fwww.html5rocks.com%2Fzh%2Ftutorials%2Finternals%2Fhowbrowserswork%2F \"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/\")，这虽然是一篇 11 年的文章，但是内容在如今也不过时，文章广为流传\n- [当···时发生了什么？](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fskyline75489%2Fwhat-happens-when-zh_CN \"https://github.com/skyline75489/what-happens-when-zh_CN\")，经典面试题，文中对于这个流程里的相关内容力求尽可能具体，不遗漏任何细节\n- [从输入 URL 到页面加载完成的过程中都发生了什么事情？](https://link.juejin.cn?target=https%3A%2F%2Ffex.baidu.com%2Fblog%2F2014%2F05%2Fwhat-happen%2F \"https://fex.baidu.com/blog/2014/05/what-happen/\")，这篇文章涉及了大量网络及硬件知识\n\n### 渲染相关\n\n- [浏览器的渲染原理简介](https://link.juejin.cn?target=https%3A%2F%2Fcoolshell.cn%2Farticles%2F9666.html \"https://coolshell.cn/articles/9666.html\")，左耳朵耗子出品，如果上文「浏览器的工作原理：新式网络浏览器幕后揭秘」觉得太长不看或者看完觉得没看懂什么，那么可以来阅读下本文，起码能从中学会一些能用在工作上的东西\n- [浏览器的回流与重绘 (Reflow & Repaint)](https://juejin.cn/post/6844903569087266823 \"https://juejin.cn/post/6844903569087266823\")\n\n### JS 执行机制\n\n- [从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000012925872 \"https://segmentfault.com/a/1190000012925872\")，超长文，这篇文章能让你对进程线程，浏览器多进程、浏览器内核多线程、JS 单线程、JS 运行机制有个不错的理解\n\n### 缓存\n\n- [文档](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCaching \"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching\")\n- [彻底理解浏览器的缓存机制](https://juejin.cn/post/6844903593275817998 \"https://juejin.cn/post/6844903593275817998\")，浏览器缓存机制与性能优化息息相关\n\n### Devtools\n\n- [Chrome DevTools](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.chrome.com%2Fdocs%2Fdevtools%2F \"https://developer.chrome.com/docs/devtools/\")，Google 出的 DevTools 的使用说明书，对于每个功能的使用都有详细的介绍，看啥文章都不如看这个\n- [Chrome\\_Devtools\\_Tricks](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdendoink%2FFrontendWingman%2Ftree%2Fmaster%2FChrome_Devtools_Tricks \"https://github.com/dendoink/FrontendWingman/tree/master/Chrome_Devtools_Tricks\")，介绍了 Chrome DevTools 的使用技巧，从不同的情景来说明应该如何搭配使用 Chrome DevTools 中的小技巧，适合英文不怎么好的读者阅读\n\n### 浏览器安全\n\n- [文档](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FSecurity \"https://developer.mozilla.org/en-US/docs/Web/Security\")\n- [一文读懂 Web 安全](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000023396707 \"https://segmentfault.com/a/1190000023396707\")，简单介绍了一些前端需要注意的安全知识\n- [the-book-of-secret-knowledge](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftrimstray%2Fthe-book-of-secret-knowledge \"https://github.com/trimstray/the-book-of-secret-knowledge\")，如果你对安全领域有兴趣，可以阅读下这个仓库的内容\n\n## 性能优化\n\n性能优化是一个系统性工程，涉及到的方面很多，不仅仅只是大家常说的静态文件和代码优化那么简单。\n\n大家学习这部分内容的时候可以先从推荐的文章中了解具体有哪些性能优化手段及具体方法，然后根据这些内容去实验。\n\n### 推荐书籍\n\n其实性能优化相关的书籍市面上出的不多，优秀的也都是好几年前的老书了，看不看也无所谓了。\n\n- [Web 性能权威指南](https://link.juejin.cn?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F25856314%2F \"https://book.douban.com/subject/25856314/\")，豆瓣 8.9 分，老书\n- [高性能网站建设进阶指南](https://link.juejin.cn?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F4719162%2F \"https://book.douban.com/subject/4719162/\")，豆瓣 8.9 分，老书\n\n### 推荐网站\n\n- [web.dev](https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2F \"https://web.dev/\")，Google 自家的 blog，你能在这上面学到很多性能优化及如何做好用户体验的知识，其实很多市面上的文章内容都有这个网站的影子\n\n### 整体优化建议\n\n- [前端性能优化 24 条建议（2020）](https://juejin.cn/post/6892994632968306702 \"https://juejin.cn/post/6892994632968306702\")，类似现代版雅虎军规\n- [前端性能优化之旅](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Falienzhou%2Ffe-performance-journey \"https://github.com/alienzhou/fe-performance-journey\")，系统性介绍性能优化的手段，参考资料也值得学习\n- [Front-End Performance Checklist 2021](https://link.juejin.cn?target=https%3A%2F%2Fwww.smashingmagazine.com%2F2021%2F01%2Ffront-end-performance-2021-free-pdf-checklist%2F \"https://www.smashingmagazine.com/2021/01/front-end-performance-2021-free-pdf-checklist/\")，一本很火的免费 PDF，包含了很多性能优化相关的 Checklist\n- [React 性能优化 | 包括原理、技巧、Demo、工具使用](https://juejin.cn/post/6935584878071119885 \"https://juejin.cn/post/6935584878071119885\")\n\n### 性能指标\n\n- [文档](https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Flearn-web-vitals%2F \"https://web.dev/learn-web-vitals/\")\n- [还在看那些老掉牙的性能优化文章么？这些最新性能指标了解下](https://juejin.cn/post/6850037270729359367 \"https://juejin.cn/post/6850037270729359367\")，文章会介绍谷歌提倡的七个用户体验指标（也可以认为是性能指标）\n- [做性能优化时，我们关注哪些指标？](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FSlS0J9eSb20PCLW062sQVg \"https://mp.weixin.qq.com/s/SlS0J9eSb20PCLW062sQVg\")\n\n### 性能监控\n\n- [前端搞工程化：从零打造性能检测库「源码 + 视频」](https://juejin.cn/post/6919295789630455815 \"https://juejin.cn/post/6919295789630455815\")，光会性能优化的手段还是不够的，如何体现优化的价值也是至关重要的\n\n## TypeScript\n\nTypeScript 是为开发大型应用而设计的，并且 TypeScript 可转译成 JavaScript。由于 TypeScript 是 JavaScript 的严格超集，任何现有的 JavaScript 程序都是合法的 TypeScript 程序。\n\n文档\n\n- [TypeScript 官方文档](https://link.juejin.cn?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2F \"https://www.typescriptlang.org/docs/\")\n\n推荐文章\n\n- [TypeScript 入门教程](https://link.juejin.cn?target=https%3A%2F%2Fts.xcatliu.com%2F \"https://ts.xcatliu.com/\")\n- [TypeScript 的另一面：类型编程](https://juejin.cn/post/6989796543880495135 \"https://juejin.cn/post/6989796543880495135\")\n- [TypeScript Deep Dive](https://link.juejin.cn?target=https%3A%2F%2Fbasarat.gitbook.io%2Ftypescript%2F \"https://basarat.gitbook.io/typescript/\") 另有[中文版](https://link.juejin.cn?target=https%3A%2F%2Fjkchao.github.io%2Ftypescript-book-chinese%2F \"https://jkchao.github.io/typescript-book-chinese/\")\n\n推荐开源项目\n\n- [TypeScript-for-Beginner-Programmers](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fchibicode%2FTypeScript-for-Beginner-Programmers \"https://github.com/chibicode/TypeScript-for-Beginner-Programmers\") 需自备梯子\n- [type-challenges](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftype-challenges%2Ftype-challenges \"https://github.com/type-challenges/type-challenges\")\n- [TypeScript exercises](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftypescript-exercises%2Ftypescript-exercises \"https://github.com/typescript-exercises/typescript-exercises\")\n\n## Electron\n\nElectron 是一个可以使用 Web 技术如 JavaScript、HTML 和 CSS 来创建跨平台原生桌面应用的框架。借助 Electron，我们可以使用纯 JavaScript 来调用丰富的原生 APIs。\n\n文档\n\n- [Electron 官网](https://link.juejin.cn?target=https%3A%2F%2Fwww.electronjs.org%2F \"https://www.electronjs.org/\")\n- [Electron 中文教程](https://link.juejin.cn?target=https%3A%2F%2Fweishuai.gitbooks.io%2Felectron-%2Fcontent%2F \"https://weishuai.gitbooks.io/electron-/content/\")\n\n推荐文章\n\n- [分享这半年的 Electron 应用开发和优化经验](https://juejin.cn/post/6844904029231775758 \"https://juejin.cn/post/6844904029231775758\")\n- [用 JS 开发跨平台桌面应用，从原理到实践](https://juejin.cn/post/6844903862302670862 \"https://juejin.cn/post/6844903862302670862\")\n- [Building a desktop application with Electron](https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fdevelopers-writing%2Fbuilding-a-desktop-application-with-electron-204203eeb658 \"https://medium.com/developers-writing/building-a-desktop-application-with-electron-204203eeb658\") 需翻墙访问\n\n推荐开源项目\n\n- [Electron 资源](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsindresorhus%2Fawesome-electron \"https://github.com/sindresorhus/awesome-electron\")\n- [Electron Playground](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftal-tech%2Felectron-playground \"https://github.com/tal-tech/electron-playground\")\n- [electron-vue-cloud-music](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxiaozhu188%2Felectron-vue-cloud-music \"https://github.com/xiaozhu188/electron-vue-cloud-music\")\n- [electron-builder](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Felectron-userland%2Felectron-builder \"https://github.com/electron-userland/electron-builder\")\n\n## 组件库\n\n组件库顾名思义指的就是将多个公共模块或者可复用的组件提取整合生成的一个仓库\n\n知名度较广的组件库：\n\n- [antd](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fant-design%2Fant-design.git \"https://github.com/ant-design/ant-design.git\")\n- [elementUI](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FElemeFE%2Felement.git \"https://github.com/ElemeFE/element.git\")\n\n相关文档：\n\n- [lerna](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flerna%2Flerna \"https://github.com/lerna/lerna\")\n- [angular commit 规范](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fangular%2Fangular%2Fblob%2Fmaster%2FCONTRIBUTING.md%23commit \"https://github.com/angular/angular/blob/master/CONTRIBUTING.md#commit\")\n- [yarn](https://link.juejin.cn?target=https%3A%2F%2Fyarnpkg.com%2F \"https://yarnpkg.com/\")\n- [css variables](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FCSS%2FUsing_CSS_custom_properties \"https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties\")\n\n推荐文章：\n\n- [从 0 到 1，搭建一个体系完善的前端 React 组件库](https://link.juejin.cn?target=https%3A%2F%2Fwww.infoq.cn%2Farticle%2Fi4q9ybdmxzmu8eex8qvh \"https://www.infoq.cn/article/i4q9ybdmxzmu8eex8qvh\")\n- [如何规范你的 Git commit？](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F182553920 \"https://zhuanlan.zhihu.com/p/182553920\")\n- [基于 lerna 和 yarn workspace 的 monorepo 工作流](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F71385053 \"https://zhuanlan.zhihu.com/p/71385053\")\n- [FusionNext 可配置能力从 Sass 体系升级为支持 Css Variable](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F257159028 \"https://zhuanlan.zhihu.com/p/257159028\")\n\n## 微前端\n\n是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将单页面前端应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。\n\n优势：\n\n- 代码库更小，更内聚、可维护性更高\n- 松耦合、自治的团队可扩展性更好\n- 渐进地升级、更新甚至重写部分前端功能成为了可能\n- 独立开发部署，缩小变更范围，进而降低相关风险\n\n框架：\n\n- [single-spa](https://link.juejin.cn?target=https%3A%2F%2Fsingle-spa.js.org%2F \"https://single-spa.js.org/\")\n- [蚂蚁-乾坤](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fumijs%2Fqiankun \"https://github.com/umijs/qiankun\")\n- [淘系-icestark](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fice-lab%2Ficestark \"https://github.com/ice-lab/icestark\")\n- [字节-Garfish](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmodern-js-dev%2Fgarfish \"https://github.com/modern-js-dev/garfish\")\n- [京东-micro-app](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmicro-zoe%2Fmicro-app \"https://github.com/micro-zoe/micro-app\")\n- [Bit](https://link.juejin.cn?target=https%3A%2F%2Fbit.dev \"https://bit.dev\")\n- [EMP - Micro Frontends solution](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FefoxTeam%2Femp \"https://github.com/efoxTeam/emp\") 基于 webpack 5 & module federation\n\n推荐文章：\n\n- [从零到一实现企业级微前端框架，保姆级教学](https://juejin.cn/post/7004661323124441102 \"https://juejin.cn/post/7004661323124441102\")\n- [字节跳动是如何落地微前端的](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FL9wbfNG5fTXF5bx7dcgj4Q \"https://mp.weixin.qq.com/s/L9wbfNG5fTXF5bx7dcgj4Q\")\n- [What Are Micro Frontends?](https://link.juejin.cn?target=https%3A%2F%2Flivebook.manning.com%2Fbook%2Fmicro-frontends-in-action%2Fchapter-1%2Fv-4%2F \"https://livebook.manning.com/book/micro-frontends-in-action/chapter-1/v-4/\")\n- [Bifrost 微前端框架及其在美团闪购中的实践](https://link.juejin.cn?target=https%3A%2F%2Ftech.meituan.com%2F2019%2F12%2F26%2Fmeituan-bifrost.html \"https://tech.meituan.com/2019/12/26/meituan-bifrost.html\")\n- [每日优鲜供应链前端团队微前端改造](https://juejin.cn/post/6844903943873675271 \"https://juejin.cn/post/6844903943873675271\")\n- [微前端在美团外卖的实践](https://link.juejin.cn?target=https%3A%2F%2Ftech.meituan.com%2F2020%2F02%2F27%2Fmeituan-waimai-micro-frontends-practice.html \"https://tech.meituan.com/2020/02/27/meituan-waimai-micro-frontends-practice.html\")\n- [How We Build Micro Frontends](https://link.juejin.cn?target=https%3A%2F%2Fblog.bitsrc.io%2Fhow-we-build-micro-front-ends-d3eeeac0acfc \"https://blog.bitsrc.io/how-we-build-micro-front-ends-d3eeeac0acfc\")\n- [Revolutionizing Micro Frontends with Webpack 5, Module Federation and Bit](https://link.juejin.cn?target=https%3A%2F%2Fblog.bitsrc.io%2Frevolutionizing-micro-frontends-with-webpack-5-module-federation-and-bit-99ff81ceb0 \"https://blog.bitsrc.io/revolutionizing-micro-frontends-with-webpack-5-module-federation-and-bit-99ff81ceb0\")\n\n### 推荐学习资料\n\n- [microfrontend-resources](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbillyjov%2Fmicrofrontend-resources \"https://github.com/billyjov/microfrontend-resources\") ，? 关于微前端的各类资料推荐\n\n## 跨端框架\n\n跨端的最主要的含义就是一套代码多端运行，减少重复劳动\n\n目前看来，国内比较流行的是小程序, H5, App 三端跨的框架， [uniapp](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdcloudio%2Funi-app \"https://github.com/dcloudio/uni-app\") 及 [taro](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FNervJS%2Ftaro \"https://github.com/NervJS/taro\") 是其中做的比较出彩的两个框架。当然在 taro3.0 之前（以下主要是说小程序），taro 跟 uniapp 都是使用编译时做更多的事情，编译成小程序能够运行的代码。\n\n而在 taro3.0 之后变成了与 [remax](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fremaxjs%2Fremax \"https://github.com/remaxjs/remax\") 相同的思想，在运行时做更多的事情，保证了原框架代码能够完全使用，而不需要为了转换成其他小程序时做兼容。\n\n- [awesome-remax](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fremaxjs%2Fawesome-remax \"https://github.com/remaxjs/awesome-remax\")\n- [美团自研 react 跨端](https://link.juejin.cn?target=https%3A%2F%2Ftech.meituan.com%2F2021%2F06%2F10%2Freact-native-hybrid-practice-dsl-in-meituan.html \"https://tech.meituan.com/2021/06/10/react-native-hybrid-practice-dsl-in-meituan.html\")\n- [京东 taro](https://juejin.cn/post/6844904036743774216 \"https://juejin.cn/post/6844904036743774216\")\n\n## 监控\n\n当业务进入稳定，最需要做的肯定是对于业务线上的各种性能、异常及常规业务进行监控，避免在上线之后成为瞎子。\n\n目前市场比较出名的监控系统：\n\n- [sentry](https://link.juejin.cn?target=https%3A%2F%2Fsentry.io%2Fwelcome%2F \"https://sentry.io/welcome/\")\n- [ali node](https://link.juejin.cn?target=https%3A%2F%2Fwww.aliyun.com%2Fproduct%2Fnodejs \"https://www.aliyun.com/product/nodejs\")\n- [bugly](https://link.juejin.cn?target=https%3A%2F%2Fbugly.qq.com%2Fv2%2F \"https://bugly.qq.com/v2/\")\n- [mixpanel](https://link.juejin.cn?target=https%3A%2F%2Fmixpanel.com%2F \"https://mixpanel.com/\")\n- [听云](https://link.juejin.cn?target=https%3A%2F%2Fwww.tingyun.com%2F \"https://www.tingyun.com/\")\n\n推荐开源库：\n\n- [rrweb](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Frrweb-io%2Frrweb \"https://github.com/rrweb-io/rrweb\")，提供像素级的录制与回放，帮助正确定位问题是如何发生的\n- [monitor](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FclouDr-f2e%2Fmonitor \"https://github.com/clouDr-f2e/monitor\")，? 一款轻量级的收集页面的用户点击行为、路由跳转、接口报错、代码报错、并上报服务端的 SDK\n- [mitojs](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmitojs%2Fmitojs \"https://github.com/mitojs/mitojs\") 上面 `monitor` 作者新维护的库。全新插拔式的监控 SDK，代码架构更清晰，配置项更丰富，高度可定制化\n\n推荐文章：\n\n- [美团可视化埋点方案](https://link.juejin.cn?target=https%3A%2F%2Ftech.meituan.com%2F2019%2F08%2F15%2Fmtflexbox-automation-buried-point-exploration.html \"https://tech.meituan.com/2019/08/15/mtflexbox-automation-buried-point-exploration.html\")\n- [如何进行 web 性能监控？](https://link.juejin.cn?target=http%3A%2F%2Fwww.alloyteam.com%2F2020%2F01%2F14184%2F%23prettyPhoto \"http://www.alloyteam.com/2020/01/14184/#prettyPhoto\")\n- [蚂蚁金服如何把前端性能监控做到极致?](https://link.juejin.cn?target=https%3A%2F%2Fwww.infoq.cn%2Farticle%2Fdxa8am44oz*lukk5ufhy \"https://www.infoq.cn/article/dxa8am44oz*lukk5ufhy\")\n- [如何做前端异常监控？](https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F29953354 \"https://www.zhihu.com/question/29953354\")\n- [前端监控平台系列：JS SDK（已开源）](https://juejin.cn/post/6862559324632252430#heading-17 \"https://juejin.cn/post/6862559324632252430#heading-17\")\n\n## 日常充电\n\n- [Best-websites-a-programmer-should-visit](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsdmg15%2FBest-websites-a-programmer-should-visit \"https://github.com/sdmg15/Best-websites-a-programmer-should-visit\")，优秀的工程师都应该阅读的网站\n\n### CSS 日常充电\n\n- [You-need-to-know-css](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fl-hammer%2FYou-need-to-know-css \"https://github.com/l-hammer/You-need-to-know-css\")\n- [CSS Inspiration](https://link.juejin.cn?target=https%3A%2F%2Fcsscoco.com%2Finspiration%2F%23%2F \"https://csscoco.com/inspiration/#/\")\n- [CSS Tricks](https://link.juejin.cn?target=https%3A%2F%2Fqishaoxuan.github.io%2Fcss_tricks%2F \"https://qishaoxuan.github.io/css_tricks/\")\n- [spinkit](https://link.juejin.cn?target=https%3A%2F%2Ftobiasahlin.com%2Fspinkit%2F \"https://tobiasahlin.com/spinkit/\") 需自备梯子\n- [animista](https://link.juejin.cn?target=https%3A%2F%2Fanimista.net%2F \"https://animista.net/\")\n\n## Github 优秀学习资料\n\n### JS 优秀学习资料\n\n- [33-js-concepts](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fleonardomso%2F33-js-concepts \"https://github.com/leonardomso/33-js-concepts\")\n- [JavaScript 安全指南](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FTencent%2Fsecguide%2Fblob%2Fmain%2FJavaScript%25E5%25AE%2589%25E5%2585%25A8%25E6%258C%2587%25E5%258D%2597.md%231.1 \"https://github.com/Tencent/secguide/blob/main/JavaScript%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97.md#1.1\")\n- [What the f\\*ck JavaScript?](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdenysdovhan%2Fwtfjs \"https://github.com/denysdovhan/wtfjs\")，有趣的 JavaScript 示例列表，附有解释\n- [clean-code-javascript](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fryanmcdermott%2Fclean-code-javascript \"https://github.com/ryanmcdermott/clean-code-javascript\")，适应于 JavaScript 的优雅代码建议\n\n### React 优秀学习资料\n\n- [react-philosophies](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmithi%2Freact-philosophies \"https://github.com/mithi/react-philosophies\")，React 哲学，内容为写 React 代码时思考的事情\n\n### 代码样式及安全\n\n- [secguide](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FTencent%2Fsecguide \"https://github.com/Tencent/secguide\")，面向开发人员梳理的代码安全指南\n\n## 生产力工具\n\n### 流程图\n\n- [whimsical](https://link.juejin.cn?target=https%3A%2F%2Fwhimsical.com%2F \"https://whimsical.com/\")\n\n## 最后\n\n内容其实目前只能算作是第一版，并不完善，欢迎大家参与投稿内容。','2021-10-11 03:30:00',0000000002,'前端',12),(0000000003,'浅谈前端常用设计模式之一：策略模式','2022年，前端技术依旧日新月异，各种新兴技术或业务解决方案层出不穷。但我始终认为，在变与不变之间，唯有经典永恒，设计模式就是经典之一。','前言\n\n2022年，前端技术依旧日新月异，各种新兴技术或业务解决方案层出不穷。但我始终认为，在变与不变之间，唯有经典永恒，设计模式就是经典之一。在笔者从业期间，见过很多不同人写的代码，层次有高有低，将设计模式运用地行云流水的大佬，写出的代码总是令人觉着舒适优雅，有时恨不得顿足品读一番，相传小米创始人雷军写的代码就如同诗一般优雅；相反，不懂设计模式的开发者写出的代码总是一言难尽，甚至没有看下去的欲望，恨不得当场重构。。。\n\n1995 年，GoF四人组开创性地提出 23 种设计模式，设计模式是前辈们对代码开发经验的总结，是解决特定问题的一系列套路，是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。站在巨人的肩膀上，能少走很多弯路，看到更多别样的风景。\n\n本系列文章，笔者将会介绍在前端开发过程中，十分实用的一些设计模式，欢迎各位大佬补充讨论，本篇文章将介绍笔者最青睐的策略模式。\n\n## 策略模式（if-else的救世主)\n\n策略模式（Strategy Pattern）指的是定义一系列的算法，把它们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。\n\n这里所指的算法，类似于一个策略，**策略模式的核心思想**就是在一个计算方法中把容易变化的算法抽出来作为“策略”参数传进去，从而使得新增策略不必修改原有逻辑。\n\n本质上来看就是我们老生常谈的解耦。如果一个复杂的系统，如果所有策略都耦合在业务逻辑里，日复一日随着需求的改变和增加，代码越来越庞杂，可维护性越来越低，但如果将策略与业务解耦，我们就可以独立维护这些策略，为业务带来更灵活的变化。\n\n### 实际操作\n\n举一个比较常见的例子，我们会遇到枚举值转换的问题，比如下面我们需要维护一个优惠券的类型，简单粗暴的想我们会直接用if-else直接梭哈。\n\n```\nconst getCouponText = (type) => {\n    if (type === 1) {\n        return \'免费券\'\n    } else if (type === 2) {\n        return \'立减券\'\n    } else if (type === 3) {\n        return \'折扣券\'\n    }\n    ...\n}\n复制代码\n```\n\n但如果我们想要我们的代码可维护性更高的话，首先我们需要对这个枚举值做一个统一的维护管理（枚举值统一管理是笔者推荐的，可以使得代码更语义化，不属于策略模式的内容），提升代码的可读性，然后使用**对象映射**来将逻辑分离出来，解放了if-else，特别是逻辑非常重的时候，用这个方法逻辑更为清晰明了。\n\n```\nconst COUPON_TYPE = {\n    FREE: 1, // 免费\n    DISCOUNT: 2, // 折扣\n    REDUCE: 3, // 立减\n};\nconst COUPON_TYPES = {\n    [COUPON_TYPE.FREE]: \'免费券\',\n    [COUPON_TYPE.DISCOUNT]: \'折扣券\',\n    [COUPON_TYPE.REDUCE]: \'立减券\'\n}\nconst getCouponText = (type) => {\n    return COUPON_TYPES[type]||\'\'\n}\n复制代码\n```\n\n在具体的业务中，我们也会使用到这些枚举值，来对不同的枚举进行不同的操作判断，这时候我们往往又会写一些if-else判断逻辑，随着业务类型的增加，我们只能不停地往里面堆代码\n\n```\nconst handleType = (type) => {\n    if (type === 1) {\n        do sth\n        do sth\n    } else if (type === 2) {\n        do sth\n        do sth\n    } else if (type === 3) {\n        do sth\n        do sth\n    }\n    ...\n}\n复制代码\n```\n\n同样地，我们使用策略模式也可以将这段代码变得更为优雅，使用一个对象专门用来维护这些对应的方法事件，每个类型对应一个方法，遵循了单一原则。\n\n```\nconst couponFunctions = {\n    [COUPON_TYPE.FREE]: () => { do sth},\n    [COUPON_TYPE.DISCOUNT]: () => { do sth },\n    [COUPON_TYPE.REDUCE]: () => { do sth }\n}\nconst handleType = (type) => {\n    couponFunctions[type] && couponFunctions[type]()\n}\n复制代码\n```\n\n笔者认为策略模式是非常好用的，特别是对于一些比较\"重\"的逻辑，各种if-else乱象，使用策略模式能够让代码更通俗易懂，每次改动代码的时候，只需要修改对应的内容就行，不至于在庞杂的逻辑下慌乱了阵脚。\n\n## 感谢观看\n\n本篇文章只介绍了策略模式，但其实另外很多设计模式也比较实用，比如观察者模式、原型模式、代理模式、装饰器模式、单例模式等，都能给我们书写代码带来新的思路和方案，有兴趣的话大家可以继续了解下，我抽时间也会把相关内容补上来和大家一起学习探讨。\n\n最后，感谢观看。我是阿李贝斯，如果你觉得本篇文章对你有帮助的话，欢迎收藏点赞，我会更有动力进行知识输出，希望和掘金的各位大佬一起共同进步，用知识对抗未知！','2022-07-27 09:05:00',0000000001,'前端',31),(0000000004,'如何写出不可维护的Vue代码','不止一次接手过复杂业务功能模块，开端总是深陷其中难以自拔，无数个深夜抚摸着头皮在内心暗暗咒骂。','### 前言\n\n不止一次接手过复杂业务功能模块，开端总是深陷其中难以自拔，无数个深夜抚摸着头皮在内心暗暗咒骂。\n\n相信你也有过类似的经历，面对复杂的业务逻辑，**看代码俩小时，写代码五分钟，没有点胆识和谋略都不敢下手**。\n\n最近总结复盘了一下，以备后用，如果有喜欢的同事想坑他一把，可以按照此方法实践(不保证100%成功)，个人拙见，如有不当望指正。\n\n### 目录\n\n1.  data属性数量过多\n2.  组件入参数量过多\n3.  mixins和业务代码耦合\n4.  不要封装纯函数\n5.  数据结构尽量复杂\n6.  不写注释或写无法理解的注释\n7.  将前端逻辑变重\n8.  不封装mixins与组件\n\n## 正文\n\n### 1、data属性数量过多\n\n要多用data属性，放置一些用不到的key，让属性看起来更丰富，增加理解成本。\n\n最好一打开页面前100行都是data属性，让维护或者参与该组件开发的人员望而生畏，瞬间对组件肃然起敬。\n\n这符合代码的坏味道所描述的：\n\n> 良药与毒药的区别在于剂量。有少量的全局数据或许无妨，**但数量越多，处理的难度就会指数上升。**\n\n如图所示，效果更佳：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c77c98cac0da4e23977cc74d68fc0876~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 2、组件入参数量过多\n\ndata属性的问题是在一个组件内，看多了加上注释可能就理解，而组件增加过多的props入参恰好能避免这个问题，**过多的入参可以让理解变得更困难，要先理解父组件内绑定的值是什么，再理解子组件内的入参用做什么**。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41dfb06081b94ae9a66a6d1476a420cc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n当然了，还有高阶一点的用法，就是让父组件的值和子组件的props名称不一致，这样做就更有趣了，难度陡增。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41c5f208a96149c1822396c194b3ef0d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 3、mixins与业务代码耦合\n\n**合理封装mixins能让代码变得更容易复用和理解，这不是我们想要的**，让mixins与业务组件的代码耦合在一起，可以达到事倍功半的效果。\n\n常规的做法是业务组件调用mixins的方法和变量，我们反其道而行之，让mixins调用组件中的方法和变量，然后让mixins多出引用，**虽然看起来像mixins，但是并没有mixins的功能**，让后期有心想抽离封装的人也无从下手。\n\n小Tips：常见的mixins方法会加上特殊前缀与组件方法区分，我们可以不使用这个规范，让mixins方法更难被发现。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28f46dadf52242ce95eac22c1742d6e2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 4、不要封装纯函数\n\n如果有一个很重要的业务组件可读性很差，势必要小步快跑的迭代重构，这种情况也不用怕，我们**一个微小的习惯就可以让这件事情变得困难重重，那就是不要封装纯函数方法**。\n\n**纯函数的好处是不引用其他变量，可以轻易的挪动和替换；** 让每个方法尽量引用data属性，当他人想迁移或替换你的方法时，就要先理解引用的属性和全局变量，再进一步，可以在方法里再引入mixnins里的变量和方法，这个小习惯就会让他们望而却步。\n\n### 5、数据结构尽量复杂\n\n让数据结构变复杂绝对是一个必杀技，**数据结构随随便便循环嵌套几层**，自己都能绕晕。\n\n再加上一些骚操作，递归遍历加一些判断和删减，**写上让人难以琢磨的注释**，哪怕是高级工程师或是资深工程师都需要狠狠的磕上一段时间才能摸清真正的业务逻辑是什么。\n\n这种方式还有另外一个优点，就是自己可能也会被绕晕，一起陷入有趣的逻辑梳理游戏。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc98d20ade67401db90a54b92cad0eb5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 6、不写注释或写无法理解的注释\n\n如果其他方式都复杂且耗时，那这种方法简直是高效的存在，**只需要胡乱的写一些让别人看不懂或容易误解的注释**，就可轻松把接手代码的同事KO掉。\n\n这个技能也看个人发挥的水平了，你也可以在注释中恐吓、劝阻参与开发人员改动功能代码，煽动开发人员放弃修改，让其内心崩溃。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7398c6390f3c4740b7a3e36de9db7102~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 7、让前端逻辑变重\n\n良好的分层设计能够让系统变得简洁和健壮；为了凸显前端的重要性，**应该将逻辑一股脑的承接到前端，让前端逻辑变重**，尤其是写一些特殊的编码配置和奇葩规则。\n\n不要和产品、后端讲述这件事情的不合理性，统统塞到前端，当需求被重新讨论时，他们会把特殊逻辑忘的一干二净，而你可以根据代码翻出一大堆，这样你就显得尤为重要了。\n\n### 8、不封装mixins与组件\n\n如果要让功能变得复杂，就不要拆分UI组件和业务组件，更不要按照业务抽离可复用的mixins方法，让组件尽量大，轻则一两千行，重则五六千行，不设上限，统统塞到一个组件里。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9084c89503264daeb00c93ef61757149~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 结尾\n\n结合自己的踩坑经历写了这边偏笔记，调侃之处，纯属娱乐。 你有没有遇上过类似的场景，你的感受如何？又是如何解决的呢？敢不敢点个赞，一起评论区讨论。','2022-07-13 03:25:00',0000000003,'前端',35),(0000000005,'使用CSS实现“文段尾行渐变消失”','文章来源于最近解决的一个需求，让一段文案的尾行渐变消失，解决的时候了解到了很多新的知识点，所以记录下来。','导语 文章来源于最近解决的一个需求，让一段文案的尾行渐变消失，解决的时候了解到了很多新的知识点，所以记录下来。\n\n## **问题描述**\n\n最近在做H5的页面的时候，遇到了这样的一个需求：\n\n在一个展示信息的页面，为了提升用户体验，希望在展示一个文段信息的时，只展示指定行数，将超出行数隐藏，并且如果有超出的行数，则展示文段的尾行渐变消失，并加上一个扩展按钮，提醒用户有未展示完整的信息。\n\n说起来比较绕，大概就是这样一个效果\n\n![图片.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8018b81ee8ac453aad3590119a6b66dd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n## 使用遮罩\n\n第一眼看起来还是比较好处理，因为文段消失的感觉，就有点像一个遮罩蒙层，所以我第一反应也是，使用一个遮罩层来处理。\n\n具体处理方式就是，在右下角放一个div，设置和背景相同的颜色，并且设置成左往右的渐变消失，盖住文字就可以，于是就有了这样的效果。\n\n![图片.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c7fecd233ad4192a0b4aa9117d4d953~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n这里的expand下面盖住的是一块渐变的盒子\n\n```\n.mask {\n		width:500px;\n		height: 36px;\n		position: absolute;\n		background: linear-gradient(90deg, transparent 10%, rgba(84, 105, 136) 70%);\n		right: 0;\n		bottom: 107px;\n		font-size: 22px;\n		font-weight: 700;\n		z-index: 332;\n}\n复制代码\n```\n\n 看起来好像比较完美的实现了，但是有个问题，渐变盒子之所以能完美覆盖最后一行文段，是因为它的颜色和背景完全相同，如果背景是渐变的，或者是一张图片，就会有问题，比如像这样。\n\n![图片.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab558e9d912b40b580b9051ff03eb574~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n这里我其实还想过，既然背景不能融合会导致渐变盒子浮出文段，那么我可以直接在文段对应位置切出一块能融合的背景，或者说设置对应的渐变色，这样就能够解决浮层。\n\n但是产品告诉我，父级渐变背景是有滚动条的，所以文段的背景色还会改变，所以不能写死这块的颜色，还是需要对应的获取。\n\n## 行内元素的渐变背景\n\n 我们在给行内元素设置背景时，它不会像块级元素一样，直接获取到背景，行内元素获取背景，是默认先让整个DOM不换行，获取到背景色之后，再默认换行，所以如果对其设置渐变背景的话，就会有这种效果。\n\n![图片.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e9351286de448f987fb856fdc16532c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n利用这个效果，我们可以在文段的上方覆盖一层文字内容和大小相同的行内元素，将其文字颜色设置为透明，然后设置一个渐变的背景色，通过调整背景色的区域来实现文段的尾行渐变，效果如下。\n\n![图片.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c4bbe7c4ee9441ba99a62dc2710f55a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n核心代码如下\n\n```\n span {\n			background: linear-gradient(90deg, transparent 80%, orange);\n			background-size: 100% 100%;\n			background-repeat: no-repeat;\n			background-position: 100% 100%;\n			cursor: pointer;\n\n			color: transparent;\n			font-size: 24px;\n			z-index: 4;\n\n		}\n		span::before {\n			content: \"Mollitia nostrum placeat consequatur deserunt velit ducimus possimus commodi      temporibus debitis quam commodi temporibus debitis quam debitis\";\n			position: absolute;\n			top: 0;\n			left: 0;\n			color: #000;\n			z-index: -1;\n		}\n复制代码\n```\n\n  其实可以看到，这里的效果就会比前面的遮罩的方法要好一点，但是即使这里的颜色控制的与背景很接近，也依然会有一点浮层的感觉。\n\n除此之外，我们用来遮罩的盒子，为了和底层文段大小一致，需要填入相同的内容，这其实看起来非常的冗余，最致命的是，这个方法直对横向的渐变起作用，所以我们需要寻求更合适的方法。\n\n## 遮罩mask\n\n Css的mask属性是个啥呢，MDN给出的介绍是：Css 属性 **`mask`** 允许使用者通过遮罩或者裁切特定区域的图片的方式来隐藏一个元素的部分或者全部可见区域。简言之，我们可以通过在元素上设置这个属性，来隐藏该元素的一部分。\n\n如果我们直接用在文段上，就可以得到这样的效果。\n\n![图片.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5c242b0ab89442897a7e761fffddecf~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n有了这个属性，顿时感觉问题解决了一大半，在使用的时候，我们就不再需要再去添加一个用于蒙层的盒子，而是只需要在文段上使用mask加上一层遮罩。\n\n但是mask在单独使用的时候，会默认设置100%的宽高，所以这里需要多定义一个来将另一个遮罩来占据剩下的位置，所以这里一共定义了两个遮罩，一个在上方，一个在末行。\n\n最终的效果:\n\n![图片.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15f972240d7243e1972b95a18edf95f2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n最终的代码：\n\n```\np {\n	margin: auto;\n	width: 450px;\n	line-height: 36px;\n	font-size: 20px;\n	-webkit-mask:linear-gradient(270deg, transparent, transparent 30%, #000),\n	linear-gradient(270deg, #000, #000);\n	-webkit-mask-size: 100% 66px, 100% calc(100% - 46px);\n	-webkit-mask-position: bottom, top;\n	-webkit-mask-repeat: no-repeat;\n}\n复制代码\n```\n\n 由于支持性不够完善，所以这里在编写的时候还需要加上前缀，这里一共定义了两个遮罩，一个在上方，一个在末行，原因是mask在单独使用的时候，会默认设置100%的宽高，所以这里需要多定义一个来将另一个遮罩推到我们需要的位置。\n\n当然，有关于Mask，还有很多非常不错的用法\n\n*   比如丝滑的融合两张图片\n\n![图片.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be2ff9e57a2d457192c47428733cb335~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n*   制作渐变过渡\n\n![608782-20200706102148459-453233707.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/626ff86535e04bfb8e07af4aa2f17280~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n有有兴趣的可以去看看这篇文档：[www.cnblogs.com/coco1s/p/13…](https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fcoco1s%2Fp%2F13253423.html \"https://www.cnblogs.com/coco1s/p/13253423.html\")\n\n## 最后\n\n虽然有几种方法没能解决问题，不过倒是带给我一些场景的实现灵感，也然我学习到了一些新的css知识，本文到这里就结束了，希望我解决问题的过程对你能有所帮助，关于文本末行渐变消失的问题，如果你有比较好的方法，欢迎在评论区留言讨论\n\n参考链接：\n\n[github.com/chokcoco/iC…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fchokcoco%2FiCSS \"https://github.com/chokcoco/iCSS\")','2022-07-26 09:33:00',0000000004,'前端',23),(0000000006,'适合初学者的 10 个JavaScript 代码整洁技巧','什么是整洁的代码呢？答案可能因人而异，个人提倡以函数式风格编写代码，如果做得正确的话，代码将更容易阅读、分解和测试。在开始函数式编程之前，学习一些小的技巧有助于编写整洁的代码。','> 什么是整洁的代码呢？答案可能因人而异，个人提倡以函数式风格编写代码，如果做得正确的话，代码将更容易阅读、分解和测试。在开始函数式编程之前，学习一些小的技巧有助于编写整洁的代码。最好的方式是阅读开源项目，学习别人的方式。对于JavaScript，ES6 引入了许多新的特性，也使得写代码多一种更加优雅的方式。\n\n阅读代码，可以站在巨人的肩膀上快速成长的有效方法，GitHub 是程序员学习的首选资源站。\n\n### 1\\. 数组合并\n\n```\n// 常规逻辑\nconst apples = [\"?\", \"?\"];\nconst fruits = [\"?\", \"?\", \"?\"].concat(apples);\n\nconsole.log(fruits); // [\"?\", \"?\", \"?\", \"?\", \"?\"];\n\n// 优雅写法 1\nconst apples = [\"?\", \"?\"];\nconst fruits = [\"?\", \"?\", \"?\", ...apples];\n\nconsole.log(fruits); //  [\"?\", \"?\", \"?\", \"?\", \"?\"];\n\n// 优雅写法 2\nconst apples = [\"?\", \"?\"];\nconst fruits = [...apples, \"?\", \"?\", \"?\"];\nconsole.log(fruits); // [\"?\", \"?\", \"?\", \"?\", \"?\"];\n\n// 优雅去重\nconst apples = [\"?\", \"?\", \"?\"];\nconst fruits = [...new Set([\"?\", \"?\", \"?\", \"?\", ...apples])];\nconsole.log(fruits); // [ \'?\', \'?\', \'?\', \'?\', \'?\' ]\n复制代码\n```\n\n### 2\\. 数组中取值\n\n```\n// 常规逻辑\nconst apples = [\"?\", \"?\"];\nconst redApple = apples[0];\nconst greenApple = apples[1];\n\nconsole.log(redApple); // ?\nconsole.log(greenApple); // ?;\n\n// 优雅写法\nconst apples = [\"?\", \"?\"];\nconst [redApple, greenApple] = apples; // 使用解构赋值\n\nconsole.log(redApple); // ?\nconsole.log(greenApple); // ?;\n复制代码\n```\n\n### 3\\. 对象取值\n\n```\n// 常规逻辑\nconst user = {\n    name: \"DevPoint\",\n    age: 30,\n};\n\nconst name = user.name; // DevPoint\nconst age = user.age; // 30\nconsole.log(name);\nconsole.log(age);\n\n// 优雅写法\nconst user = {\n    name: \"DevPoint\",\n    age: 30,\n};\n\nconst { name, age } = user;\n\nconsole.log(name); // DevPoint\nconsole.log(age); // 30\n复制代码\n```\n\n### 4\\. 数组循环\n\n数组循环的方法有 `.forEach()` 与 `for...of`，在使用上各有特色，但在效率上，`for...of` 比 `.forEach()` 快。因此推荐使用 `for...of`。\n\n```\n// 常规逻辑\nconst fruits = [\"?\", \"?\", \"?\", \"?\"];\n\nfor (let i = 0; i < fruits.length; i++) {\n    console.log(fruits[i]);\n}\n\n// 优雅写法\nconst fruits = [\"?\", \"?\", \"?\", \"?\"];\n\nfor (fruit of fruits) {\n    console.log(fruit);\n}\n复制代码\n```\n\n### 5\\. 箭头函数作为回调\n\n箭头函数是 ES6 中引入新的语法，除了让代码变得优雅的同时，可以避免 `this` 带来的问题。\n\n```\n// 常规逻辑\nconst fruits = [\"?\", \"?\", \"?\", \"?\"];\n\nfruits.forEach(function (fruit) {\n    console.log(fruit);\n});\n\n// 优雅写法\nconst fruits = [\"?\", \"?\", \"?\", \"?\"];\nfruits.forEach((fruit) => console.log(fruit));\n复制代码\n```\n\n### 6\\. 数组搜索\n\n数组操作，在前端开发中是比较常见的功能，为了提高开发效率降低重复代码，可以考虑写一个通用的数组操作的脚本库。\n\n假设需要通过一个对象的属性从一个对象数组中查找一个对象，通常使用 for 循环：\n\n```\n// 常规逻辑\nconst inventory = [\n    { name: \"Bananas\", quantity: 5 },\n    { name: \"Apples\", quantity: 10 },\n    { name: \"Grapes\", quantity: 2 },\n];\n\n// Get the object with the name `Apples` inside the array\nfunction getApples(arr, value) {\n    for (let index = 0; index < arr.length; index++) {\n        if (arr[index].name === \"Apples\") {\n            return arr[index];\n        }\n    }\n}\n\nconst result = getApples(inventory);\nconsole.log(result); // { name: \'Apples\', quantity: 10 }\n\n// 优雅写法\nconst inventory = [\n    { name: \"Bananas\", quantity: 5 },\n    { name: \"Apples\", quantity: 10 },\n    { name: \"Grapes\", quantity: 2 },\n];\n\nfunction getApples(arr, value) {\n    return arr.find((obj) => obj.name === \"Apples\");\n}\n\nconst result = getApples(inventory);\nconsole.log(result);\n复制代码\n```\n\n### 7.字符串转换为数字\n\n```\n// 常规逻辑\nconst num = parseInt(\"10\");\n\nconsole.log(num); // 10\nconsole.log(typeof num); // \"number\";\n\n// 优雅写法\nconst num = +\"10\";\nconsole.log(num); //=> 10\nconsole.log(typeof num); // \"number\"\nconsole.log(+\"10\" === 10); // true;\n复制代码\n```\n\n同样的方法可以用于判断是否为整数：\n\n```\nconst isInteger = (val) => Number.isInteger(+val);\nconsole.log(isInteger(\"DevPoint\")); // false\nconsole.log(isInteger(\"30\")); // true\nconsole.log(isInteger(30)); // true\n复制代码\n```\n\n### 8\\. null 值初始化\n\n```\n// 常规逻辑\nfunction getUserRole(role) {\n    let userRole;\n    if (role) {\n        userRole = role;\n    } else {\n        userRole = \"USER\";\n    }\n    return userRole;\n}\n\nconsole.log(getUserRole()); // \"USER\"\nconsole.log(getUserRole(\"ADMIN\")); // \"ADMIN\";\n\n// 优雅写法\nfunction getUserRole(role) {\n    return role || \"USER\"; // 默认值定义的常见方法\n}\n\nconsole.log(getUserRole()); // \"USER\"\nconsole.log(getUserRole(\"ADMIN\")); // \"ADMIN\";\n复制代码\n```\n\n### 9\\. 字符串拼接\n\n过去无尽的 `+` 号，再加上一些排版就更痛苦。\n\n```\n// 常规逻辑\nconst name = \"DevPoint\";\nconst message = \"Hi \" + name + \"!\";\nconsole.log(message); // Hi DevPoint!\n// 优雅写法\nconst name = \"DevPoint\";\nconst message = `Hi ${name}!`;\nconsole.log(message); // Hi DevPoint!\n复制代码\n```\n\n### 10 对象合并\n\n对象的合并，在ES6中，可以学习一些扩展运算符和解构赋值，这样有利于写出更加简洁的代码。\n\n```\n// 常规逻辑\nconst employee = { name: \"DevPoint\", age: 30 };\nconst salary = { grade: \"A\" };\nconst summary = salary;\nfor (const key in employee) {\n    summary[key] = employee[key];\n}\nconsole.log(summary); // { grade: \'A\', name: \'DevPoint\', age: 30 }\n// 优雅写法\nconst employee = { name: \"DevPoint\", age: 30 };\nconst salary = { grade: \"A\" };\nconst summary = { ...employee, ...salary };\nconsole.log(summary); // { name: \'DevPoint\', age: 30, grade: \'A\' }\n复制代码\n```','2022-06-20 12:46:00',0000000005,'前端',14),(0000000007,'一定要优雅，高端前端程序员都应该具备的基本素养','近来看到很多公司裁员，忽然惊醒，之前是站在项目角度考虑问题，却没站在咱们程序员本身看待问题，险些酿成大错，如果人人都能做到把项目维护得井井有条，无论什么人都能看明白都能快速接手，那咱们的竞争力在哪里呢？','之前写过几篇关于如何写出可维护项目的文章（[构建大型前端业务项目的一点经验](https://juejin.cn/post/7016948081321050148 \"https://juejin.cn/post/7016948081321050148\")、[编写可维护的现代化前端项目](https://juejin.cn/post/6844903996910485511 \"https://juejin.cn/post/6844903996910485511\")、[接手前端新项目？这里有些注意点你可能需要留意一下](https://juejin.cn/post/6844903678852202510 \"https://juejin.cn/post/6844903678852202510\")），近来看到很多公司裁员，忽然惊醒，之前是站在项目角度考虑问题，却没站在咱们程序员本身看待问题，险些酿成大错，如果人人都能做到把项目维护得井井有条，无论什么人都能看明白都能快速接手，那咱们的竞争力在哪里呢？这个时候我再看项目中那些被我天天骂的代码，顿时心中就无限景仰起来，原来屎山才是真能能够保护我们的东西，哪有什么岁月静好，只是有人替你负屎前行罢了\n\n为了能让更多人认识到这一点，站在前端的角度上，我在仔细拜读了项目中的那些暗藏玄机的代码后，决定写下此文，由于本人功力尚浅，且之前一直走在错误的道路上，所以本文在真正的高手看来可能有些班门弄斧，在此献丑了?\n\n## 用 TypeScript，但不完全用\n\n`TypeScript`大行其道，在每个团队中，总有那么些个宵小之辈想尽一切办法在项目里引入 `ts`，这种行为严重阻碍了屎山的成长速度，但同是打工人我们也不好阻止，不过就算如此，也无法阻止我们行使正义\n\n众所周知，`TypeScript` 别名 `AnyScript`，很显然，这就是`TypeScript`创始人`Anders Hejlsberg`给我们留下的暗示，我们有理由相信`AnyScript` 才是他真正的目的\n\n```\nconst list: any = []\nconst obj: any = {}\nconst a: any = 1\n复制代码\n```\n\n引入了 `ts`的项目，由于是在原可运行代码的基础上额外添加了类型注释，所以代码体积毫无疑问会增大，有调查显示，可能会增加 `30%`的代码量，如果充分发挥 `AnyScript` 的宗旨，意味着你很轻松地就让代码增加了 `30%` 毫无用处但也挑不出啥毛病的代码，这些代码甚至还会增加项目的编译时间（毕竟增加了`ts`校验和移除的成本嘛）\n\n你不仅能让自己写的代码用上 `AnyScript`，甚至还可以给那些支持 `ts` 的第三方框架/库一个大嘴巴子\n\n```\nexport default defineComponent({\n  props: {\n    // 现在 data 是 any 类型的啦\n    data: {\n      type: Number as PropType<any>,\n    },\n  },\n  setup(_, { emit }) {\n    // 现在 props 是 any 类型的啦\n    const props: any = _\n    ...\n  }\n})\n复制代码\n```\n\n当然了，全屏 `any`可能还是有点明显了，所以你可以适当地给部分变量加上具体类型，但是加上类型不意味着必须要正确使用\n\n```\nconst obj: number[] = []\n// ...\n// 虽然 obj 是个 number[]，但为了实现业务，就得塞入一些不是 number 的类型，我也不想的啊是不是\n// 至于编辑器会划红线报错？那是小问题，不用管它，别人一打开这个项目就是满屏的红线，想想就激动\nobj.push(\'2\')\nobj.push([3])\n复制代码\n```\n\n## 命名应该更自由\n\n命名一直是个困扰很多程序员的问题，究其原因，我们总想给变量找个能够很好表达意思的名称，这样一来代码的可阅读性就高了，但现在我们知道，这并不是件好事，所以我们应该放纵自我，既摆脱了命名困难症，又加速了屎山的堆积进度\n\n```\nconst a1 = {}\nconst a2 = {}\nconst a3 = 2\nconst p = 1\n复制代码\n```\n\n我必须强调一点，命名不仅是变量命名，还包含**文件名、类名、组件名**等，这些都是我们可以发挥的地方，例如类名\n\n```\n<div class=\"box\">\n  <div class=\"box1\"></div>\n  <div class=\"box2\"></div>\n<div>\n<div class=\"box3\"></div>\n复制代码\n```\n\n乍一看似乎没啥毛病，要说有毛病似乎也不值当单独挑出来说，没错，要的就是这个效果，让人单看一段代码不好说什么，但是如果积少成多，整个项目都是 `box`呢？全局搜索都给你废了！如果你某些组件再一不小心没用 `scoped` 呢？稍不留意就不知道把什么组件的样式给改了，想想就美得很\n\n关于 `css`我还想多说一点，鉴于其灵活性，我们还可以做得更多，总有人说什么 `BEM` 不 `BEM`的，他们敢用我们就敢写这样的代码\n\n```\n&-card {\n  &-btn {\n    &_link {\n      &--right {\n      }\n    }\n    &-nodata {\n      &_link {\n        &--replay {\n          &--create {}\n        }\n      }\n    }\n  }\n  &-desc {}\n}\n复制代码\n```\n\n好了，现在请在几百行（关于这一点下一节会说到）这种格式的代码里找出类名 `.xxx__item_current.mod-xxx__link` 对应的样式吧\n\n## 代码一定要长\n\n屎山一定是够高够深的，这就要求我们的代码应该是够长够多的\n\n大到一个文件的长度，小到一个类、一个函数，甚至是一个 `if` 的条件体，都是我们自由发挥的好地方。\n\n什么单文件最好不超过 `400`行，什么一个函数不超过 `100`行，简直就是毒瘤，\n\n![1.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/605301677ade4f8da68a8c80d70cfa8f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n所以这就要求我们要具备将十行代码就能解决的事情写成一百行的能力，最好能给人一种多即是少的感觉\n\n```\ndata === 1\n  ? \'img\'\n  : data === 2\n    ? \'video\'\n    : data === 3\n      ? \'text\'\n      : data === 4\n        ? \'picture\'\n        : data === 5\n          ? \'miniApp\'\n复制代码\n```\n\n三元表达式可以优雅地表达逻辑，像诗一样，虽然这段代码看起来比较多，但逻辑就是这么多，我还专门用了三元表达式优化，不能怪我是不是？什么`map`映射枚举优化听都没听过\n\n你也可以选择其他一些比较容易实现的思路，例如，多写一些废话\n\n```\nif (a > 10) {\n  // 虽然下面几个 if 中对于 a 的判断毫无用处，但不仔细看谁能看出来呢？看出来了也不好说什么，毕竟也没啥错\n  // 除此之外，多级 if 嵌套也是堆屎山的一个小技巧，什么提前 return 不是太明白\n  if (a > 5) {\n    if (a > 3 && b) {\n\n    }\n  }\n  if (a > 4) {\n\n  }\n}\n复制代码\n```\n\n除此之外，你还可以写一些中规中矩的方法，但重点在于这些方法根本就没用到，这种发挥的地方就更多了，简直就是扩充代码体积的利器，毕竟单看这些方法没啥毛病，但谁能想到根本就用不到呢？就算有人怀疑了，但你猜他敢随便从运行得好好的业务项目里删掉一些没啥错的代码吗？\n\n## 组件、方法多多滴耦合\n\n为了避免其他人复用我的方法或组件，那么在写方法或组件的时候，一定要尽可能耦合，提升复用的门槛\n\n例如明明可以通过 `Props`传参解决的事情，我偏要从全局状态里取，例如`vuex`，独一份的全局数据，想传参就得改 `store`数据，但你猜你改的时候会不会影响到其他某个页面某个组件的正常使用呢？如果你用了，那你就可能导致意料之外的问题，如果你不用你就得自己重写一个组件\n\n组件不需要传参？没关系，我直接把组件的内部变量给挂到全局状态上去，虽然这些内部变量确实只有某一个组件在用，但我挂到全局状态也没啥错啊是不是\n\n嘿，明明一个组件就能解决的事情，现在有了倆，后面还可能有仨，这代码量不就上来了吗？\n\n方法也是如此，明明可以抽取参数，遵循函数式编程理念，我偏要跟外部变量产生关联\n\n```\n// 首先这个命名就很契合上面说的自由命名法\nfunction fn1() {\n  // ...\n  // fn1 的逻辑比较长，且解决的是通用问题，\n  // 但 myObj 偏偏是一个外部变量，这下看你怎么复用\n  window.myObj.name = \'otherName\'\n  window.myObj.children.push({ id: window.myObj.children.length })\n  // ...\n}\n复制代码\n```\n\n## 魔术字符串是个好东西\n\n实际上，据我观察，排除掉某些居心不轨的人之外，大部分人还是比较喜欢写魔术字符串的，这让我很欣慰，看着满屏的不知道从哪里冒出来也不知道代表着什么的硬编码字符串，让人很有安全感\n\n```\nif (a === \'prepare\') {\n  const data = localStorage.getItem(\'HOME-show_guide\')\n  // ...\n} else if (a === \'head\' && b === \'repeating-error\') {\n  switch(c) {\n    case \'pic\':\n      // ...\n      break\n    case \'inDrawer\':\n      // ...\n      break\n  }\n}\n复制代码\n```\n\n基于此，我们还可以做得更多，比如用变量拼接魔术字符串，`debug`的时候直接废掉全局搜索\n\n```\nif (a === query.name + \'_head\') {\n\n}\n复制代码\n```\n\n大家都是中国人，为什么不试试汉字呢？\n\n```\nif (data === \'正常\') {\n\n} else if (data === \'错误\') {\n\n} else if (data === \'通过\') {\n\n}\n复制代码\n```\n\n## 轮子就得自己造才舒心\n\n众所周知，造轮子可以显著提升我们程序员的技术水平，另外由于轮子我们已经自己造了，所以减少了对社区的依赖，同时又增加了项目体积，有力地推动了屎山的成长进程，可以说是一鱼两吃了\n\n例如我们可能经常在项目中使用到时间格式化的方法，一般人都是直接引入 `dayjs`完事，太肤浅了，我们应该自己实现，例如，将字符串格式日期格式化为时间戳\n\n```\nfunction format(str1: any, str2: any) {\n  const num1 = new Date(str1).getTime()\n  const num2 = new Date(str2).getTime()\n  return (num2 - num1) / 1000\n}\n复制代码\n```\n\n多么精简多么优雅，至于你说的什么格式校验什么 `safari`下日期字符串的特殊处理，等遇到了再说嘛，就算是`dayjs`不也是经过了多次 `fixbug`才走到今天的嘛，多一些宽松和耐心好不好啦\n\n如果你觉得仅仅是 `dayjs`这种小打小闹难以让你充分发挥，你甚至可以造个 `vuex`，`vue`官网上写明了`eventBus`可以充当全局状态管理的，所以我们完全可以自己来嘛，这里就不举例了，这是自由发挥的地方，就不局限大家的思路了\n\n## 借助社区的力量-轮子还是别人的好\n\n考虑到大家都只是混口饭吃而已，凡事都造轮子未免有些强人所难，所以我们可以尝试走向另外一个极端——凡事都用轮子解决\n\n判断某个变量是字符串还是对象，[kind-of](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fkind-of \"https://www.npmjs.com/package/kind-of\")拿来吧你；获取某个对象的 `key`，[object-keys](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fobject-keys \"https://www.npmjs.com/package/object-keys\")拿来吧你；获取屏幕尺寸，[vue-screen-size](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fvue-screen-size \"https://www.npmjs.com/package/vue-screen-size\")拿来吧你……等等，就不一一列举了，需要大家自己去发现\n\n先甭管实际场景是不是真的需要这些库，也甭管是不是杀鸡用牛刀，要是大家听都没听过的轮子那就更好了，这样才能彰显你的见多识广，总之能解决问题的轮子就是好问题，\n\n在此我得特别提点一下 `lodash`，这可是解决很多问题的利器，但是别下载错了，得是 [commonjs版本](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Flodash \"https://www.npmjs.com/package/lodash\")的那个，量大管饱还正宗，[es module](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Flodash-es \"https://www.npmjs.com/package/lodash-es\")版本是不行滴，太小家子气\n\n```\nimport _ from \'lodash\'\n复制代码\n```\n\n## 多尝试不同的方式来解决相同的问题\n\n世界上的路有很多，很多路都能通往同一个目的地，但大多数人庸庸碌碌，只知道沿着前人的脚步，没有自己的思想，别人说啥就是啥，这种行为对于我们程序员这种高端的职业来说，坏处很大，任何一个有远大理想的程序员都应该避免\n\n落到实际上来，就是尝试使用不同的技术和方案解决相同的问题\n\n*   搞个`css`模块化方案，什么`BEM`、`OOCSS`、`CSS Modules`、`CSS-in-JS` 都在项目里引入，紧跟潮流扩展视野\n*   `vue`项目只用 `template`？逊啦你，`render`渲染搞起来\n*   之前看过什么前端依赖注入什么反射的文章，虽然对于绝大多数业务项目而言都是水土不服，但问题不大，能跑起来就行，引入引入\n*   还有那什么 `rxjs`，人家都说好，虽然我也不知道好在哪里，但胜在门槛高一般人搞不清楚所以得试试\n*   `Pinia` 是个好东西，什么，我们项目里已经有 `vuex`了？`out`啦，人家官网说了 `vue2`也可以用，我们一定要试试，紧跟社区潮流嘛，一个项目里有两套状态管理有什么值得大惊小怪的！\n\n## 做好自己，莫管他人闲事\n\n看过一个小故事，有人问一个年纪很大的老爷爷的长寿秘诀是什么，老爷爷说是从来不管闲事\n\n这个故事对我们程序员来说也很有启发，写好你自己的代码，不要去关心别人能不能看得懂，不要去关心别人是不是会掉进你写的坑里\n\n```\nmounted() {\n  setTimeout(() => {\n    const width = this.$refs.box.offsetWidth\n    const itemWidth = 50\n    // ...\n  }, 200)\n}\n复制代码\n```\n\n例如对于上述代码，为什么要在 `mounted`里写个 `setTimeout`呢？为什么这个 `setTimeout`的时间是 `200`呢？可能是因为 `box` 这个元素大概会在 `mounted`之后的 `200ms`左右接口返回数据就有内容了，就可以测量其宽度进行其他一系列的逻辑了，至于有没有可能因为网络等原因超过 `200ms`还是没有内容呢？这些不需要关心，你只要保证在你开发的时候 `200ms`这个时间是没问题的就行了； `itemWidth`代表另外一个元素的宽度，在你写代码的时候，这个元素宽度就是 `50`，所以没必要即时测量，你直接写死了，至于后面其他人会不会改变这个元素的宽度导致你这里不准了，这就不是你要考虑的事情了，你开发的时候确实没问题，其他人搞出来问题其他人负责就行，管你啥事呢？\n\n## 代码自解释\n\n高端的程序员，往往采用最朴素的编码方式，高手从来不写注释，因为他们写的代码都是自解释的，什么叫自解释？就是你看代码就跟看注释一样，所以不需要注释\n\n我觉得很有道理，代码都在那里搁着了，逻辑写得清清楚楚，为啥还要写注释呢，直接看代码不就行了吗？\n\n乍一看，似乎这一条有点阻碍堆屎山的进程，实则不然\n\n一堆注定要被迭代无数版、被无数人修改、传承多年的代码，其必定是逻辑错综复杂，难免存在一些不可名状的让人说不清道不明的逻辑，没有注释的加成，这些逻辑大概率要永远成为黑洞了，所有人看到都得绕着走，相当于是围绕着这些黑洞额外搭起了一套逻辑，这代码体积和复杂度不就上来了吗？\n\n如果你实在手痒，倒也可以写点注释，我这里透露一个既能让你写写注释过过瘾又能为堆屎山加一把力的方法，那就是：在注释里撒谎！\n\n没错，谁说注释只能写对的？我理解不够，所以注释写得不太对有什么奇怪的吗？我又没保证注释一定是对的，也没逼着你看注释，所以你看注释结果被注释误导写了个bug，这凭啥怪我啊\n\n```\n// 计算 data 是否可用\n//（实际上，这个方法的作用是计算 data 是否 不可用）\nfunction isDisabledData(data: any) {\n  // ...\n}\n复制代码\n```\n\n上述这个例子只能说是小试牛刀，毕竟多调试一下很容易被发现的，但就算被发现了，大家也只会觉得你只是个小粗心鬼罢了，怎么好责怪你呢，这也算是给其他人的一个小惊喜了，况且，万一真有人不管不顾就信了，那你就赚大了\n\n## 编译问题坚决不改\n\n为了阻碍屎山的成长速度，有些阴险的家伙总想在各种层面上加以限制，例如加各种`lint`，在编译的时候，命令行中就会告诉你你哪些地方没有按照规则来，但大部分是 `waring` 级别的，即你不改项目也能正常运行，这就是我们的突破点了。\n\n尽管按照你的想法去写代码，`lint`的事情不要去管，`waring`报错就当没看到，又不是不能用？在这种情况下，如果有人不小心弄了个 `error`级别的错误，他面对的就是从好几屏的 `warning` 中找他的那个 `error` 的场景了，这就相当于是提前跟屎山来了一次面对面的拥抱\n\n根据破窗理论，这种行为将会影响到越来越多的人，大家都将心照不宣地视 `warning`于无物（从好几屏的 `warning`中找到自己的那个实在是太麻烦了），所谓的 `lint`就成了笑话\n\n## 小结\n\n一座历久弥香的屎山，必定是需要经过时间的沉淀和无数人的操练才能最终成型，这需要我们所有人的努力，多年之后，当你看到你曾经参与堆砌的屎山中道崩殂轰然倒塌的时候，你就算是真的领悟了我们程序员所掌控的恐怖实力！?','2022-06-09 06:12:00',0000000006,'前端',22),(0000000008,'有了这些前端css工具，我下班都更早了！','你是不是还在手写按钮、文本字体等简单样式？这些工具就可以帮你解决以上种种难题，从此下班你将快人一步，赶快用起来吧！','![有了这些前端css工具，我下班都更早了！](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef55988104ac43e293ba09e7f3b684ea~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n> 你是不是还在手写按钮、文本字体等简单样式？这些工具就可以帮你解决以上种种难题，从此下班你将快人一步，赶快用起来吧！\n\n### 01 CSS Button Generator\n\n**地址：[cssbuttongenerator.com/](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fcssbuttongenerator.com%2F \"https://link.zhihu.com/?target=https%3A//cssbuttongenerator.com/\")**\n\n**推荐：★★★★★**\n\n**简介**：CSS Button Generator是一个免费的在线工具，可让您创建跨浏览器的 HTML 和CSS 按钮样式，您不必学习任何复杂的CSS规则。只需单击并滑动即可制作CSS 3按钮。很多漂亮的按钮样本。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35d3d608571d44c7bedec0dafdd914b7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 02 花式边界半径\n\n**地址：[9elements.github.io/fancy-borde…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2F9elements.github.io%2Ffancy-border-radius%2F \"https://link.zhihu.com/?target=https%3A//9elements.github.io/fancy-border-radius/\")**\n\n**推荐：★★★★★**\n\n**简介**：通过拖拽的形式生成需要的border-radius！\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2076b1cb259497098af199a9b06ee68~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 03 平滑阴影\n\n**地址：[shadows.brumm.af/](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fshadows.brumm.af%2F \"https://link.zhihu.com/?target=https%3A//shadows.brumm.af/\")**\n\n**推荐：★★★★★**\n\n**简介**：可以生成多个分层阴影，提供非常酷的效果，你也可以自定义颜色。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3d80836cdc14d919e54719ae66d6f0f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 04 阴影生成器\n\n**地址：[neumorphism.io/](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fneumorphism.io%2F \"https://link.zhihu.com/?target=https%3A//neumorphism.io/\")**\n\n**推荐：★★★★★**\n\n**简介**：此网站通过 选择颜色：或大小：半径：距离：强度：模糊：形状：复制边框半径：50px;背景，生成非常nice的阴影，让你的界面更加的美观自然。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/771daf260cd1446aa877298b85d81786~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 05 css在线工具\n\n**地址：** [tool.lu/css/](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Ftool.lu%2Fcss%2F \"https://link.zhihu.com/?target=https%3A//tool.lu/css/\")\n\n**推荐：★★★★**\n\n**简介**：美化：格式化代码，使之容易阅读。净化：将代码单行化，并去除注释。整理：按照一定的顺序，重新排列css的属性。优化：将css的长属性值优化为简写的形式。压缩：将代码最小化，加快加载速度！\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8a705ab3e6046b0a3db88b0c79b6b2c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 06 cssgradient\n\n**地址：[cssgradient.io/](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fcssgradient.io%2F \"https://link.zhihu.com/?target=https%3A//cssgradient.io/\")**\n\n**推荐：★★★★**\n\n**简介**：CSS Gradient 是一个快乐的小网站和免费工具，可让您为网站创建渐变背景。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e85e342d7594600a737e3796836abbe~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 07 css网格生成器\n\n**地址：[cssgrid-generator.netlify.app/](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fcssgrid-generator.netlify.app%2F \"https://link.zhihu.com/?target=https%3A//cssgrid-generator.netlify.app/\")**\n\n**推荐：★★★★★**\n\n**简介**：您可以设置行和列的数字还有单位，我将为您生成一个 CSS Grid 网格布局！在方框中拖动来创建 div 放置在网格内。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7a6189cca4142a292b0f63d9c3ef104~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 08 过渡动画\n\n**地址：[www.transition.style/](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fwww.transition.style%2F \"https://link.zhihu.com/?target=https%3A//www.transition.style/\")**\n\n**推荐：★★★★**\n\n**简介**：各种各样的css动画合集！\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b0c858ced164eb597e90f19e5ab5755~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 09 加载动画\n\n**地址：[loading.io/](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Floading.io%2F \"https://link.zhihu.com/?target=https%3A//loading.io/\")**\n\n**推荐：★★★★★**\n\n**简介**：在这里你可以生成多个加载动画并将其下载为SVG、GIF、PNG和其他格式，但它最棒的特点是你可以将这些动画自定义到一个新的水平。值得尝试。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5c30ded40974730ab65458915c12530~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 10 波浪生成器\n\n**地址：[getwaves.io/](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgetwaves.io%2F \"https://link.zhihu.com/?target=https%3A//getwaves.io/\")**\n\n**推荐：★★★★★**\n\n**简介**：通过一些自定义生成简单的波纹。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdafea469e4f4546b30859876548e50e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 11 我可以用这个css吗？\n\n**地址：[caniuse.com/?search=cli…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fcaniuse.com%2F%253Fsearch%253Dclip-path \"https://link.zhihu.com/?target=https%3A//caniuse.com/%3Fsearch%3Dclip-path\")**\n\n**推荐：★★★★★**\n\n**简介**：不要问我，得问它！css浏览器兼容性查询工具\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fe05743d732454389a47ba2446b2a5c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 12 零代码工具箱\n\n**地址：[www.lingdaima.com/](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fwww.lingdaima.com%2F \"https://link.zhihu.com/?target=https%3A//www.lingdaima.com/\")**\n\n**推荐：★★★★★**\n\n**简介**：各种前端实用的好工具，杜绝造轮子，每款工具都经过精心打磨，帮助所有程序员提高前端开发效率！\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/027583369cf74941ad133e5afe749a59~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 13 css技巧\n\n**地址：[lhammer.cn/You-need-to…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Flhammer.cn%2FYou-need-to-know-css%2F \"https://link.zhihu.com/?target=https%3A//lhammer.cn/You-need-to-know-css/\")**\n\n**推荐：★★★★★**\n\n**简介**：css小技巧合集，一直在更新！\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd51f386de2446bfac0786d11f49dd70~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)','2022-07-07 01:12:00',0000000007,'前端',8),(0000000009,'知识点整理： vue一些高级概念','混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。','![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf111c39bc8742218da6ffaf54a81f70~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n## 混入mixins\n\n### 官方解释\n\n> 混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\n\n简单的来说就是 Mixins 是我们`可以重用`的代码块，在实际开发中，如果有些代码重复性比较高，这时候可以考虑 Mixins 这个特性。\n\n简单的mixin示例\n\n```\nexport default {\n  data() {\n    return {\n      name: \'来自mixin的name\',\n      arr: [\n        1,\n        {\n          arrName: \'来自mixin\',\n          arrMixin: \'来自mixin\'\n        },\n        1233\n      ],\n      obj: { name: \'来自mixin\', value: \'来自mixin\', mixin: \'只有mixin才有的字段\' }\n    }\n  },\n  created() {\n    console.log(\'我是mixin的created---\')\n  },\n  mounted() {\n    console.log(\'我是mixin的mounted---\')\n    this.getInfo()\n  },\n  methods: {\n    getInfo() {\n      console.log(\'我是mixin, getInfo:\', this.name)\n      console.log(\'我是mixin的obj:\', this.obj)\n      console.log(\'我是mixin的arr:\', this.arr)\n    }\n  }\n}\n\n复制代码\n```\n\n组件中使用\n\n```\nimport mixinDemo from \'./mixin.js\'\nexport default {\n  name: \'\',\n  mixins: [mixinDemo],\n  components: {},\n  data() {\n    return {\n      name: \'组件中的name\',\n      arr: [\n        2,\n        {\n          arrName: \'来自组件的arrName\',\n          title: \'来自组件的独有字段title\'\n        }\n      ],\n      obj: { name: \'来自组件name\', value: \'来自组件value\', title: \'只有组件才有的title字段\' }\n    }\n  },\n  computed: {},\n  watch: {},\n  created() {\n    console.log(\'---我是组件的created---\')\n  },\n  mounted() {\n    console.log(\'---我是组件的mounted---\')\n\n    this.getInfo()\n  },\n  methods: {\n    getInfo() {\n      console.log(\'我是组件的, getInfo:\', this.name)\n      console.log(\'我是组件的obj:\', this.obj)\n      console.log(\'我是组件的arr:\', this.arr)\n    }\n  }\n}\n复制代码\n```\n\n控制台结果\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7ba6545f4ce466b904c6a1bc6452a6a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n通过以上结果可以发现\n\n*   生命周期钩子函数会`合并`起来，`都会执行`。**先执行mixins的钩子函数 再 执行组件的钩子函数**。\n\n*   data 的同名数据，要分情况讨论\n\n\n> 如果是基本类型，会用组件的同名数据覆盖mixin的数据。\n>\n> 但是如果是对象，数据对象在内部会进行`递归`合并，并在发生冲突时以**组件数据优先**。类似 `Object.assign(mixinObj, componentObj)`;\n>\n> 数组的话则直接以`组件`中的数据优先\n\n*   methods的方法也是一样，会用组件的方法覆盖mixin的同名方法。\n\n*   除了上面这些，还有例如 `methods`、`components` 和 `directives`，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对，**同名的会覆盖，以组件的为优先**。\n\n\n### 全局混入\n\n混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响**每一个**之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑。\n\n### 混入造成的问题\n\n用得太多的话，容易混乱。后期维护的时候，不容易查找变量或者方法。\n\n## 自定义指令 directive\n\n### 简介\n\n除了核心功能默认内置的指令 (`v-model` 和 `v-show`)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。\n\n比如项目中常用的水印功能。我们对一个 div 范围内添加水印样式。可以用到自定义指令。\n\n首先看看效果图\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fca9143907544d649f2dd573a78924d9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n生成水印有许多方法。我们现在通过自定义指令的方式来操作，以便熟悉自定义指令的使用。\n\n先上代码\n\n#### 方法文件\n\n```\nfunction addWaterMarker(str, parentNode, font, textColor) {\n  // 水印文字生成方法 略\n}\n\nconst waterMarker = {\n  name: \'waterMarker\',\n  bind: function(el, binding) {\n    addWaterMarker(binding.value, el)\n  },\n  update: function(el, binding) {\n    if (binding.oldValue !== binding.value) {\n      addWaterMarker(binding.value, el)\n    }\n  }\n}\n\nexport default waterMarker\n复制代码\n```\n\n##### 注册自定义指令\n\n```\nimport Vue from \'vue\'\nimport waterMarker from \'./watermark.js\'\nVue.directive(waterMarker.name, waterMarker)\n复制代码\n```\n\n##### main.js全局调用\n\n```\nimport \'./directive.js\'\n复制代码\n```\n\n##### 组件中使用\n\n指令需要用 `v- + 指令名` 方式引用\n\n```\n<div v-waterMarker=\"\'我是水印\'\" class=\"wrapper\"></div>\n复制代码\n```\n\n#### 指令的钩子函数\n\n一个指令定义对象可以提供如下几个钩子函数 (均为可选)：\n\n*   `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\n\n*   `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\n\n*   `update`：所在组件的 VNode 更新时调用，**但是可能发生在其子 VNode 更新之前**。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。\n\n*   `componentUpdated`：指令所在组件的 VNode **及其子 VNode** 全部更新后调用。\n\n*   `unbind`：只调用一次，指令与元素解绑时调用。\n\n\n#### 指令钩子函数会被传入以下参数：\n\n*   `el`：指令所绑定的元素，可以用来直接操作 DOM。\n\n*   `binding`：一个对象，包含以下 property：\n\n    *   `name`：指令名，不包括 `v-` 前缀。\n    *   `value`：指令的绑定值，例如：`v-my-directive=\"1 + 1\"` 中，绑定值为 `2`。\n    *   `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。\n    *   `expression`：字符串形式的指令表达式。例如 `v-my-directive=\"1 + 1\"` 中，表达式为 `\"1 + 1\"`。\n    *   `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `\"foo\"`。\n    *   `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`。\n*   `vnode`：Vue 编译生成的虚拟节点。移步 [VNode API](https://link.juejin.cn?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%23VNode-%25E6%258E%25A5%25E5%258F%25A3 \"https://cn.vuejs.org/v2/api/#VNode-%E6%8E%A5%E5%8F%A3\") 来了解更多详情。\n\n*   `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用。\n\n\n### 组件中局部自定义指令\n\n```\nexport default {\n  directives: {\n    waterMarker: {\n      // 当前指令的钩子函数 略\n      bind() {}\n    }\n  }\n}\n复制代码\n```\n\n## 过滤器 filter\n\nVue过滤器本质上是一个函数，它接受一个值，处理它，然后返回处理过的值。\n\n过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道 ( | ) ”符号指示\n\n##### 组件中使用\n\n```\n<div class=\"btn-list\">\n  {{ btn | btnFilter }}\n</div>\n<div class=\"btn-list\" :id=\"btn2 | btnFilter\">id</div>\n复制代码\n```\n\n##### 组件中定义过滤器\n\n```\nconst filterList = [\n  { key: 1, text: \'提交\' },\n  { key: 2, text: \'查看\' },\n  { key: 3, text: \'编辑\' },\n  { key: 4, text: \'删除\' }\n]\nexport default {\n  filters: {\n    btnFilter(val) {\n      return filterList.find(item => item.key === val).text\n    }\n  },\n  data() {\n    return {\n      btn: 1,\n      btn2: 3\n    }\n  }\n}\n复制代码\n```\n\n全局定义过滤器\n\n```\nimport Vue from \'vue\'\nVue.filter(\'btnFilter\', function (value) {\n    // 逻辑代码...\n})\n\n\n--------\n// 再到main.js引用即可\n复制代码\n```\n\n过滤器可以 **串联** 使用\n\n```\n{{ btn | btnFilter | newBtnFilter}}\n复制代码\n```\n\n上述 `btn` 作为参数传入到 `btnFilter` 中，然后继续调用 `newBtnFilter`，此时将以 `btnFilter` 的结果作为参数使用\n\n过滤器是 JavaScript 函数，因此可以 **接收参数**\n\n```\n{{ btn | btnFilter(\'arg1\', \'arg2\')}}\n复制代码\n```\n\n这里的 btnFilter 相当于是接收三个参数的函数，其中 btn 为第一个参数， \'arg1\' 为第二个参数， \'arg2\' 为第三个参数。\n\n## 过渡\n\nVue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具：\n\n*   在 CSS 过渡和动画中自动应用 class\n*   可以配合使用第三方 CSS 动画库，如 Animate.css\n*   在过渡钩子函数中使用 JavaScript 直接操作 DOM\n*   可以配合使用第三方 JavaScript 动画库，如 Velocity.js\n\nVue 提供了 `transition` 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡\n\n*   条件渲染 (使用 `v-if`)\n*   条件展示 (使用 `v-show`)\n*   动态组件\n*   组件根节点\n\n示例\n\n```\n<div class=\"btn-list\" @click=\"show\">\n  {{ btn | btnFilter }}\n</div>\n<transition name=\"a\">\n  <p v-if=\"isShow\">过渡动画呀</p>\n</transition>\n复制代码\n```\n```\nexport default {\n  data() {\n    return {\n      isShow: true\n    }\n  },\n   methods: {\n    show() {\n      this.isShow = !this.isShow\n    }\n  }\n}\n复制代码\n```\n```\n.a-enter-active,\n.a-leave-active {\n  transition: opacity 0.5s;\n}\n.a-enter,\n.a-leave-to {\n  opacity: 0;\n}\n复制代码\n```\n\n当插入或删除包含在 `transition` 组件中的元素时，Vue 将会做以下处理：\n\n1.  自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。\n2.  如果过渡组件提供了 [JavaScript 钩子函数](https://link.juejin.cn?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Ftransitions.html%23JavaScript-%25E9%2592%25A9%25E5%25AD%2590 \"https://cn.vuejs.org/v2/guide/transitions.html#JavaScript-%E9%92%A9%E5%AD%90\")，这些钩子函数将在恰当的时机被调用。\n3.  如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和 Vue 的 `nextTick` 概念不同)\n\n### 过渡的类名\n\n在进入/离开的过渡中，会有 6 个 class 切换。\n\n1.  `v-enter`：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。\n2.  `v-enter-active`：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。\n3.  `v-enter-to`：**2.1.8 版及以上**定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 `v-enter` 被移除)，在过渡/动画完成之后移除。\n4.  `v-leave`：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。\n5.  `v-leave-active`：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。\n6.  `v-leave-to`：**2.1.8 版及以上**定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 `v-leave` 被删除)，在过渡/动画完成之后移除。\n\n`<transition>` 中的 name 对应上述类名的 v , 如： `name=\"a\"` 则对应类名为 `a-enter` 等。如果你使用一个没有名字的 `<transition>`则 `v-` 是这些类名的默认前缀。\n\n如此，我们就可以通过编写不同的 css 动画样式，配合`<transition>`来达到不同的效果。\n\n### JavaScript 钩子\n\n```\n <transition\n      v-on:before-enter=\"beforeEnter\"\n      v-on:enter=\"enter\"\n      v-on:after-enter=\"afterEnter\"\n      v-on:enter-cancelled=\"enterCancelled\"\n      v-on:before-leave=\"beforeLeave\"\n      v-on:leave=\"leave\"\n      v-on:after-leave=\"afterLeave\"\n      v-on:leave-cancelled=\"leaveCancelled\"\n    >\n      <!-- ... -->\n    </transition>\n复制代码\n```\n\n此时可以在不同的钩子中，使用 `Velocity` 等动画库来实现我们需要的动画效果。','2022-07-27 07:51:00',0000000006,'前端',7),(0000000010,'最详细的 Vue3 + TypeScript 使用教程【值得收藏】','','> 哈喽,大家好 我是`xy`??‍?。最近技术栈刚刚由之前的 `React` 转向 `Vue3`了，由于之前多多少少也接触过 `Vue`，所以这次只用了一个上午的时间就上手 `Vue3` 了，如果大家有关于`vue`或者`react`上的问题，欢迎来滴滴我，一起交流学习 ?\n\n至于技术栈为什么由 `react` 转向 `vue3`，也是因为今年换了新工作，公司技术栈以`vue3`为主，刚好前段时间又接手了一个项目，就直接采用 `Vue3` `script setup` `typescript` 开发，于是今天就想给大家分享下 `script setup` 结合 `typescript` 使用的一些技巧，如果这些技巧能够帮助到你，记得给我点个赞呦 ?\n\n## 环境搭建\n\n环境搭建这里就不详细介绍了，可以直接使用官方的方式创建\n\n```\nnpm init vue@latest\n复制代码\n```\n\n这一指令将会安装并执行 `create-vue`，它是 `Vue` 官方的项目脚手架工具。你将会看到一些诸如 `TypeScript` 和`测试`支持之类的可选功能提示：\n\n```\n✔ Project name: … <your-project-name>\n✔ Add TypeScript? … No / Yes\n✔ Add JSX Support? … No / Yes\n✔ Add Vue Router for Single Page Application development? … No / Yes\n✔ Add Pinia for state management? … No / Yes\n✔ Add Vitest for Unit testing? … No / Yes\n✔ Add Cypress for both Unit and End-to-End testing? … No / Yes\n✔ Add ESLint for code quality? … No / Yes\n✔ Add Prettier for code formatting? … No / Yes\n\nScaffolding project in ./<your-project-name>...\nDone.\n复制代码\n```\n\n如果不确定是否要开启某个功能，你可以直接按下回车键选择 `No`。在项目被创建后，通过以下步骤安装依赖并启动开发服务器：\n\n```\ncd <your-project-name>\nnpm install\nnpm run dev\n复制代码\n```\n\n想看更多的`详细配置`的同学，可以移步到我之前的一篇文章中：\n\n[![Vite2＋Vue3.x＋TypeScript 搭建一套企业级的开发脚手架](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a43d7e731f6f439f968e0c628a7cb4b7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FBcxeuh8fUoRIF2DNnPj5HA \"https://mp.weixin.qq.com/s/Bcxeuh8fUoRIF2DNnPj5HA\")\n\n这里就不做过多的讲解了，这篇文章的重点还是在 `script setup` `typescript` 结合使用上\n\n## ref()\n\n`ref()`接受一个内部值，返回一个响应式的、可更改的 `ref` 对象，此对象只有一个指向其内部值的 `property .value`。\n\n### 类型定义\n\n```\nfunction ref<T>(value: T): Ref<UnwrapRef<T>>\ninterface Ref<T> {\n  value: T\n}\n复制代码\n```\n\n### 为 ref() 标注类型\n\n`ref()` 标注类型有三种方式：\n\n1.  通过泛型参数的形式来给 `ref()`增加类型\n\n```\nimport { ref } from \'vue\'\n\nconst initCode = ref<string | number>(\'200\')\n复制代码\n```\n\n2.  如果是遇到复杂点的类型，可以自定义 `interface` 然后泛型参数的形式传入\n\n```\nimport { ref } from \'vue\'\n\ninterface User {\n  name: string\n  age: string | number\n}\n\nconst user = ref<User>({\n  name:\'前端开发爱好者\',\n  age: 20\n})\n复制代码\n```\n\n3.  通过使用 `Ref` 这个类型为 `ref` 内的值指定一个更复杂的类型\n\n```\nimport { ref } from \'vue\'\nimport type { Ref } from \'vue\'\n\nconst initCode: Ref<string | number> = ref(\'200\')\n复制代码\n```\n\n### 三种方式推荐\n\n比较推荐使用`前两种`方式，前两种方式其实都是以`泛型`的形式来标注类型的\n\n第三种方式需要额外的引入：\n\n```\nimport type { Ref } from \'vue\'\n复制代码\n```\n\n所以不是很推荐(本着能少写一行是一行原则)\n\n## reactive()\n\n`reactive()` 返回一个对象的响应式代理。\n\n### 类型定义\n\n```\nfunction reactive<T extends object>(target: T): UnwrapNestedRefs<T>\n复制代码\n```\n\n### 为 reactive() 标注类型\n\n`reactive()`标注类型有两种方式：\n\n1.  直接给声明的变量添加类型\n\n```\nimport { reactive } from \'vue\'\n\ninterface User {\n  name: string\n  age: string | number\n}\n\nconst user:User = reactive({\n  name:\"前端开发爱好者\",\n  age:\'20\'\n})\n复制代码\n```\n\n2.  通过泛型参数的形式来给 `reactive()`增加类型\n\n```\nimport { reactive } from \'vue\'\n\ninterface User {\n  name: string\n  age: string | number\n}\n\nconst user = reactive<User>({\n  name:\"前端开发爱好者\",\n  age:\'20\'\n})\n复制代码\n```\n\n### 两种方式推荐\n\n`不推荐`使用 `reactive()` 的泛型参数,因为处理了深层次 ref 解包的返回值与泛型参数的类型不同。`推荐直接给声明的变量添加类型`。\n\n## computed ()\n\n接受一个 `getter` 函数，返回一个只读的响应式 `ref` 对象，即 `getter` 函数的返回值。它也可以接受一个带有 `get` 和 `set` 函数的对象来创建一个可写的 `ref` 对象。\n\n### 类型定义\n\n```\n// 只读\nfunction computed<T>(\n  getter: () => T,\n  debuggerOptions?: DebuggerOptions\n): Readonly<Ref<Readonly<T>>>\n\n// 可写的\nfunction computed<T>(\n  options: {\n    get: () => T\n    set: (value: T) => void\n  },\n  debuggerOptions?: DebuggerOptions\n): Ref<T>\n复制代码\n```\n\n### 为 computed() 标注类型\n\n`computed()`标注类型有两种方式：\n\n1.  从其计算函数的返回值上推导出类型\n\n```\nimport { ref, computed } from \'vue\'\n\nconst count = ref<number>(0)\n\n// 推导得到的类型：ComputedRef<string>\nconst user = computed(() => count.value + \'前端开发爱好者\')\n复制代码\n```\n\n2.  通过泛型参数显式指定 `computed()` 类型\n\n```\nconst user = computed<string>(() => {\n  // 若返回值不是 string 类型则会报错\n  return \'前端开发爱好者\'\n})\n复制代码\n```\n\n### 两种方式推荐\n\n自动推导类型虽然简单快捷，但是还是希望`手动`的去`指定`其类型，这样更加利于代码的可维护性，所以这里推荐大家使用通过泛型参数显式指定 `computed()` 类型\n\n## defineProps()\n\n为了在声明 `props` 选项时获得完整的类型推断支持，我们可以使用 `defineProps` API，它将自动地在 `script setup` 中使用\n\n### 为 defineProps() 标注类型\n\n1.  从它的参数中推导类型:\n\n```\nconst props = defineProps({\n  name: { type: String, required: true },\n  age: Number\n})\n复制代码\n```\n\n2.  通过泛型参数来定义 `props` 的类型\n\n```\nconst props = defineProps<{\n  name: string\n  age?: number\n}>()\n复制代码\n```\n\n当然了,我们也可以吧以上的泛型参数定义成一个单独的 `interface`\n\n```\ninterface Props {\n  name: string\n  age?: number\n}\n\nconst props = defineProps<Props>()\n复制代码\n```\n\n> 以上的两种方式虽然都可以很方便的`标注类型`, 但是失去了对 `props` 定义默认值的能力\n\n目前官方也给出了解决方案,但是目前这个方案还处于实验性,并且需要`显式地选择开启`。\n\n```\n// vite.config.js\nexport default {\n  plugins: [\n    vue({\n      reactivityTransform: true\n    })\n  ]\n}\n复制代码\n```\n\n通过对 `defineProps()` 的响应性解构来添加默认值:\n\n```\n<script setup lang=\"ts\">\ninterface Props {\n  name: string\n  age?: number\n}\n\nconst { name = \'前端开发爱好者\', age = 100 } = defineProps<Props>()\n</script>\n复制代码\n```\n\n## defineEmits()\n\n为了在声明 `emits` 选项时获得完整的类型推断支持，我们可以使用 `defineEmits` API，它将自动地在 `script setup` 中使用\n\n### 为 defineEmits() 标注类型\n\n`defineEmits()` 标注类型直接推荐`泛型`形式\n\n```\nimport type { GlobalTheme } from \'naive-ui\'\n\nconst emit = defineEmits<{\n  (e: \'setThemeColor\', val: GlobalTheme): void\n}>()\n复制代码\n```\n\n虽然官方还推荐了`运行时`自动推导的一种形式,但是本人不是很推荐\n\n## defineExpose()\n\n`defineExpose()` 编译器宏来显式指定在 `script setup` 组件中要暴露出去的 `property`,使得父组件通过`模板ref`的方式获取到当前组件的实例\n\n### 为 defineExpose() 标注类型\n\n`defineExpose()` 类型推导直接使用参数类型自动推到即可\n\n```\n<script setup>\nimport { ref } from \'vue\'\n\nconst name = ref<string>(\'前端开发爱好者\')\n\ndefineExpose({\n  name\n})\n复制代码\n```\n\n## provide()\n\n`provide()`供给一个值，可以被后代组件注入\n\n### 类型定义\n\n```\nfunction provide<T>(key: InjectionKey<T> | string, value: T): void\n复制代码\n```\n\n### 为 provide() 标注类型\n\n为 `provide()` 标注类型, Vue 提供了一个 `InjectionKey` 接口，它是一个继承自 `Symbol` 的泛型类型，可以用来在提供者和消费者之间同步注入值的类型\n\n```\nimport type { InjectionKey } from \'vue\'\n\n// 建议声明 key (name) 放到公共的文件中\n// 这样就可以在 inject 的时候直接导入使用\nconst name = Symbol() as InjectionKey<string>\n\nprovide(name, \'前端开发爱好者\') // 若提供的是非字符串值会导致错误\n复制代码\n```\n\n以上方式是通过定义 key 的类型来标注类型的,还有一种方式直接 `key` 采用`字符串`的形式添加\n\n```\nprovide(\'name\', \'前端开发爱好者\')\n复制代码\n```\n\n## inject()\n\n`inject()`注入一个由祖先组件或整个应用供给的值\n\n### 类型定义\n\n```\n// 没有默认值\nfunction inject<T>(key: InjectionKey<T> | string): T | undefined\n\n// 带有默认值\nfunction inject<T>(key: InjectionKey<T> | string, defaultValue: T): T\n\n// 使用工厂函数\nfunction inject<T>(\n  key: InjectionKey<T> | string,\n  defaultValue: () => T,\n  treatDefaultAsFactory: true\n): T\n复制代码\n```\n\n### 为 inject() 标注类型\n\n`provide()` 的 `key` 的类型是声明式提供的话(provide()类型标注的第一种形式)\n\n`inject()` 可以直接导入声明的 `key` 来获取父级组件提供的值\n\n```\n// 由外部导入\nconst name = Symbol() as InjectionKey<string>\n\nconst injectName = inject(name)\n复制代码\n```\n\n如果 `provide()` 的 `key` 直接使用的`字符串`形式添加的, 需要通过泛型参数声明\n\n```\nconst injectName = inject<string>(\'name\')\n复制代码\n```\n\n## 模板 ref\n\n模板 `ref` 需要通过一个显式指定的`泛型参数`和一个`初始值 null` 来创建：\n\n```\n<img ref=\"el\" class=\"logo\" :src=\"Logo\" alt=\"\" />\n\nconst el = ref<HTMLImageElement | null>(null)\n复制代码\n```\n\n## 组件 ref\n\n有时，你可能需要为一个子组件添加一个模板 ref，以便调用它公开的方法\n\n```\n<!-- Child.vue -->\n<script setup lang=\"ts\"> const handleLog = () => console.log(\'前端开发爱好者\')\n\ndefineExpose({\n  open\n}) </script>\n复制代码\n```\n\n为了获取 `MyModal` 的类型，我们首先需要通过 `typeof` 得到其类型，再使用 `TypeScript` 内置的 `InstanceType` 工具类型来获取其实例类型：\n\n```\n<!-- parent.vue -->\n<script setup lang=\"ts\"> import Child from \'./Child.vue\'\n\n// 为子组件 ref 声明类型\nconst child = ref<InstanceType<typeof Child> | null>(null)\n\n// 调用子组件中的方法\nconst getChildHandleLog = () => {\n  child.value?.handleLog()\n} </script>\n复制代码\n```\n\n## 事件处理器\n\n原生的 DOM 事件标注类型\n\n```\n<template>\n  <input type=\"text\" @change=\"handleChange\" />\n</template>\n\n<script setup lang=\"ts\"> function handleChange(event: Event) {\n  console.log((event.target as HTMLInputElement).value)\n} </script>\n复制代码\n```','2022-07-17 08:19:00',0000000005,'前端',11),(0000000011,'ES2022新规发布，8个实用新功能','JavaScript 不是一种开源语言，它是一种需要遵循 ECMAScript 标准规范编写的语言，TC39 委员会负责讨论和批准新功能的发布， 那TC39他们是谁？','![ES2022新规发布，8个实用新功能](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46d108b60511497a9ec4115ffb1ed29d~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n**新的 ES13 规范终于发布了。**\n\nJavaScript 不是一种开源语言，它是一种需要遵循 ECMAScript 标准规范编写的语言，TC39 委员会负责讨论和批准新功能的发布， 那TC39他们是谁？\n\n“ECMA International 的 TC39 是一群 JavaScript 开发人员、实施者、学者等，他们与社区合作维护和发展 JavaScript 的定义。” — TC39.es\n\n他们的发布过程由五个阶段组成，自 2015 年以来，他们一直在进行年度发布，它们通常发生在春天举行发布。\n\n有两种方法可以引用任何 ECMAScript 版本：\n\n*   按年份：这个新版本将是 ES2022。\n*   按其迭代次数：这个新版本将是第 13 次迭代，所以它可以被称为 ES13。\n\n那么这次这个版本有什么新东西呢？我们可以对哪些功能感到兴奋？\n\n**01、正则表达式匹配索引**\n\n目前，在 JavaScript 中使用 JavaScript Regex API 时，仅返回匹配的开始索引。但是，对于一些特殊的高级场景，这还不够。\n\n作为这些规范的一部分，添加了一个特殊的标志 d。通过使用它，正则表达式 API 将返回一个二维数组作为名索引的键。它包含每个匹配项的开始和结束索引。如果在正则表达式中捕获了任何命名组，它将在 indices.groups 对象中返回它们的开始/结束索引， 命名的组名将是它的键。\n\n```\n// ✅ a regex with a \'B\' named group capture\nconst expr = /a+(?<B>b+)+c/d;\n\nconst result = expr.exec(\"aaabbbc\")\n\n// ✅ shows start-end matches + named group match\nconsole.log(result.indices);\n// prints [Array(2), Array(2), groups: {…}]\n\n// ✅ showing the named \'B\' group match\nconsole.log(result.indices.gr\noups[\'B\'])\n// prints [3, 6]\n复制代码\n```\n\n查看原始提案，[github.com/tc39/propos…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Ftc39%2Fproposal-regexp-match- \"https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-regexp-match-\") indices\n\n**02、Top-level await**\n\n在此提案之前，不接受Top-level await，但有一些变通方法可以模拟这种行为，但其有缺点。\n\nTop-level await 特性让我们依靠模块来处理这些 Promise。这是一个直观的功能。\n\n但是请注意，它可能会改变模块的执行顺序， 如果一个模块依赖于另一个具有Top-level await 调用的模块，则该模块的执行将暂停，直到 promise 完成。\n\n让我们看一个例子：\n\n```\n// users.js\nexport const users = await fetch(\'/users/lists\');\n\n// usage.js\nimport { users } from \"./users.js\";\n// ✅ the module will wait for users to be fullfilled prior to executing any code\nconsole.log(users);\n复制代码\n```\n\n在上面的示例中，引擎将等待用户完成操作，然后，再执行 usage.js 模块上的代码。\n\n总之，这是一个很好且直观的功能，需要小心使用，我们不要滥用它。\n\n在此处查看原始提案。[github.com/tc39/propos…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Ftc39%2Fproposal-top-level-await \"https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-top-level-await\")\n\n**03、.at( )**\n\n长期以来，一直有人要求 JavaScript 提供类似 Python 的数组负索引访问器。而不是做 array\\[array.length-1\\] 来做简单的 array\\[-1\\]。这是不可能的，因为 \\[\\] 符号也用于 JavaScript 中的对象。\n\n被接受的提案采取了更实际的方法。Array 对象现在将有一个方法来模拟上述行为。\n\n```\nconst array = [1,2,3,4,5,6]\n\n// ✅ When used with positive index it is equal to [index]\narray.at(0) // 1\narray[0] // 1\n\n// ✅ When used with negative index it mimicks the Python behaviour\narray.at(-1) // 6\narray.at(-2) // 5\narray.at(-4) // 3\n复制代码\n```\n\n查看原始提案，[github.com/tc39/propos…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Ftc39%2Fproposal-relative-indexing-method \"https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-relative-indexing-method\")\n\n顺便说一句，既然我们在谈论数组，你知道你可以解构数组位置吗？\n\n```\nconst array = [1,2,3,4,5,6];\n\n// ✅ Different ways of accessing the third position\nconst {3: third} = array; // third = 4\narray.at(3) // 4\narray[3] // 4\n复制代码\n```\n\n**04、可访问的 Object.prototype.hasOwnProperty**\n\n以下只是一个很好的简化， 已经有了 hasOwnProperty。但是，它需要在我们想要执行的查找实例中调用。因此，许多开发人员最终会这样做是很常见的：\n\n```\nconst x = { foo: \"bar\" };\n\n// ✅ grabbing the hasOwnProperty function from prototype\nconst hasOwnProperty = Object.prototype.hasOwnProperty\n\n// ✅ executing it with the x context\nif (hasOwnProperty.call(x, \"foo\")) {\n  ...\n}\n复制代码\n```\n\n通过这些新规范，一个 hasOwn 方法被添加到 Object 原型中，现在，我们可以简单地做：\n\n```\nconst x = { foo: \"bar\" };\n\n// ✅ using the new Object method\nif (Object.hasOwn(x, \"foo\")) {\n  ...\n}\n复制代码\n```\n\n查看原始提案，[github.com/tc39/propos…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Ftc39%2Fproposal-accessible-object-hasownproperty \"https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-accessible-object-hasownproperty\")\n\n**05、Error Cause**\n\n错误帮助我们识别应用程序的意外行为并做出反应，然而，理解深层嵌套错误的根本原因，正确处理它们可能会变得具有挑战性，在捕获和重新抛出它们时，我们会丢失堆栈跟踪信息。\n\n没有关于如何处理的明确协议，考虑到任何错误处理，我们至少有 3 个选择：\n\n```\nasync function fetchUserPreferences() {\n  try {\n    const users = await fetch(\'//user/preferences\')\n      .catch(err => {\n        // What is the best way to wrap the error?\n        // 1. throw new Error(\'Failed to fetch preferences \' + err.message);\n        // 2. const wrapErr = new Error(\'Failed to fetch preferences\');\n        //    wrapErr.cause = err;\n        //    throw wrapErr;\n        // 3. class CustomError extends Error {\n        //      constructor(msg, cause) {\n        //        super(msg);\n        //        this.cause = cause;\n        //      }\n        //    }\n        //    throw new CustomError(\'Failed to fetch preferences\', err);\n      })\n    }\n}\nfetchUserPreferences();\n复制代码\n```\n\n作为这些新规范的一部分，我们可以构造一个新错误并保留获取的错误的引用。我们只需将对象 {cause: err} 传递给 Errorconstructor。\n\n这一切都变得更简单、标准且易于理解深度嵌套的错误， 让我们看一个例子：\n\n```\nasync function fetcUserPreferences() {\n  try {\n    const users = await fetch(\'//user/preferences\')\n      .catch(err => {\n        throw new Error(\'Failed to fetch user preferences, {cause: err});\n      })\n    }\n}\nfetcUserPreferences();\n复制代码\n```\n\n了解有关该提案的更多信息，[github.com/tc39/propos…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Ftc39%2Fproposal-error-cause \"https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-error-cause\")\n\n**06、Class Fields**\n\n在此版本之前，没有适当的方法来创建私有字段， 通过使用提升有一些方法可以解决它，但它不是一个适当的私有字段。但现在很简单， 我们只需要将 # 字符添加到我们的变量声明中。\n\n```\nclass Foo {\n  #iteration = 0;\n\n  increment() {\n    this.#iteration++;\n  }\n\n  logIteration() {\n    console.log(this.#iteration);\n  }\n}\n\nconst x = new Foo();\n\n// ❌ Uncaught SyntaxError: Private field \'#iteration\' must be declared in an enclosing class\nx.#iteration\n\n// ✅ works\nx.increment();\n\n// ✅ works\nx.logIteration();\n复制代码\n```\n\n拥有私有字段意味着我们拥有强大的封装边界， 无法从外部访问类变量，这表明 class 关键字不再只是糖语法。\n\n我们还可以创建私有方法：\n\n```\nclass Foo {\n  #iteration = 0;\n\n  #auditIncrement() {\n    console.log(\'auditing\');\n  }\n\n  increment() {\n    this.#iteration++;\n    this.#auditIncrement();\n  }\n}\n\nconst x = new Foo();\n\n// ❌ Uncaught SyntaxError: Private field \'#auditIncrement\' must be declared in an enclosing class\nx.#auditIncrement\n\n// ✅ works\nx.increment();\n复制代码\n```\n\n该功能与私有类的类静态块和人体工程学检查有关，我们将在接下来的内容中看到。\n\n了解有关该提案的更多信息，[github.com/tc39/propos…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Ftc39%2Fproposal-class-fields \"https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-class-fields\")\n\n**07、Class Static Block**\n\n作为新规范的一部分，我们现在可以在任何类中包含静态块，它们将只运行一次，并且是装饰或执行类静态端的某些字段初始化的好方法。\n\n我们不限于使用一个块，我们可以拥有尽可能多的块。\n\n```\n// ✅ will output \'one two three\'\nclass A {\n  static {\n      console.log(\'one\');\n  }\n  static {\n      console.log(\'two\');\n  }\n  static {\n      console.log(\'three\');\n  }\n}\n复制代码\n```\n\n他们有一个不错的奖金，他们获得对私有字段的特权访问， 你可以用它们来做一些有趣的模式。\n\n```\nlet getPrivateField;\n\nclass A {\n  #privateField;\n  constructor(x) {\n    this.#privateField = x;\n  }\n  static {\n    // ✅ it can access any private field\n    getPrivateField = (a) => a.#privateField;\n  }\n}\n\nconst a = new A(\'foo\');\n// ✅ Works, foo is printed\nconsole.log(getPrivateField(a));\n复制代码\n```\n\n如果我们尝试从实例对象的外部范围访问该私有变量，我们将得到无法从类未声明它的对象中读取私有成员#privateField。\n\n了解有关该提案的更多信息，[github.com/tc39/propos…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Ftc39%2Fproposal-class-static-block \"https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-class-static-block\")\n\n**08、Private Fields**\n\n新的私有字段是一个很棒的功能，但是，在某些静态方法中检查字段是否为私有可能会变得很方便。\n\n尝试在类范围之外调用它会导致我们之前看到的相同错误。\n\n```\nclass Foo {\n  #brand;\n\n  static isFoo(obj) {\n    return #brand in obj;\n  }\n}\n\nconst x = new Foo();\n\n// ✅ works, it returns true\nFoo.isFoo(x);\n\n// ✅ works, it returns false\nFoo.isFoo({})\n\n// ❌ Uncaught SyntaxError: Private field \'#brand\' must be declared in an enclosing class\n#brand in x\n复制代码\n```\n\n了解有关该提案的更多信息。[github.com/tc39/propos…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Ftc39%2Fproposal-private-fields-in-in \"https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-private-fields-in-in\")\n\n**最后的想法**\n\n这是一个有趣的版本，它提供了许多小而有用的功能，例如 at、private fields和error cause。当然，error cause会给我们的日常错误跟踪任务带来很多清晰度。\n\n一些高级功能，如top-level await，在使用它们之前需要很好地理解。它们可能在你的代码执行中产生不必要的副作用。\n\n我希望这篇文章能让你和我一样对新的 ES2022 规范感到兴奋，请记得点赞我，关注我。\n\n**\\- End -**\n','2022-07-12 02:37:00',0000000004,'前端',36),(0000000012,'js中关于递归与回溯',' 递归作为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。','![js中关于递归与回溯](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6f8dcd4c39043c581d0a89475bbe412~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n## 何为递归\n\n> 递归作为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。需要注意的是，递归必须要用边界条件，否则很容易导致死循环\n\n## 构成递归条件\n\n1.  子问题须与原始问题为同样的事，且更为简单\n2.  不能无限制地调用本身，须有个出口，化简为非递归状况处理\n\n但是递归函数并不容易一下子就能想的出来，所以我们可以先通过一个子问题来逐步延申。\n\n**问题一：** 假设我们需要求1+2+3+...+100的值，我们很容易想出下面的代码\n\n```\n function calcNum(n) {\n      let sum = 0\n      for (let i = 0; i <= 100; i++) {\n        sum += i\n      }\n      return sum\n    }\n    console.log(calcNum()) // 5050\n复制代码\n```\n\n这样的代码是不满足于递归中，直接或者间接调用本身的定义。那么如何变成递归版本呢？(**任何的循环，都可以写成递归**)\n\n1.  寻找相同的子问题 该题目相同的子问题很明显是sum+=i，该过程是重复调用的过程。\n2.  寻找终止条件 寻找递归的终止条件，该问题的终止条件是i>100的情况\n\n**这两大要素都找到了，就很容易写出下面的递归版本**\n\n```\nfunction calcNum(n) {\n      let sum = 0\n      function dfs(n) {\n        if (n > 100) {\n          return\n        }\n        sum += n\n        n++\n        dfs(n)\n      }\n      dfs(n)\n      return sum\n    }\n    console.log(calcNum(1)) // 5050\n复制代码\n```\n\n## 关于回溯\n\n递归一定伴随着回溯，那么什么是回溯呢？以上面的代码为例子，我们分别在这两处地方输出n的值\n\n```\nfunction calcNum(n) {\n      let sum = 0\n      function dfs(n) {\n        if (n > 100) {\n          return\n        }\n        sum += n\n        n++\n        console.log(n, \'递归前的n\')\n        dfs(n)\n        console.log(n, \'递归后的n\')\n      }\n      dfs(n)\n      return sum\n    }\n复制代码\n```\n\n毫无疑问，\"递归前的n\"会按照1-100输出，而\"递归后的n\"则会100-1输出，这就说明了一个很重要的知识点，**递归函数是类似一个栈迭代的过程，它的值输出的顺序为先进后出**。通俗一点说，递归函数后面的参数，会反转输出。\n\n要想理解回溯的含义，最为经典的还是二叉树的遍历。二叉树的遍历，又分为**前序遍历，中序遍历，后序遍历**，分别通过代码来感受一下这三种遍历的方式。 前序遍历\n\n```\n// 基本结构\n const treeNode = {\n      val: 1,\n      left: null,\n      right: {\n        val: 2,\n        left: {\n          val: 3,\n          left: null,\n          right: null\n        },\n        right: null\n      }\n    }\n复制代码\n```\n\n来看下leetcode [前序遍历](https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fbinary-tree-inorder-traversal%2F \"https://leetcode.cn/problems/binary-tree-inorder-traversal/\")原题 ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9edcd4f3071e439a9535b117c5e8b993~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n```\nconst root = {\n      val: 5,\n      left: {\n        val: 4,\n        left: {\n          val: 1,\n          right: null,\n          left: null\n        },\n        right: {\n          val: 2,\n          right: null,\n          left: null\n        }\n      },\n      right: {\n        val: 6,\n        left: {\n          val: 7,\n          left: null,\n          right: null\n        },\n        right: {\n          val: 8,\n          left: null,\n          right: null\n        }\n      }\n    }\n    function getRoot(root) {\n      const res = []\n      function dfs(root) {\n        if (!root) {\n          return\n        }\n        res.push(root.val)\n        dfs(root.left)\n        dfs(root.right)\n      }\n      dfs(root)\n      return res\n    }\n    console.log(getRoot(root)) // 5 4 1 2 6 7 8\n复制代码\n```\n\n中序遍历\n\n```\nfunction getRoot(root) {\n      const res = []\n      function dfs(root) {\n        if (!root) {\n          return\n        }\n        dfs(root.left)\n        res.push(root.val)\n        dfs(root.right)\n      }\n      dfs(root)\n      return res\n    }\n    console.log(getRoot(root)) // 1 4 2 5 6 7 8\n复制代码\n```\n\n后续遍历\n\n```\nfunction getRoot(root) {\n      const res = []\n      function dfs(root) {\n        if (!root) {\n          return\n        }\n        dfs(root.left)\n        dfs(root.right)\n        res.push(root.val)\n      }\n      dfs(root)\n      return res\n    }\n    console.log(getRoot(root)) // 1 2 4 7 8 6 5\n复制代码\n```\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7de29ee35b24ce798f74f95f54fd614~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) 在写递归的时候，时刻都要注意边界，以上场景的边界，则是找不到节点（节点为null）的时候，就退出。\n\n通过输出的结果可以得知以下规律：\n\n1.  前序遍历：中左右\n2.  中序遍历：左中右\n3.  后序遍历：左右中\n\n而实现该规律的主要依据，是通过递归的回溯导致，我们以中序遍历为例子：\n\n```\n dfs(root.left)\n res.push(root.val)\n dfs(root.right)\n复制代码\n```\n\n当第一个dfs(root.left)递归结束后，就会弹出\'1\'的节点，然后就进了dfs(root.right)的节点，发现是个null，说明这个dfs(root.right)递归结束，那么此时则回到了\'4\'的节点，然后就进入了dfs(root.right)节点...\n\n## 实际业务\n\n二叉树的遍历，其实类比于我们常见操作菜单树，或着树形结构的操作...\n\n```\nlet tree = [\n  {\n    id: \'1\',\n    title: \'节点1\',\n    children: [\n      {\n        id: \'1-1\',\n        title: \'节点1-1\'\n      },\n      {\n        id: \'1-2\',\n        title: \'节点1-2\'\n      }\n    ]\n  },\n  {\n    id: \'2\',\n    title: \'节点2\',\n    children: [\n      {\n        id: \'2-1\',\n        title: \'节点2-1\'\n      }\n    ]\n  }\n]\n复制代码\n```\n\n当我们要寻找遍历每个节点的时候，同样需要注意边界，当我们操作的数据没有的时候或者不存在的时候，则退出当次遍历。\n\n```\n function getRootData(tree) {\n      const res = []\n      function dfs(tree) {\n        if (!tree || tree.length === 0) {\n          return res\n        }\n        for (let i = 0; i < tree.length; i++) {\n          const t = tree[i]\n          if (t.children && t.children.length > 0) {\n            dfs(t.children) // 开始递归\n          } else {\n            res.push(t.title) //  [\'节点1-1\', \'节点1-2\', \'节点2-1\']\n          }\n        }\n      }\n      dfs(tree)\n      return res\n    }\n复制代码\n```\n\n可能有人会有疑问，这也没有利用到回溯的操作啊，那么我就换个场景，假如**我给个你节点的id，你帮我找出他所有的父节点**，那么你可能会怎么操作呢？\n\n```\n const tree = [\n      {\n        id: \'1\',\n        title: \'节点1\',\n        children: [\n          {\n            id: \'1-1\',\n            title: \'节点1-1\'\n          },\n          {\n            id: \'1-2\',\n            title: \'节点1-2\'\n          }\n        ]\n      },\n      {\n        id: \'2\',\n        title: \'节点2\',\n        children: [\n          {\n            id: \'2-1\',\n            title: \'节点2-1\',\n            children: [\n              {\n                id: \'2-1-1\',\n                title: \'节点2-1-1\'\n              }\n            ]\n          }\n        ]\n      }\n    ]\n    function pathTree(tree, id) {\n      const res = []\n      function dfs(tree, path) {\n        if (!tree || tree.length === 0) {\n          return\n        }\n        for (let i = 0; i < tree.length; i++) {\n          const t = tree[i]\n          path.push(t.id)\n          if (path.includes(id)) {\n            res.push(path.slice())\n          }\n          if (t.children && t.children.length > 0) {\n            dfs(t.children, path)\n          }\n          path.pop() // 路径回溯\n        }\n      }\n      dfs(tree, [])\n      return res\n    }\n    console.log(pathTree(tree, \'2-1-1\')) // [2,2-1,2-1-1]\n复制代码\n```\n\n其实以上核心的代码为path.pop()，为什么需要这句代码呢？我们可以通过leetcode上的排列组合问题来进行讨论。\n\n## 组合问题\n\n[经典的组合问题](https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fcombinations%2F \"https://leetcode.cn/problems/combinations/\") ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ead1ec3c1884466a8e8c56b2d80dba0e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n以上面题目为例子，从1-4(n)的数字中，排列2(k)个数的组合。解这个题目，可以使用暴力的做法，嵌套for循环来完成该功能。\n\n```\nfunction combine(n) {\n      const res = []\n      for (let i = 1; i <= n; i++) {\n        for (let j = i + 1; j <= n; j++) {\n          res.push([i, j])\n        }\n      }\n      return res\n    }\n\n  console.log(combine(4), \'res\') // [1,2][1,3][1,4][2,3][3,4][2,4]\n复制代码\n```\n\n细心朋友就会发现，它嵌套for次数则是等于它排列(k)的次数，那么我假如k的次数是10，或者20，那么岂不是要嵌套10个或者20个for循环。这套代码写下来，估计是个人都会晕了。在以上代码块中也可以发现**重复的子问题也就是for循环，它想要的结果则为当我们找个了k个数的时候就停止**。那么我们可以尝试通过递归来解决该问题（递归for循环），但是这样的过程还是很抽象的，需要借助图例理解。（任何的组合问题，都可以理解成为n叉树的遍历） ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c200c5d379784534bad684fff43203d8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n```\n function combine(n, k) {\n      const res = []\n      function dfs(n, path, startIndex) {\n        if (path.length === k) {\n          res.push(path.slice())\n          return\n        }\n        for (let i = startIndex; i <= n; i++) {\n          path.push(i)\n          dfs(n, path, i + 1)\n          path.pop()\n        }\n      }\n      dfs(n, [], 1)\n      return res\n    }\n复制代码\n```\n\n当我们选择到了\\[1,2\\]之后，则需要回到1的位置，因为这个时候需要选择3选项，形成\\[1,3\\]，那么回到\'1\'的操作，就类似于二叉树遍历回到父节点的操作，如果此时我们不操作，path.pop()，那么此时就会形成了\\[1,2,3\\]，这样的结果明显不是我们想要，所以在操作push \"3\"的过程，需要先把2给pop掉。而递归的终止条件则为当路径的长度等于k的时候则退出。 另外在函数体中，还发现了startIndex的存在，这个是作为横向for循环开始的位置，我们结合上面两个for循环的代码，是不是发现了j = i + 1的操作，而这个startIndex则是还原了这个操作而已。\n\n关于回溯的问题，leetcode还有许多很好的题目：\n\n[组合总数](https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fcombination-sum%2F \"https://leetcode.cn/problems/combination-sum/\") [全排列](https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fpermutations%2F \"https://leetcode.cn/problems/permutations/\") [子集](https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fsubsets%2F \"https://leetcode.cn/problems/subsets/\") ...','2022-07-26 06:37:00',0000000003,'前端',10),(0000000019,'一名外包仔的2022年中总结','大家好，我是twinkle, 目前是某公司的一名外包员工。现在2022年已经过去一半了，而我还是这个样子，现在借用当前的平台，来总结下今年上半年的工作情况和自己的一个情况吧','![一名外包仔的2022年中总结](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c98fa14b89d40738093b768a5885ff8~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n时光不负，创作不停，本文正在参加[2022年中总结征文大赛](https://juejin.cn/post/7108989863126368286 \"https://juejin.cn/post/7108989863126368286\")」\n\n# 自我介绍\n\n大家好，我是`twinkle`, 目前是**某公司的一名外包员工**。现在`2022`年已经过去一半了，而我还是这个样子，现在借用当前的平台，来总结下今年上半年的工作情况和自己的一个情况吧???\n\n# 逝去半年的时光\n\n## 文章\n\n在过去的半年中，自己除了做自己分内之事外，也在[掘金](https://juejin.cn/user/3448527863681853 \"https://juejin.cn/user/3448527863681853\")，[csdn](https://link.juejin.cn?target=https%3A%2F%2Ftwinkle.blog.csdn.net%2F \"https://twinkle.blog.csdn.net/\")，[头条](https://link.juejin.cn?target=https%3A%2F%2Fmp.toutiao.com%2Fprofile_v4%2Findex \"https://mp.toutiao.com/profile_v4/index\")等平台发表自己的文章，也算是给自己的一个交代吧!???\n\n2022年上半年的文章写的并不是很多，有的时候会质疑自己，**写那么多干啥，又没有人看???**。后来想通了，`写文章是自己的一个输出的过程，在学习一个知识点，看文章或者看视频都是输入的过程，写代码是自己输出的过程，而写文章是把自己理解到的知识点来告诉别人，我懂了，希望你也能懂。???`\n\n上半年主要是[vue3源码系列的文章](https://juejin.cn/column/7101509647936258056 \"https://juejin.cn/column/7101509647936258056\"),在写这个文章还需要重点感谢[cuixiaorui](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcuixiaorui \"https://github.com/cuixiaorui\")/**[mini-vue](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcuixiaorui%2Fmini-vue \"https://github.com/cuixiaorui/mini-vue\")** 这个仓库，里面的代码都写了注释，在每个流程节点都有`console.log`的输出，但是一开始人家的并不是`monorepo`,而我直接使用`monorepo`,算是自己在人家肩膀上的一种小小的创新吧???！在人家的基础上，自己也慢慢的可以写出来一个简单vue3源码，有兴趣的请[查看源码](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcll123456%2Fcommon-study%2Ftree%2Fmaster%2Fvue3-analysis \"https://github.com/cll123456/common-study/tree/master/vue3-analysis\")\n\n## github\n\n在`github`上面，自己也是坚持输出，请看下图；\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/893c83772099446dbe4d459dc2e2b804~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n在项目上，自己也创建了许多项目，并且带有完成进度\n\n| 项目名称 | 简介 | 进度 |\n| --- | --- | --- |\n| [vue3-webpack-ssr](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcll123456%2Fvue3-webpack-ssr \"https://github.com/cll123456/vue3-webpack-ssr\") | 该项目是2022年年3月开始的，然后主要实现了自己手动搭建一个vue3 ssr的项目，体验下vue3 ssr和vue2的区别，真实感受是流程都是一样的，打两份包，服务端生产html结构，最后客户端来激活。 | `100%` |\n| [rouyi-cloud-vue3](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcll123456%2Frouyi-cloud-vue3 \"https://github.com/cll123456/rouyi-cloud-vue3\") | 该项目启动于21年的9月份，随着elment-plus的更新，自己也同步更新了。现在大致的功能都实现了，后续自己要把后台改成node,然后用ts来改写 | `js 100%`， `ts 0%` |\n| [basic-template](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcll123456%2Fbasic-template \"https://github.com/cll123456/basic-template\") | 一个模板项目，里面集中了`vue3-ruoyi`和`vue2-ruoyi`的项目，仿照`vite`的安装方式，自己写了个脚手架，将来还需要完善里面的模板 | `100%` |\n| [deal-big-file](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcll123456%2Fdeal-big-file \"https://github.com/cll123456/deal-big-file\") | 在项目开发中遇到**大文件的上传和下载**，然后自己根据实战和当前网上的教材和资源，自己写了个实现思路，帮助更多的人 | `100%` |\n| [template-varlet-v3-ts](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcll123456%2Ftemplate-varlet-v3-ts \"https://github.com/cll123456/template-varlet-v3-ts\") | ✈✈✈使用unocss,vite，varlet来搭建移动端，所有资源都是按需加载，非常快，做的这个项目需要感谢[开源狂魔Anthony Fu](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantfu \"https://github.com/antfu\")写的大部分工具，我只是把他的这些工具给组合起来，写了一个移动端的模板，开发了移动端中常用的功能，建议有需要的可以下载看看哦! | `100%` |\n| [vue-design](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcll123456%2Fvue-design \"https://github.com/cll123456/vue-design\") | 这个项目的初心是想做一个**低代码平台**，但是在自己开发过程遇到了写问题，现在开发的程度有点低，希望在后续中自己能找到解决办法 | `10%` |\n| [common-study](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcll123456%2Fcommon-study \"https://github.com/cll123456/common-study\") | 这个项目主要想打造一个共同学习的项目，记录自己在过去和将来所有的学习过程都记录在里面 | `1%` |\n\n> 在`github`上面，上半年也建立了好几个库，都是带有学习的目的来建立仓库，希望自己的学习成果能够帮助其他人\n\n# 总结\n\n今年上半年大体上还算满意，也存在着许多的不足，例如：自己看的书也较少，完成的内容也不算好，可能是自己的能力有待提升吧！**希望在后续的半年中，自己能够找到一份满意的工作，毕竟外包不是长久之计，希望能遇到伯乐(●\'◡\'●)**,虽然我不是千里马，但是我相信，水到渠成，自己现在的努力，在将来肯定是对自己有帮助的，与大家共勉！**欢迎大家在下面留言，如果有内推的，也欢迎来内推我哦，成功的话请吃饭???和和奶茶???**','2022-08-05 18:45:26',0000000010,'代码人生',24),(0000000020,'大裁员下，程序员如何做“副业”？','前几天有幸看了尤雨溪尤大的直播，他们谈到一个话题，是说目前前端人，或者是整个程序员群体如何做副业？近年来互联网行情下降，好多人都在思考要不要搞个副业来抵御风险。','![大裁员下，程序员如何做“副业”？](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e7d37251bc04bf48caafe62eae2991e~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n> 本文来源公众号：[程序员成功](https://link.juejin.cn?target=https%3A%2F%2Fwww.ruims.top%2Fstatic%2Fwxpub.png \"https://www.ruims.top/static/wxpub.png\")\n\n大家好，我是杨成功。\n\n前几天有幸看了尤雨溪尤大的直播，他们谈到一个话题，是说目前前端人，或者是整个程序员群体如何做副业？近年来互联网行情下降，好多人都在思考要不要搞个副业来抵御风险。\n\n这不又来事了，这两天又爆了互联网大裁员。继阿里“向社会输送人才”之后，京东又搞了个“毕业礼”，整的小伙伴们人心惶惶。副业的关注度又一波升级。\n\n那今天我们就来聊聊，程序员做副业这件事。\n\n## 为什么程序员都想着做副业？\n\n我理解今天的程序员为什么都有做副业的想法，原因不外乎两个方面。\n\n一是互联网的爆发期已过，以前程序员体量小，会点基本技能就可以不愁工作，薪资也非常可观，但现在随着大量人员涌入，各种名校高学历的加入内卷，我们突然发现没什么竞争优势了。\n\n二是互联网开发圈这种畸形的工作氛围，熬夜加班过于严重，消耗生命力来赶进度。特别是大厂，钱是给的多，但是透支强度懂得都懂，说句不好听的是拿命换钱。\n\n以前大家听这些可能只是自嘲一下，随着脉脉上不断爆出大厂程序员加班猝死的消息，大家开始慌了，原来比起收入，健康才是我们终身的财富。\n\n当然还有一个原因，不只是程序员的职业阴霾，但程序员首当其冲，那就是 “35 岁危机”。\n\n程序员是拼学习能力和创造能力的职业，不进则退的规则远大于其他行业。35 以后，如果你不是真的热爱这个行业，那么你会发现，20 多岁的那种学习钻研的毅力已经没有了。再加上身体状况大不如前，加班扛不动，各方面你怎么和新来的小伙子们拼？\n\n以上的种种情况，再加上网络上疯狂的制造焦虑，我们自己也突然有了种随时会降薪，随时会被裁，随时要加入内卷，甚至随时会没命的担忧，开始想后路了。不行搞点副业？不行创个业？\n\n所以如果你今天在技术社区发一篇“程序员如何搞副业”的文章，点击率一定翻倍。根本原因，就是大家对未来的担忧。\n\n卷不动怎么办？遇到 35 岁危机怎么办？大家都想着规避风险，这才不得不去关注副业。\n\n## 怎么看 “加班内卷” 和 “35 岁危机”？\n\n这两个现象是程序员焦虑的主要来源，看似避无可避，可有没有想过根本原因是什么？\n\n我们再往深剖一下这两个问题，其实大家担心的是：“如果这种加班状态持续到 35 岁，我能不能撑得住？到时候竞争力下降，我会不会被新人替代？”\n\n但是我想说一个误区，就是初中级别的程序员，需要大量的写代码来提升自己的技术能力，不断的投入时间学习，研究，拓宽视野。但是到了高级别的程序员，比如带团队的 leader，架构师，写代码一定是越来越少的。\n\n对于这些人来说，他们不需要通过加班来发挥价值，他们有自己的核心竞争力和不可替代性，写代码也是写一些核心的关键的代码，更多的时间关注技术选型和解决问题的方案。所以说程序员的职业生涯不会一直伴随着加班，当你拥有核心竞争力，你的工作方式反而会很自由。\n\n那什么是核心竞争力？我说一句话大家一定会有体会：你的技术 leader，**一个决策可以让团队的开发效率提升 10 倍，也可能让团队的开发效率降低 10 倍**，有可能最后还出不了成果，甚至告诉你这个不行得重来！\n\n这就是核心竞争力呀！一个程序员对技术选型，解决方案的评估和判断，这才是他的核心竞争力。这种竞争力不是你刷一堆算法，背一堆八股文，学很多面试技巧，他就能有的。这些东西是需要你经过几年大量的 **写代码+学习+尝试+思考** 才能培养出的能力。\n\n所以说，我们所谓的 “加班内卷” 和 “35 岁危机”，得分两个阶段来看。\n\n### 工作五年内\n\n如果你是工作的前五年，这个阶段你精力旺盛，学习能力强劲，那就是要卷的啊。趁着职业上升的黄金时期，花大量的时间和精力做积累，不断做加法，尽力尝试着去拓宽技术视野，让自己成为一个独当一面的人。这样你才能积累到别人无法超越的高度。\n\n如果这个阶段你躺平了，你想着反正大家都在卷，我不想参与其中，每天上班空闲摸个鱼也挺好的。那这样持续几年，除了业务代码熟练一些，你在技术深度广度上都没多大的长进。当你发现公司的新人越来越厉害，他们带来的技术让你应接不暇的时候，你突然发现卧槽，危机真的来了，这个时候再卷是不是晚了？\n\n我不是鼓励大家内卷，相反我很反对做那些没什么意义光是自我消耗的事情。但是努力和积累永远不是卷，更不是不想奋斗的借口。如果卷真的避免不了，那一定要“卷的有价值”。\n\n比起内卷，其实我更鼓励大家“外卷”。外卷到意思就是当你在某个领域积累了一定经验后，要试着跳出当前的圈子，去探索一下外面的世界。\n\n比如你是一个前端程序员，尽管你的 Title 是“前端”，但你不能一直只在前端的圈子里打转。作为一个程序员，只要涉及到程序开发的，前端后端产品服务器，你都要接触，这样你的视野才会变的更广，看问题的角度更多，随之你的判断能力和才会得到提升。\n\n大家总觉得，一个前端就该专攻 js，只有准备向全栈发展才会接触后端。其实不是的，接触并不代表一定要做，了解整体可以培养你的全局观。比如你遇到了一个难题，你只会在前端的范畴研究，可能这个问题在后端处理只是一行代码的事情，可你不知道呀，所以会浪费很多时间。\n\n### 工作五年后\n\n如果你已经工作五年以上，上面说的你都没做到，眼看着自己快奔三了，还是一线开发，依然没有形成核心竞争力，这个时候 35 岁危机袭面而来。你面对一浪强过一浪的后浪，有心追赶但是明显吃力，这个时候即使老板不会裁你，你心中也会忐忐忑忑，害怕自己某一天突然失业。\n\n但是如果上面说的你都做到了，工作五年后，你多半会带一个小团队，或者成为架构师。不管有没有进入大厂，你总会在一个地方持续发挥着自己的不可替代性。\n\n工作的基本任务你会安排给组内小伙伴，架构和难题自己攻克，长期下来，你会越来越值钱，这是再厉害的应届生都做不到的，这个时候你会有 35 岁危机吗？自然不会。\n\n而且我有一个预感，程序员这个行业一定是越做越自由的。当你能力出众，技术超群，地域已经限制不了你，你可以选择任意地方的工作，并不一定要守在某一家公司，某一个城市。\n\n或许有一天你可以在三亚海边租个小房子，每天早上起来晒晒太阳，打开电脑，安排好今天的工作，然后看看前沿技术资讯，review 一下同事的代码，花几个小时解决掉剩余的难题，然后眯着眼继续晒太阳。\n\n聊这些就比较理想了，未来还是要展望的嘛。但是核心思想就是，如果你五年内没有做好积累，形成自己的核心竞争力，那么 35 岁危机也许真的离你不远。反之，则是另外一种状况。\n\n## 怎么做副业\n\n上面说，程序员的 35 岁危机本质是因为没有核心竞争力。再回到做副业这件事，怎么做副业能帮我们抵抗 35 岁危机？\n\n既然危机来源于核心竞争力，那么副业的目的一定是帮助我们提升核心竞争力。\n\n这里大家也会有一个误区，认为做副业的目的是为了赚钱，开辟一条新的收入途径。这个也不能算错，但是你想啊，一个年薪百万的程序员需要做副业吗？\n\n人的精力有限，如果你的副业不是为了帮你巩固主业，而是分走了你投入在主业上的一部分精力，可能你真的赚了笔钱，但长远来看肯定没有你持续提升带来的收入更多。\n\n核心竞争力除了硬实力，当然也包括这些：\n\n*   名气\n*   口碑\n*   帮助别人\n*   分享技术\n*   分享思想\n\n名气不用说，在任何圈子积累了名气路就会顺畅许多；口碑呢就是说你这个人的办事能力，靠不靠谱；帮助别人是你有没有带动别人一起成长的能力；分享最关键了，你的任意优势，包括技术和思想，如果你认为是有价值的，那就分享出来啊，这样别人才能在更多方面了解你，这是你简历之外的另一张名片。\n\n如果你做副业的目标是为了增加上面几个方面的软实力，OK，这就是最棒的。这些方面可能短期看不到回报，光是付出了，但是坚持下去，一定会给你带来意料之外的惊喜。\n\n具体到做副业的方式有哪些？我认为两个足矣：\n\n*   **写文章**\n*   **录视频**\n\n写文章真的是一个非常非常好的学习总结方式。人的听和看的能力是天生的，但是读和写的能力是需要后天培养的。比如你看一个技术视频，看完貌似学会了。十分钟后让你写一下这个视频的关键信息，你一想，哎刚才是什么来着？好像记不清了。有些东西你以为掌握了，但是让你写的时候，你才发现那也许是错觉。\n\n写文章会逼着你回忆和思考，没有真正吸收和消化的东西，你是写不出来的。所以坚持写文会提升我们的思考力和总结概括能力。还有你工作中遇到的重要问题和解决方案，如果不记下来，过几个月多半会忘。等到要写简历的时候，突然发现好像没什么可写，这是非常不划算的事情。\n\n除此之外，你还可以把自己的文章发表到社区，会得到很多读者的反馈，这个会给到你非常正向的鼓励，也有利于查漏补缺，同时也会慢慢积累你的口碑和名气。\n\n不过开始写文章的时候会比较痛苦，写的不好，还憋不出来。其实我现在也是这个状态，一篇文章得写一周，一句话改来改去总觉得不通顺，总觉得结构设计差点意思。不过只能硬着头皮写，写的多了总会得心应手的。\n\n至于录视频，我最近才发现这个事的好处，有点后知后觉了哈。\n\n不得不承认我们程序员大多都宅，不爱说话，表达能力一般般。好多人更愿意写几行代码，也不愿意多说一句话。但是你想啊，如果有一天你的技术非常厉害了，你要把自己的经验分享给别人，如果你不能很精简的表达出关键点并且让别人听得懂的话，这是不是成了你的短板？\n\n录视频虽然也是总结，思考，但比起写文章，它对表达能力的要求更高。表达能力是你往上走的通用能力，如果你想成为管理层几乎必备。但是呢我们工作和生活环境中表达的机会又很少，如果你可以尝试通过录视频来分享你的技术，一来有的聊，二来练习面对镜头的心态和语言组织，这是非常好的锻炼。\n\n总之呢，打造核心竞争力，不仅仅是代码，不断突破自己的局限，才是正道。\n\n本文聊的做副业并没有聊怎么赚钱，而是赚“核心竞争力”，这个东西虽然不能直接带来票子，但又何尝不是你抵御风险的底气呢？','2022-03-30 01:11:00',0000000001,'代码人生',2),(0000000021,'判空的姿势你学废了么','我想大家在开发过程中遇到最多的问题便是NullPointerException即空指针异常了吧，空指针异常一般分为以下几种情况：','我想大家在开发过程中遇到最多的问题便是NullPointerException即空指针异常了吧，空指针异常一般分为以下几种情况：\n\n1.  object对象为null，为null的情况大多数都是上一步的查询方法没有查到结果，此时通过object来get其中的属性的时候会报异常\n2.  对象集合为空，然后get(0)或者遍历的时候没有获取到对象\n3.  字段值为null，此时又拿次字段去做比较还是什么，也会报异常\n\n现在对常见情况进行详解\n\n*   对象为空的话我们常用的就是以下方式jdk的util包里的方法\n\n```\nObjects.isNull(obj)\nObjects.nonNull(obj)\nobj != null\nobj == null\n复制代码\n```\n\n*   集合为空的话最常用的就是Spring里带的方法\n\n```\nCollectionUtils.isEmpty(list)\nlist.size() > 0\n复制代码\n```\n\n*   字段值为null的时候常用的是\n\n```\nStrings.isBlank(str)\nStringUtil.isEmpty(str)\n复制代码\n```\n\n前两种判空我就不做讲解了，下面就是着重讲一下第三种关于一些字段的判空\n\n一般字段为空判断的都是String类型，或者数据库字段设置默认值为null或者空字符串 这个时候我们需要对字符串做处理，例如进行正则匹配什么的，如果是null或者是空字符串的话就会有问题，有一小部分人可能习惯了isEmpty方法，但是这种情况会很容易出现空字符串的问题，这个时候系统就会报异常了。下面我来给大家看一下两个方法的区别：\n\n**1.Strings.isBlank(str)** --org.apache.logging.log4j.util 包\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57d815c80adb402ca473f2522b9d7b4a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?) 我们可以看到方法底层有两种判断方式，前面的就是我们常见的等于null判断，后面的方法我们先看一下trim()方法： ![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00501eb37feb415bbeabba555ebd90b6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?) 源码具体的作用也是对字符串的前后部分的空格做了处理，删除了字符串最前面和尾部的空格，将中间的字符串包含空格(这个空格不是前面或者后面的空格)返回。 将字符串进行trim()方法处理空格后便进行isEmpty()方法处理了:\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cf5e011c5884ed795a3f1900421acd0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?) **2.StringUtilS.isEmpty(str)** ---org.apache.commons.lang3 包\n\n​![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d00d09c37d14427a668a6cccccc496e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)​编辑​ 此时我们看一下apache的lang包下的判空少了个空格的处理， 由此可见我们以后再对字符串类型的字段处理的时候应该使用哪个方法都一清二楚了吧。\n\n再补充一点：我们很多系统中都会有很多过滤条件，例如单号或者什么的也有很多是string类型的，我们在后台接收参数的时候可以先通过trim()方法将操作人误操作的前后空格给处理掉，然后再将处理后的参数放到筛选条件中进行筛选，这样保证用户的体验性。\n\n提示：现在jdk的util包还有一个方法是Optional()方法，这个方法可以通过链式进行后续的一系列处理，功能挺全且好用，不过对于初级程序员可能阅读起来比较麻烦，我会在后面跳一个时间去针对这个进行详细介绍。\n\n```\nOptional(obj)\n复制代码\n```\n\n好了，这篇文章到此结束了，如果有大佬还有更好的方法可以在评论区发表出来，谢谢~\n\n如果感觉我这边文章写的不错的话欢迎三连，点赞、收藏、转发~','2022-08-08 10:04:00',0000000002,'代码人生',17),(0000000022,'我裁完兄弟们后，辞职了，转行做了一名小职员','那天早晨，我冲进总经理的办公室，发现人力资源总监也在，我说：真巧，真好，两位都在，我要辞职！','![我裁完兄弟们后，辞职了，转行做了一名小职员](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14ac7e1dd11547c881ed6ea82813ab2f~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n「时光不负，创作不停，本文正在参加[2022年中总结征文大赛](https://juejin.cn/post/7108989863126368286 \"https://juejin.cn/post/7108989863126368286\")」\n\n# 序\n\n> 那天早晨，我冲进总经理的办公室，发现人力资源总监也在，我说：真巧，真好，两位都在，我要辞职！\n\n我在马路上走着，头脑有些昏昏沉沉的。\n\n“**大爷，我有故事你听听吗？**”，扫马路的大爷没理我，提起垃圾桶，走了。\n\n“**阿姨，你想听听我的经历不？**”，等公交的大妈拦下一辆出租车，走了。\n\n算了，年中总结到了，我就谈一谈我的上半身……上半生……不是，上半年吧。\n\n### 一、十年职场终一梦，互联网里心不平\n\n`2022`年，是我工作的第`11`年，这`11`年，我都在互联网中沉浮，而且一直是向着风口奔跑。\n\n我一开始处于电信增值行业，我们叫**SP**业务。\n\n现在的年轻人可能很难想象，以前的互动主要靠短信，就是`1`毛钱一条的短信。\n\n> 比如某电视台有个话题，对于一个事件你是支持还是反对，如果支持发短信1，反对发送2。\n\n这时候，发送一条短信的定价可以自己设置，比如**2元1条**，在运营商那里备个案就行，当时来说，这是合法的。\n\n一般为了提高发短信的积极性，都会在最后搞一个抽奖，抽中之后送套茶壶啥的，这样，两块钱也就舍得花了。\n\n因为自己有定价的权利，所以可玩的就有很多。\n\n比如：\n\n> 我做一个游戏嵌到手机里，想玩就发短信啊。\n\n再比如：\n\n> 我提供一个服务，每天给你发送天气预报信息，想订阅就发短信啊。\n\n`2011`年，随着智能手机的兴起，短信有被网络消息取代的趋势，而且乱收费也受到了监管。\n\n所以，一些**SP**企业就纷纷转型移动互联网，去做智能手机应用。\n\n我此时毕业，因为学的就是智能手机应用开发专业，而且[大学期间也自己搞了一些](https://juejin.cn/post/7123985353878274056 \"https://juejin.cn/post/7123985353878274056\")和`iOS`的**APP**去运作，所以很顺利地就找到工作。\n\n这一干就是`5`年，搞过手机游戏，搞过**订餐系统**，搞过**电商**，搞过**O2O**，搞过**政务**……因为企业转型，一般没有目标，_什么火就搞什么_。\n\n后来，我感觉干的太乱了，自己应该抓住一个行业去搞，于是在`2016`年就去了另一家公司，主要做**在线教育平台**。\n\n所有公司都一样，**一个公司干久了，职位自然会提升**，因为人都熬走了，只剩下你了，另外你跟各部门都熟，工作推进起来也方便。\n\n我也是这么一步一步走过来，从普通开发到技术组长，从技术组长到技术经理，从技术经理再到项目经理。\n\n工作内容也是越来越杂：\n\n*   **普通开发**时，只写客户端代码就可以。\n*   **负责技术**时，因为客户端嵌入了H5页面，客户端要调服务端的接口，所以我也学会了前端和后端的开发。实际工作中，你会发现，_你不了解一线的实际操作，你是心虚的_，你没法避免别人糊弄你，你也无法更公正地解决争端，所谓的什么“道理都是相通的”、“能管理好煤炭企业，也能管理好体育企业”这类管理理论，只是作为管理者懒政的借口。\n*   **负责项目**时，需要对产品原型、UI设计进行一个把握，需要对前期需求和后期售后进行一个兼顾，出个差，陪个酒也是常有的事情。有时候，哪里有空缺了，比如没有人设计原型，那么就要自己顶上去。\n\n整体下来，自己基本上达到**这么一种情况**：做一个互联网项目，从需求到上线，如果有更专业的人，那么能干的更快更好，如果只有自己，也能磕磕碰碰地完成。\n\n这种技能就是，要说没有本事吧，好像还能干不少事情。要说有本事呢，还真没有一样可以拿出手的绝活。\n\n但是，这不重要。\n\n我更关注的是，我供职的几家公司，包括身边的互联网公司，做产品也好，做平台也罢，**都没有实现盈利**。\n\n此处需要解释一下，我心中的盈利是指**传统的盈利**，就是通过销售的方式，产生了大于成本的收入，比如这软件花5块钱做的，卖了10块钱。\n\n我供职的公司，基本上都融过资，从百万到千万都有，都是拿着一份未来的规划，就有人投钱。\n\n没有实现盈利，却依然可以持续地生存下去，我认为这不是一种常态。\n\n看不到自己的作品实打实地变现，我是心虚的。\n\n十年互联网一场梦，看着一波又一波游走在风口的企业，虽然从没有耽误过我拿薪水，但是我却是担惊受怕的：\n\n*   这是泡沫吗？\n*   会破吗？\n*   哪一天会到来？\n*   我这10年的积累稳不稳定？\n\n### 二、裁员浪潮突袭来，转行意识在徘徊\n\n上半年，大家还在期待着加薪，没想到等到的是裁员。\n\n还好，我是项目负责人，因为平时工作表现还可以，所以不裁我。不但不裁我，还给我**升职加薪**。\n\n但是，我也面临了一个问题：你裁谁？\n\n我刚上任，哪里知道该裁谁，就这么推推搡搡，确定了一个名单。\n\n裁人那天早上，我推门去找总经理，我说我要辞职了，于是就出现了开头的那一幕。\n\n我走在街上，我觉得这是一个经过**反复思考后**的决定。\n\n可能很多人觉得，疫情期间，能有一份工作不就挺好吗？\n\n但是，我还考虑到了未来。\n\n三十多岁的人了，只考虑眼下的工作吗？问过自己要什么吗？\n\n```\n1、你处的行业怎么样？\n   教育行业，崩盘式堕落。\n2、行业不行，公司有发展也可以啊，你公司发展怎么样？\n   失去方向，驱逐人员。\n3、公司不佳，工作内容有前途也可以，你的工作有没有挑战？\n   重复性工作，得心应手。\n复制代码\n```\n\n好像只剩下钱了，但是这钱，**还能挣多久**，现在挣得心虚吗？\n\n不只是我这么想，我身边好多人都这么想。\n\n于是，戏剧性的一幕发生了。\n\n大家开始纷纷转行了，这个转行只是小转行，指的是IT行业内的工种转行。\n\n*   做前端开发的开始转行做后端开发。\n*   做后端开发的开始转行做项目管理。\n*   做项目管理的开始转行做产品管理。\n\n有时候我在想，这个问题是**转行就能破局**的吗？\n\n是跟整体_经济形势_有关呢，还是跟_个人职业匹配_有关呢，说不好，不好说，好像只能**试试看**了。\n\n其实，我也准备转行了，从项目管理转向**人工智能**开发。\n\n我从`2018`年开始，出于兴趣，就已经开始学习人工智能了，我认为写**逻辑代码的顶峰就是无逻辑**，那就是神经网络，就是人工智能。\n\n`4`年的学习，也有了一些实践和应用，也该宝刀出鞘了。\n\n### 三、出去面试吓一跳，行业经验很重要\n\n我先是奔着人工智能算法工程师去投简历，但是我的**简历太复杂**了，啥都干过，起初我还认为这是优势。\n\n直到碰到一个招聘主管点醒了我，她居然还是我的学姐，她说你把算法部分抽出来吧，_面试啥岗位就写啥经历_。\n\n我一想也对，以前自己也当过面试官，一般除非管理岗位，大公司都比较看重专业性，你招聘一个`Android`开发，结果简历上`80%`写的是`PHP`，这不合适。\n\n我把其他项目都删除了，只保留算法相关的应用案例，基本上都是应用在**教育教学**方面的。\n\n后来，面试机会真的多了。\n\n但是问题也来了，这些招聘的企业，有的是搞煤炭的，有的是搞养殖的，你与他们**很难对上话**。\n\n比如他们说一个“倒线”，你听不明白，他们都觉得很奇怪，这不是行业基础知识吗？他们认为你**应该明白**。\n\n再后来，我还是决定去**教育行业**试试，这一去不要紧，一发不可收拾，什么“`教材`”、“`章节`”、“`知识点`”、“`题库`”、“`资源`”、“`备授课`”，搞了多少年了，而且既全面又深度。\n\n最后，我还是选择了一家做**算法**的教育企业，这将作为我算法职业生涯的起点。\n\n你看，是否教育行业已经不重要了，重要的是算法这个职业，这就是除了钱之外，我们**另外追求的点**。\n\n### 四、人到中年再重启，空杯心态学到底\n\n这次我选择了做一名小职员，最最底层那种普通开发。\n\n原因是你选择了算法，那么以你在算法领域的资历，当不了管理。\n\n强行做，是会有问题的，所谓：**德不配位，必有灾殃**。\n\n而我也很坦然，做管理这么多年，沉下心来，踏踏实实学习一两年，不好吗？\n\n入职新公司这两个月，我感受到了从来没有过的舒适，没有了没完没了的**会议**，没有了上午说完中午就交的**方案**，也没有了深夜打来处理现场问题的**电话**，只有我深爱的算法_代码_。\n\n而且，通过实际的项目，也让我对算法有了更深的见解，这_两个月_的收获也远远超过之前的_两年_。\n\n挺好的，善于舍得就会有更多的收获。\n\n相信我通过几年的学习，再结合之前杂七杂八的经验，最终在人工智能产业方面可以做出一定的成绩，这也是我最新的规划。\n\n看见没有，**人一旦有了新的希望，就有了动力**。\n\n我有时候就在思考一个问题，那就是换一个赛道的意义。\n\n你在一个赛道里已经到了`8`分，换一个赛道再经过几年可能只到`7`分，换赛道究竟是_逃避_还是_提升_？\n\n这个真的不好说。\n\n但是有一点可以肯定，你在`8`分的赛道里已经没有斗志了，换一个赛道你会充满**求知欲**，重新赋予它新的**希望**，将以往的成功或者失败的经验全部用来**成就它**，猜测它应该不会很差吧。\n\n### 五、长江后浪推前浪，后浪有话对你讲\n\n虽然这是我的总结，但是我也希望对你多少有些影响，该唾弃的唾弃，值得借鉴的借鉴。\n\n对于职场新人，我想对你们说几句话：\n\n> 1、从基层到管理，从单一到复杂，这是在向上走，肯定是进步的，但同时也在越走越窄。\n\n不要觉得领导傻，尤其是大领导，你觉得一圈人都在骗他，他还不知道呢，就我知道。\n\n其实，有可能是**他在骗你们一圈人**。\n\n能向上走就向上走。\n\n古今中外，位置越高接触的信息就越多，决策也越正确，而这种正确不是你认为的正确。\n\n我之前带过一个项目，开发人员很烂，产品逻辑很烂，我认为应该先梳理人和事，大领导确不以为然。我考虑的是怎样做好，做不好其他的都无从谈起。但是大领导考虑的是平台有没有，某个时间点没有，可能都不用做了。\n\n但是，越往上路是越窄的。\n\n*   一个开发，可能有`5000`个合适的岗位。\n*   一个组长，可能有`3000`个合适的岗位。\n*   一个经理，可能只有`1000`个合适岗位。\n*   一个总监，可能只有`50`个岗位。\n*   一个总裁，可能找不到工作。\n\n> 2、搞管理并一定是你能力强，和信息差有关系，这种能力不一定能平移到其他公司。\n\n如果你当上了管理，也不要骄傲。\n\n这个角色可能并不是你能力强，可能就是没有人愿意干，也可能是你在这公司待得住，甚至可能仅仅就是老板看你**顺眼**。\n\n不管怎样，你既然在这个职位上了，你就会去开各种_会_，去参与各种_决策_，去描绘各种_规划_，这可能会让你产生一种自己优秀的错觉。\n\n这种优秀，换一个公司就会把你打回原形。\n\n**平台和能力**的故事，数不胜数。\n\n所以，如果你是个管理者，不要变成**行政管理**，那就变成了员工的服务员，每天就是喝茶看新闻，收收报表啊，鼓励鼓励信心啊，你以为没有你的**协调**就转不起来，其实那是假象，久而久之你就废了。\n\n一定要做**业务领导**，指导员工的行进路线，披荆斩棘，攻坚克难，培养人才，只有这样，你才能不管去哪里都能立起**一杆大旗**，这种**能力**只和**你**有关。\n\n> 3、民营企业，就是为了实现老板的个人想法，一个单位待得时间越久，你被定制化的就会越深。\n\n很遗憾，这可能很打击人。\n\n你不要谈什么行业规范，谈什么职业操守，起码在民营企业，真的就是为了实现老板的**个人想法**。\n\n**他出钱，你干活**，除了立马应验的坑，否则你不要去阻拦他、打断他、抵制他。\n\n第一，他会不高兴。第二，**你的判断未必对**。\n\n一个企业，老板是第一责任人，员工是第一背锅人。\n\n你想要在他这里发展，就要多和他站在统一战线上，但是站久了，也会让你忘了世界上还有别人。\n\n有些事，是相同的。但是，有些事是千差万别的。\n\n同一个行为，这个老板可能高度赞扬你，另一个老板就会极度批判你，对错很随机，这就是定制化人才。\n\n就像高速路的收费员，她干了`15`年，结果来了**ETC**，她失业了，她说：我只会收费，你撤了，我以后还怎么活啊，我可是连续`10`年被评为**优秀员工**的。\n\n你都按照领导说的做了，最终却导致你无路可走，这就是被**深度定制**。\n\n要防止被定制，就要多抬头看看，放眼行业，多思考你在**行业**中处于什么水平，而不是你在**单位**中处于什么地位。\n\n> 一个人的职业生涯，总会受到行业的影响，行业又会受时代影响，各种影响下，我们太渺小了。好好把握机会，不要虚度时光，你努力过，以后不会后悔。有时候鸡汤也挺好，起码让你充实，让这一天积极地度过，这是会提高成功概率的。','2022-06-17 15:54:00',0000000003,'代码人生',3),(0000000023,'Shopee年中晋升 -- 我是如何晋升高级工程师的','最近虾皮陆陆续续官宣了年中晋升名单，我非常荣幸入选了，除了头衔的变化，还会有可观的调薪和配股，是真的香啊，那么就在这里分享一下我的晋升心得。','最近虾皮陆陆续续官宣了年中晋升名单，我非常荣幸入选了，除了头衔的变化，还会有可观的调薪和配股，是真的香啊，那么就在这里分享一下我的晋升心得。\n\n## 加入shopee\n\n我2018年本科毕业，虽然是985的学校，但是由于工作头两年没有在互联网，因此头两年的技术积累可以忽略不计。终于有一天我出于对互联网的憧憬，准备了一下面试的八股文和梳理了一下工作经验，在2020年加入了shopee。\n\n刚刚来到虾皮的时候，身边的大家由于有比较丰富的项目经验，这给了我不小的压力，但是也成为了我的动力。那时候工作还是相对轻松的，于是我会在完成工作后主动再向leader要活，因此也给leader留下了不错的印象，我也借机熟悉了各个模块的业务。\n\n除了平时的工作，我偶尔会在下班后学习一些新的东西，并且借组内分享的机会把学到的东西分享给其他人，在2021年我分享的次数是组内最多的。\n\n由于组内的code review机制，我会主动去看其他人的代码，从中学习好的代码规范。此外我买了《代码简洁之道》，在业务代码中尝试去实践书里的理论。\n\n就这样，我顺利地在shopee度过了2020年\n\n## 成长\n\n其实主要的成长可以分为两部分：人际关系和个人技术。\n\n在人际关系方面，我和所有的同事都保持着紧密的合作，不管工作中遇到任何沟通上的问题，我都以对事不对人的原则来处理，从不因为工作上的冲突影响同事之间的关系。虽然这看似很微不足道，但是在虾皮是很重要的。因为虾皮的业务需求线很长，先是市场当地(如印尼)的业务第一线提出需求，然后交由新加坡审核，才会到中国这边的pm，中间兜兜转转沟通的成本是很高的，经常会遇到问题需要反复确认，这时候对沟通技巧的要求就很高了。\n\n其次我跟leader也保持着紧密的交流，平时吃饭遇到会坐一起，偶尔还会一起去健身房或者去做核酸。我个人和leader不卑不亢的相处对双方都更有好处，因为我自己可以得到职业生涯发展的建议，而我的leader也能更好帮助我，我坚信良好的上下级关系一定是平等互助的。\n\n技术方面，因为之前有过一些技术上的沉淀，并且在处理日常开发需求中表现的得心应手，我的leader会逐渐安排我去做一些核心的业务。随着工作难度的上升，感到吃力是不可避免的。这时候要能正确认知风险并且及时上报，认知风险是非常重要的一项能力，能让团队的人力安排更加的合理，也能保证团队okr的完成。\n\n那么如何能正确识别风险呢？首先我们接到需求后要能正确的拆解工作，并且估算工时，一旦进度小规模的落后了，我们可以通过加班、减少会议、交接值班等方式来追赶进度，如果进度大幅度落后，那么不要犹豫，向leader报风险吧。要知道，是人就会犯错，但是犯错后止损的能力也是非常重要的。\n\n非常幸运，，2021年得到了不错的绩效，算是为一年的工作画上圆满的句号。\n\n## 突破\n\n随着能力的提升和团队的演进，在工作中我逐渐从配角变成主角，我的能力得到越来越多人的认可，甚至新入职的高级工程师在遇到问题也会来问我，这都充分说明我的能力已经到达了高级工程师的水平，这时晋升只是迟早的事情了。\n\n在晋升的喜悦之余，压力也会变大，因为晋升后leader对我的期望更高了，想要拿到好的绩效就要比其他的高级工程师都要优秀才行，新的挑战也是非常严峻，但总的来说我会继续努力，毕竟30岁已经在眼前了(我上学比较晚)','2022-08-08 12:53:00',0000000004,'代码人生',5),(0000000024,'超越 Nginx！号称下一代 Web 服务器，用起来够优雅！','Nginx是一款非常流行的Web服务器，在Github上已有16K+Star，我们经常用它来做静态资源托管或反向代理。最近发现了一款全新的Web服务器Caddy，Star数超越Nginx，标星38K+Star。试用了一下Caddy，发现它使用起来比Nginx优雅多了，功能也很强大，推荐给大家！','\n![超越 Nginx！号称下一代 Web 服务器，用起来够优雅！](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec1b54e1328646b8aa270136f2745bc8~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n> Nginx是一款非常流行的Web服务器，在Github上已有`16K+Star`，我们经常用它来做静态资源托管或反向代理。最近发现了一款全新的Web服务器`Caddy`，Star数超越Nginx，标星`38K+Star`。试用了一下`Caddy`，发现它使用起来比Nginx优雅多了，功能也很强大，推荐给大家！\n\nSpringBoot实战电商项目mall（50k+star）地址：[github.com/macrozheng/…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmacrozheng%2Fmall \"https://github.com/macrozheng/mall\")\n\n## Caddy简介\n\nCaddy是一款功能强大，扩展性高的Web服务器，目前在Github上已有`38K+Star`。Caddy采用Go语言编写，可用于静态资源托管和反向代理。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22838fde048a4d78b89c3460d2b2169f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\nCaddy具有如下主要特性：\n\n*   对比Nginx复杂的配置，其独创的`Caddyfile`配置非常简单；\n*   可以通过其提供的`Admin API`实现动态修改配置；\n*   默认支持自动化HTTPS配置，能自动申请HTTPS证书并进行配置；\n*   能够扩展到数以万计的站点；\n*   可以在任意地方执行，没有额外的依赖；\n*   采用Go语言编写，内存安全更有保证。\n\n## 安装\n\n> 首先我们直接在CentOS 8上安装Caddy，使用DNF工具安装无疑是最简单的，Docker安装方式之后也会介绍。\n\n*   使用如下命令通过DNF工具安装Caddy，安装成功后Caddy会被注册成系统服务；\n\n```\ndnf install \'dnf-command(copr)\'\ndnf copr enable @caddy/caddy\ndnf install caddy\n复制代码\n```\n\n*   使用`systemctl status caddy`查看Caddy的状态，可以发现Caddy已被注册为系统服务，但是还没开启。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/775f0dce685d4d1c8aa8eb0df109f3bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n## 使用\n\n> 下面我们体验下Caddy的基本使用，对于Web服务器来说都是常用的操作，你准能用的上！\n\n### 基本使用\n\n> 首先我们来个Caddy的入门使用，让Caddy运行在`2015`端口上并返回`Hello, world!`。\n\n*   直接使用`caddy`命令将输出Caddy的常用命令，基本看介绍就知道如何使用了，标出来的是常用命令；\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c28921ef8f64ea5abd77950a8d70c7b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   使用`caddy start`命令可以让Caddy服务在后台运行；\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e09153414f2a402ca1375f1631e48900~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   Caddy默认使用JSON格式的配置文件，但由于JOSN格式配置书写比较麻烦，又提供了`Caddyfile`这种更加简洁的配置形式，使用如下命令能自动把`Caddyfile`转化为JSON配置；\n\n```\ncaddy adapter\n复制代码\n```\n\n*   我们可以先创建一个名称为`Caddyfile`的文件，文件内容如下，然后使用`caddy adapter`将它转换为JSON配置，再使用`caddy reload`使配置生效，该配置将监听`2015`端口，并返回`Hello, world!`；\n\n```\n:2015\n\nrespond \"Hello, world!\"\n复制代码\n```\n\n*   然后我们使用curl命令访问`localhost:2015`，将返回指定的信息；\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa84e360dde54de6a5fccce5a10a3716~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   当然我们还可以使用Caddy提供的`Admin API`来查看配置信息，使用如下命令即可；\n\n```\ncurl localhost:2019/config/\n复制代码\n```\n\n*   当前JSON配置如下，如果你直接使用JSON配置的话需要书写如下配置，使用`Caddyfile`确实方便很多！\n\n```\n{\n   \"apps\": {\n      \"http\": {\n         \"servers\": {\n            \"srv0\": {\n               \"listen\": [\":2015\"],\n               \"routes\": [{\n                  \"handle\": [{\n                     \"body\": \"Hello, world!\",\n                     \"handler\": \"static_response\"\n                  }]\n               }]\n            }\n         }\n      }\n   }\n}\n复制代码\n```\n\n### `Caddyfile`基本语法\n\n*   下面案例将使用`Caddyfile`来进行配置，我们有必要了解下它的语法，`Caddyfile`的具体语法规则如下。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/553713d0a8ae42c9ba0790c5d4b4744e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   介绍下上图中的关键字，有助于理解。\n\n| 关键字 | 解释 | 使用 |\n| --- | --- | --- |\n| Global options block | 服务器全局配置 | 可用于配置是否启用HTTPS和Admin API等 |\n| Snippet | 可以复用的配置片段 | 定义好后认可以通过`import`关键字引用 |\n| Site Block | 单个网站配置 | 通过`file_server`可以配置静态代理，通过`reverse_proxy`可以配置动态代理 |\n| Matcher definition | 匹配定义 | 默认情况下指令会产生全局影响，通过它可以指定影响范围 |\n| Comment | 注释 | 使用`#`符号开头 |\n| Site address | 网站地址 | 默认使用HTTPS，如需开启HTTP，需要指定`http://`开头 |\n| Directive | 指令 | 指令赋予了Caddy强大的功能 |\n\n### 反向代理\n\n> 反向代理就是当请求访问你的代理服务器时，代理服务器会对你的请求进行转发，可以转发到静态的资源路径上去，也可以转发到动态的服务接口上去。下面我们以对域名进行代理为例，来讲讲如何进行静态代理和动态代理。\n\n#### 静态代理\n\n> 静态代理就是将请求代理到不同的静态资源路径上去，这里我们将对`docs.macrozheng.com`的请求代理到我的文档项目中，对`mall.macrozheng.com`的请求代理到mall的前端项目中。\n\n*   首先我们修改下本机的host文件：\n\n```\n192.168.3.106 docs.macrozheng.com\n192.168.3.106 mall.macrozheng.com\n复制代码\n```\n\n*   然后将我们的文档项目和mall前端项目上传到Caddy的html目录中去，并进行解压操作：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbc0fc8b2eb2419e88e064fdd5163cd1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   修改`Caddyfile`文件，使用如下配置，修改完成后使用`caddy reload`命令刷新配置；\n\n```\nhttp://docs.macrozheng.com {\n        root * /mydata/caddy/html/docs\n        file_server browse\n}\n\nhttp://mall.macrozheng.com {\n        root * /mydata/caddy/html/mall\n        file_server browse\n}\n复制代码\n```\n\n*   如果你的`Caddyfile`文件格式不太合格的话，会出现如下警告，直接使用`caddy fmt --overwrite`格式化并重写配置即可解决；\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07beee1f10b348dca77a5ec3243ca6c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   通过`docs.macrozheng.com`即可访问部署好的文档项目了：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfcaba6179bc4a93b128b3d2e8566f75~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   通过`mall.macrozheng.com`即可访问到部署好的前端项目了。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccd81bea17624b84baf2449ce0ba5c99~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n#### 动态代理\n\n> 动态代理就是把代理服务器的请求转发到另一个服务上去，这里我们将把对`api.macrozheng.com`的请求代理到演示环境的API服务上去。\n\n*   首先我们修改下本机的host文件，添加如下规则：\n\n```\n192.168.3.106 api.macrozheng.com\n复制代码\n```\n\n*   修改`Caddyfile`文件，使用如下配置，修改完成后使用`caddy reload`命令刷新配置；\n\n```\nhttp://api.macrozheng.com {\n        reverse_proxy http://admin-api.macrozheng.com\n}\n复制代码\n```\n\n*   之后通过`api.macrozheng.com/swagger-ui.html`即可访问到`mall-admin`的API文档页面了。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78dc0351ec8b4afe8392da2c9c63433a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 文件压缩\n\n> 如果我们的服务器带宽比较低，网站访问速度会很慢，这时我们可以通过让Caddy开启Gzip压缩来提高网站的访问速度。这里我们以mall的前端项目为例来演示下它的提速效果。\n\n*   我们需要修改`Caddyfile`文件，使用`encode`指令开启Gzip压缩，修改完成后使用`caddy reload`命令刷新配置；\n\n```\nhttp://mall.macrozheng.com {\n        root * /mydata/caddy/html/mall\n        encode {\n            gzip\n        }\n        file_server browse\n}\n复制代码\n```\n\n*   有个比较大的JS文件压缩前是`1.7M`；\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f65fe32a88d40beac5ea356eb5e714e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   压缩后为`544K`，访问速度也有很大提示；\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c5781f981684a169b8c0db9a309daa8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   另外我们可以看下响应信息，如果有`Content-Encoding: gzip`这个响应头表明Gzip压缩已经启用了。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1794dfca3ecf4d4c99a9c6dabedb4732~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 地址重写\n\n> 有的时候我们的网站更换了域名，但还有用户在使用老的域名访问，这时可以通过Caddy的地址重写功能来让用户跳转到新的域名进行访问。\n\n*   我们需要修改`Caddyfile`文件，使用`redir`指令重写地址，修改完成后使用`caddy reload`命令刷新配置；\n\n```\nhttp://docs.macrozheng.com {\n        redir http://www.macrozheng.com\n}\n复制代码\n```\n\n*   此时访问旧域名`docs.macrozheng.com`会直接跳转到`www.macrozheng.com`去。\n\n### 按目录划分\n\n> 有时候我们需要使用同一个域名来访问不同的前端项目，这时候就需要通过子目录来区分前端项目了。\n\n*   比如说我们需要按以下路径来访问各个前端项目；\n\n```\nwww.macrozheng.com #访问文档项目\nwww.macrozheng.com/admin #访问后台项目\nwww.macrozheng.com/app #访问移动端项目\n复制代码\n```\n\n*   我们需要修改`Caddyfile`文件，使用`route`指令定义路由，修改完成后使用`caddy reload`命令刷新配置。\n\n```\nhttp://www.macrozheng.com {\n        route /admin/* {\n                uri strip_prefix /admin\n                file_server {\n                        root /mydata/caddy/html/admin\n                }\n        }\n        route /app/* {\n                uri strip_prefix /app\n                file_server {\n                        root /mydata/caddy/html/app\n                }\n        }\n        file_server * {\n                root /mydata/caddy/html/www\n        }\n}\n复制代码\n```\n\n### HTTPS\n\n> Caddy能自动支持HTTPS，无需手动配置证书，这就是之前我们在配置域名时需要使用`http://`开头的原因，要想使用Caddy默认的HTTPS功能，按如下步骤操作即可。\n\n*   首先我们需要修改域名的DNS解析，直接在购买域名的网站上设置即可，这里以`docs.macrozheng.com`域名为例；\n\n*   之后使用如下命令验证DNS解析记录是否正确，注意配置的服务器的`80`和`443`端口需要在外网能正常访问；\n\n\n```\ncurl \"https://cloudflare-dns.com/dns-query?name=docs.macrozheng.com&type=A\" \\\n  -H \"accept: application/dns-json\"\n复制代码\n```\n\n*   修改`Caddyfile`配置文件，进行如下配置；\n\n```\ndocs.macrozheng.com {\n        root * /mydata/caddy/html/docs\n        file_server browse\n}\n复制代码\n```\n\n*   然后使用`caddy run`命令启动Caddy服务器即可，是不是非常方便！\n\n```\ncaddy run\n复制代码\n```\n\n### Docker支持\n\n> 当然Caddy也是支持使用Docker进行安装使用的，其使用和直接在CentOS上安装基本一致。\n\n*   首先使用如下命令下载Caddy的Docker镜像；\n\n```\ndocker pull caddy\n复制代码\n```\n\n*   然后在`/mydata/caddy/`目录下创建`Caddyfile`配置文件，文件内容如下；\n\n```\nhttp://192.168.3.105:80\n\nrespond \"Hello, world!\"\n复制代码\n```\n\n*   之后使用如下命令启动caddy服务，这里将宿主机上的`Caddyfile`配置文件、Caddy的数据目录和网站目录挂载到了容器中；\n\n```\ndocker run -p 80:80 -p 443:443 --name caddy \\\n    -v /mydata/caddy/Caddyfile:/etc/caddy/Caddyfile \\\n    -v /mydata/caddy/data:/data \\\n    -v /mydata/caddy/html:/usr/share/caddy \\\n    -d caddy\n复制代码\n```\n\n*   之后使用`docker exec`进入caddy容器内部执行命令；\n\n```\ndocker exec -it caddy /bin/sh\n复制代码\n```\n\n*   输入Caddy命令即可操作，之后的操作就和我们直接在CentOS上安装一样了。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a2a161c0e3e4ccbbeee4fb441ac79fd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n## 总结\n\n今天体验了一把Caddy，其强大的指令功能，让我们无需多余的配置即可实现各种功能，使用起来确实非常优雅！尤其是其能自动配置实现HTTPS，非常不错！Nginx能实现的功能Caddy基本都能实现，大家可以对比下之前写的[Nginx使用教程](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F9VZi2suAlomu1IRGy-qdCA \"https://mp.weixin.qq.com/s/9VZi2suAlomu1IRGy-qdCA\") ，你就会发现使用Caddy来实现有多么优雅！\n\n如果你想了解更多SpringBoot实战技巧的话，可以试试这个带全套教程的实战项目（50K+Star）：[github.com/macrozheng/…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmacrozheng%2Fmall \"https://github.com/macrozheng/mall\")\n\n## 参考资料\n\n*   项目地址：[github.com/caddyserver…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcaddyserver%2Fcaddy \"https://github.com/caddyserver/caddy\")\n*   官方文档：[caddyserver.com/](https://link.juejin.cn?target=https%3A%2F%2Fcaddyserver.com%2F \"https://caddyserver.com/\")','2022-04-12 01:15:00',0000000005,'后端',10),(0000000025,'对接了个三方支付，给俺气的呀','我们的商城需要在日本上线去赚小日子过得不错的日本人的钱，所以支付是首要的。就找了一家做日本本地支付的公司做对接，公司名字当然不能说，打我也不说。','![对接了个三方支付，给俺气的呀](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72111a937e91479190259866e0dc4c11~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n携手创作，共同成长！这是我参与「掘金日新计划 · 8 月更文挑战」的第7天，[点击查看活动详情](https://juejin.cn/post/7123120819437322247 \"https://juejin.cn/post/7123120819437322247\")\n\n故事是这样的：\n\n我们的商城需要在日本上线去赚小日子过得不错的日本人的钱，所以**支付**是首要的。就找了一家做日本本地支付的公司做对接，公司名字当然不能说，打我也不说。\n\n第一天，很愉快，签了协议，给了开发文档。俺就准备开始撸代码了。\n\n### API文档\n\n这开发文档，打开**两秒钟**就自动挂掉了，我只能一次又一次的点击`Reload`。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/744dd78e2b7a4daf9ac058a42f3f7f69~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n后来实在受不了了，我趁着那两三秒钟显示的时间，**截图**对照着看。结果就是所有的字段**不能复制粘贴了，只能一个一个敲。**\n\n还是这个API文档，**必输字段**和**非必输字段**乱的一塌糊涂，哪些是必输纯靠试，有的必输字段调试的时候有问题，对面直接甩过来一句，要么不传了吧。听得我懵懵的。\n\n### 加密，验签\n\n然后到了加密，验签。竟然能只给了`node`的demo，咱对接的大部分是后端程序员吧,没事，咱自己写。比较坑的是**MD5加密完是大写**的字母，这三方公司**转小写**了，也没有提示，折腾了一会，测了一会也就通了，还好还好。\n\n### 场景支持\n\n在之后就是支付的一个场景了，日本是没有微信支付宝这样的便捷支付的，要么**信用卡**，要么**便利店支付**。\n\n> 稍微说下**便利店支付**，就是说，客户下完单之后，会给到一个**回执**，是**一串数字**，我们且称之为**支付码**，他们便利店有一个类似于ATM机的**柜员机**，去这个机子上凭借这串支付码打印出来一个**凭条**，然后拿着这个凭条去找便利店的店员，**现金支付**。\n\n就是这个场景，就是这个数字，三方它就给客户显示**一次**，就**一次**，点击支付的时候显示**一次**。要是客户不截图，那么不好意思，您就重新下单吧。而且这个支付码我们拿不到，这个跳转了他们的页面，也不发个邮件告知。这明显**没法用**啊，我们的订单过期时间三天，客户这三天啥时候想去便利店支付都行，可是这只显示一次太扯了。\n同样的请求再发一次显示的是**支付进行中**。这怎么玩，好说歹说他们排期开发了两周，把这个订单号重入解决了，就是说同一笔订单再次进入是可以看到那串支付码的。\n\n### 测试环境不能测\n\n最后，写完了，调通了，测一下支付，结果他们测试环境**不支持**日本的这个便利店支付**测试**，what? **测试环境不能测试**？那我这么久在干什么，让我们上线上测，我的代码在测试环境还没搞完，让我上生产，最后上了，没测通，对方的问题，当天下午就把代码给回滚了。等着对方调试完继续测。\n\n### 业务不完整\n\n还有，**不支持退款**，作为一个支付公司，不支持退款，我们客户退款只能**线下转账**，闹呢。\n\n以前对接三方的时候，遇到问题地想到的是我们是不是哪里做错了，再看看文档。对接这个公司，就跟他们公司的测试一样，找bug呢。\n\n## 建议\n\n这里是本文的重点，咱就是给点建议，作为一家提供服务的公司，不管是啥服务。\n\n1.  对外API文档应当可以正常显示，必输非必输定义正确，字段类型标注准确。\n2.  若是有验签的步骤，介绍步骤详细并配上各个语言的demo，并强调格式以及大小写。\n3.  牵扯到业务的，需要站在客户的角度思考，这个是否合情合理。\n4.  业务的完整性，有可能是尚未开发完全，但是得有备选的方案。','2022-08-03 16:51:00',0000000006,'后端',5),(0000000026,'后端接口性能差，该从哪些方面进行优化？','作为一个后端开发工程师，我们大部分时间都是在开发业务接口，作为一个资深开发，我们不仅仅是要保证能用就行，更重要的是要保证接口的性能。那么如果接口慢，我们应该从哪些方面对接口进行优化呢？','**前言**\n\n作为一个后端开发工程师，我们大部分时间都是在开发业务接口，作为一个资深开发，我们不仅仅是要保证能用就行，更重要的是要保证接口的性能。那么如果接口慢，我们应该从哪些方面对接口进行优化呢？\n\n**一：善于使用异步编程**\n\n1.  利用多线程实现异步\n\n比较推荐的方式是自定义TreadPool来实现多线程，在Java 8以及8以上的版本，我们也可以使用CompletableFuture来实现异步编程。\n\n注：如果你对线程池还有所疑问，可以看我的另一篇文章，相信会对你有所帮助。 [线程池原理分析](https://juejin.cn/post/7046789499182907406 \"https://juejin.cn/post/7046789499182907406\")\n\n2.  使用mq中间件实现异步\n\n现在市面上比较流行的分布式消息中间件有rocketmMq，rabbitMq，kafka等，在Springboot的环境中引入相关的消息中间件也比较简单，这里就不再赘述了。\n\n**二：数据量大的时候使用批量与分批操作**\n\n1.在查询数据库的时候我们要尽量避免在for循环中操作数据库，尽量使用批量处理来对数据库进行操作。在Mybatis中我们可以使用批量处理器来对数据库进行操作，MybatisPlus甚至为我们封装好了批量处理的API。\n\n2.避免在for循环中进行rpc调用，尽量使用批量查询。\n\n3.如果操作的数据量很大，那么我们可以进行分批处理，这样可以避免一次交互的数据量过大，从而导致接口响应过慢。\n\n**三：避免大事务**\n\n**大事务会带来什么危害？**\n\n1.并发情况下，数据库连接池容易被撑爆\n\n2.锁定太多的数据，造成大量的阻塞和锁超时\n\n3.执行时间长，容易造成主从延迟\n\n4.回滚所需要的时间比较长\n\n**如何解决大事务问题？**\n\n尽量少使用`@Transactional`注解，虽然它真的很方便，但是声明式事务很难控制好事务的粒度，推荐使用编程式事务来帮助我们更好的控制事务的粒度。Spring给我们提供了`TransactionTemplate`来帮助我们实现编程式事务。\n\nTransactionTemplate的简单使用：\n\n```\n @Resource\n private TransactionTemplate transactionTemplate;\n\n    @Test\n    public void test1(){\n        transactionTemplate.execute(action->{\n            //执行数据库事务操作\n            return null;\n        });\n    }\n复制代码\n```\n\n**四：优化sql慢查询**\n\n**导致慢查询的原因**\n\n1.关键的字段缺少索引\n\n我们可以根据Explain分析慢SQL，如果没有建立索引的话，创建索引即可。\n\n2.有索引，但是却没有用上索引\n\n我们通过Explain分析慢SQL，发现没有使用到索引，但是发现已经创建了索引，那么这种情况就是索引失效了。\n\n这里我举例一些索引失效的一些场景：\n\n①.字段类型不匹配\n\n②.索引列使用了函数\n\n③.like使用了左模糊\n\n④.使用了联合索引，但是却不满足最左匹配原则\n\n索引失效的原因还有很多，这里就不一一列出来了\n\n3.SQL比较复杂，很慢，但是不好优化\n\n如果你的SQL比较复杂，那么建议利用Java代码逻辑来实现对应的逻辑，我们毕竟不是SQL开发，而是后端Java开发，复杂的SQL不仅可能导致慢查询，也不利用后期代码的维护工作。\n\n4.数据表数据很多\n\n①：如果旧数据用户访问的比较少，我们可以对数据进行冷热分离\n\n②：对数据进行分库分表\n\n如果表的数据量已经很大了，那么我们可能就需要进行分库分表的处理了。我们可以使用ShardingJDBC，Mycat等成熟的中间件或者代理来帮助我们完成大数据表的分库分表。\n\n**五：善于利用缓存**\n\n对于并发比较高的系统，缓存是非常有必要的。我们可以将一些查询较多，但是修改不频繁的数据放入到缓存中，这样可以帮助我们减少对数据库的访问。这样不仅可以减轻数据库的压力，而且接口的响应速度也可以得到很大的提升。\n\n**使用Redis作分布式缓存**\n\n通常我们会利用Redis作为分布式缓存中间件，但是在使用Redis的时候，我们对key的设计要合理，不然出现Big Key，很有可能影响到我们接口的响应速度。\n\n**使用Caffeine作为本地缓存**\n\n很多时候我们不仅仅会利用Redis做分布式缓存，同时我们也会做一个本地缓存，减轻redis的压力。这里我以caffeine为例，当然还有很多本地缓存的实现，我这里就不一一介绍了.\n\n注：我们生产上的服务都是部署多台机器的，那么当数据修改时，我们如何让本地缓存失效呢？我的一个思路是可以通过Redis的事件发布机制，只要我们所有的服务都订阅Redis的某个事件，一旦数据进行了改动，那么就发布事件，所有订阅了相关事件的服务就可以接收到消息并将对应的缓存删除。另外如果数据的实时性要求不高，我们甚至可以不用删除缓存，只需要过期时间设置短一点即可（例如5s,10s）。\n\n**六：控制好锁的粒度**\n\n在并发场景下，很多时候我们都需要使用到锁来帮助我们保证数据的安全性，包括像数据的幂等性处理都需要用到锁。但是如果不管我们使用Sysnchrnoized关键字，jdk的lock锁，还是分布式锁，我们都需要控制好锁的粒度，如果锁的粒度很大，显然会影响到我们系统的吞吐量。\n\n**最后**\n\n如果你的接口性能比较差，不妨尝试按照以上几点进行优化吧，如果有任何疑问，欢迎在下方评论区留言。最后，原创不易，如果本文对你有所帮助，那么点个赞再走吧。','2022-07-26 01:53:00',0000000007,'后端',11),(0000000027,'这个队列的思路是真的好，现在它是我简历上的亮点了。','前几天在一个开源项目的 github 里面看到这样的一个 pr：','![这个队列的思路是真的好，现在它是我简历上的亮点了。](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/251304a98bcb42eb8e240816ca271e08~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n你好呀，我是歪歪。\n\n前几天在一个开源项目的 github 里面看到这样的一个 pr：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6279dbd5b3e84765af92f8baa26ec7a1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n光是看这个名字，里面有个 MemorySafe，我就有点陷进去了。\n\n我先给你看看这个东西：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb1bc72308041388039175bacb40624~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n这个肯定很眼熟吧？我是从阿里巴巴开发规范中截的图。\n\n为什么不建议使用 FixedThreadPool 和 SingleThreadPool 呢？\n\n因为队列太长了，请求会堆积，请求一堆积，容易造成 OOM。\n\n那么问题又来了：前面提到的线程池用的队列是什么队列呢？\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ab79f730e844b46887a493a403250e3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n用的是没有指定长度的 LinkedBlockingQueue。\n\n没有指定长度，默认长度是 Integer.MAX\\_VALUE，可以理解为无界队列了：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fe301df5bc546a9b001bf3dea391562~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n所以，在我的认知里面，使用 LinkedBlockingQueue 是可能会导致 OOM 的。\n\n如果想避免这个 OOM 就需要在初始化的时候指定一个合理的值。\n\n“合理的值”，听起来轻描淡写的四个字，但是这个值到底是多少呢，你说的准吗？\n\n基本上说不准。\n\n所以，当我看到 pr 上的 MemorySafeLinkedBlockingQueue 这个名字的时候，我就陷进去了。\n\n在 LinkedBlockingQueue 前面加上了 MemorySafe 这个限定词。\n\n表示这是一个内存安全的 LinkedBlockingQueue。\n\n于是，我想要研究一下到底是怎么样来实现“安全”的，所以啪的一下就点进去了，很快啊。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/352ca52f5cff48cf946449fb87561739~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n## MemorySafeLBQ\n\n在这个 pr 里面我们看一下它主要是想干个什么事儿：\n\n> [github.com/apache/dubb…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fapache%2Fdubbo%2Fpull%2F10021 \"https://github.com/apache/dubbo/pull/10021\")\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09608cf194c34dba80d4cd13f0f5ba88~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n提供代码的哥们是这样描述它的功能的：\n\n> 可以完全解决因为 LinkedBlockingQueue 造成的 OOM 问题，而且不依赖 instrumentation，比 MemoryLimitedLinkedBlockingQueue 更好用。\n\n然后可以看到这次提交涉及到 7 个文件。\n\n实际上真正核心的代码是这两个：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e56be282d5449fea9f529eac297bd60~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n但是不要慌，先眼熟一下这两个类，然后我先按下不表。先追根溯源，从源头上讲。\n\n这两个类的名字太长了，所以先约定一下，在本文中，**我用 MemoryLimitedLBQ 来代替 MemoryLimitedLinkedBlockingQueue。用 MemorySafeLBQ 来代替 MemorySafeLinkedBlockingQueue。**\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/509ed895e1e1498c875e239e4f73877b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n可以看到，在 pr 里面它还提到了“比 MemoryLimitedLBQ 更好用”。\n\n也就是说，它是用来替代 MemoryLimitedLBQ 这个类的。\n\n这个类从命名上也看得出来，也是一个 LinkedBlockingQueue，但是它的限定词是 MemoryLimited，可以限制内存的。\n\n我找了一下，这个类对应的 pr 是这个：\n\n> [github.com/apache/dubb…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fapache%2Fdubbo%2Fpull%2F9722 \"https://github.com/apache/dubbo/pull/9722\")\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b72a5c1415d4815adfa5042734951e7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n在这个 pr 里面，有大佬问他：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e73a04c5a6574a318333a0c08b9020ed~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n你这个新队列实现的意义或目的是什么？你能不能说出当前版本库中需要被这个队列取代的队列？这样我们才好决定是否使用这个队列。\n\n也就是说他只是提交了一个新的队列，但是并没有说到应用场景是什么，导致官方不知道该不该接受这个 pr。\n\n于是，他补充了一个回复：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61bc824ad9bf4a2a98435a283a8a3ad8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n就是拿的 FixedThreadPool 做的示例。\n\n在这个里面，就使用了无参的 LinkedBlockingQueue，所以会有 OOM 的风险。\n\n那么就可以使用 MemoryLimitedLBQ 来代替这个队列。\n\n比如，我可以限制这个队列可以使用的最大内存为 100M，通过限制内存的方式来达到避免 OOM 的目的。\n\n好，到这里我先给你梳理一下。\n\n首先应该是有一个叫 MemoryLimitedLBQ 的队列，它可以限制这个队列最大可以占用的内存。\n\n然后，由于某些原因，又出现了一个叫做 MemorySafeLBQ 的队列，宣称比它更好用，所以来取代它。\n\n所以，接下来我就要梳理清楚三个问题：\n\n*   MemoryLimitedLBQ 的实现原理是什么？\n*   MemorySafeLBQ 的实现原理是什么？\n*   MemorySafeLBQ 为什么比 MemoryLimitedLBQ 更好用？\n\n## MemoryLimitedLBQ\n\n别看这个玩意我是在 Dubbo 的 pr 里面看到的，但是它本质上是一个队列的实现方式。\n\n所以，完全可以脱离于框架而存在。\n\n也就是说，你打开下面这个链接，然后直接把相关的两个类粘出来，就可以跑起来，为你所用：\n\n> [github.com/apache/dubb…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fapache%2Fdubbo%2Fpull%2F9722%2Ffiles \"https://github.com/apache/dubbo/pull/9722/files\")\n\n我先给你看看 MemoryLimitedLBQ 这个类，它就是继承自 LinkedBlockingQueue，然后重写了它的几个核心方法。\n\n只是自定义了一个 memoryLimiter 的对象，然后每个核心方法里面都操作了 memoryLimiter 对象：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70e36f9c76a64e239af273a3099b9a77~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n所以真正的秘密就藏在 memoryLimiter 对象里面。\n\n比如，我带你看看这个 put 方法：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a27abcd9aca480f96fb873c84a4e1e8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n这里面调用了 memoryLimiter 对象的 acquireInterruptibly 方法。\n\n在解读 acquireInterruptibly 方法之前，我们先关注一下它的几个成员变量：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26c2eef8ae584cd6a3d05275b979411b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   memoryLimit 就是表示这个队列最大所能容纳的大小。\n*   memory 是 LongAdder 类型，表示的是当前已经使用的大小。\n*   acquireLock、notLimited、releaseLock、notEmpty 是锁相关的参数，从名字上可以知道，往队列里面放元素和释放队列里面的元素都需要获取对应的锁。\n*   inst 这个参数是 Instrumentation 类型的。\n\n前面几个参数至少我还很眼熟的，但是这个 inst 就有点奇怪了。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39a45ca5e04c4f63ac56a384c9fccd4f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n这玩意日常开发中基本上用不上，但是用好了，这就是个黑科技了。很多工具都是基于这个玩意来实现的，比如大名鼎鼎的 Arthas。\n\n它可以更加方便的做字节码增强操作，允许我们对已经加载甚至还没有被加载的类进行修改的操作，实现类似于性能监控的功能。\n\n可以说 Instrumentation 就是 memoryLimiter 的关键点：\n\n比如在 memoryLimiter 的 acquireInterruptibly 方法里面，它是这样的用的：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73442fd1385141d183487e4d4608bdae~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n看方法名称你也知道了，get 这个 object 的 size，这个 object 就是方法的入参，也就是要放入到队列里面的元素。\n\n为了证明我没有乱说，我带你看看这个方法上的注释：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9785d401fa0d4275833ca6cb8ddc4a31~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n> an implementation-specific approximation of the amount of storage consumed by the specified object\n\n注意这个单词：approximation.\n\n这可是正儿八经的四级词汇，还是 a 开头的，你要是不眼熟的话可是要挨板子的。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e547a335c6f4689893930b70acddebd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n整句话翻译过来就是：返回指定对象所消耗的存储量的一个特定实现的近似值。\n\n再说的直白点就是你传进来的这个对象，在内存里面到底占用了多长的长度，这个长度不是一个非常精确的值。\n\n所以，理解了 inst.getObjectSize(e) 这行代码，我们再仔细看看 acquireInterruptibly 是怎么样的：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1635a5151c324bfdbdb67b9aa28d5129~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n首先，两个标号为 ① 的地方，表示操作这个方法是要上锁的，整个 try 里面的方法是线程安全的。\n\n然后标号为 ② 的里面干了什么事儿？\n\n就是计算 memory 这个 LongAdder 类型的 sum 值加上当前这个对象的值之后，是不是大于或者等于 memoryLimit。\n\n如果计算后的值真的超过了 memoryLimit，那么说明需要阻塞一下下了，调用 notLimited.await() 方法。\n\n如果没有超过 memoryLimit，说明还能往队列里面放东西，那么就更新 memory 的值。\n\n接着到了标号为 ③ 的地方。\n\n来到这里，再次判断一下当前已经使用的值是否没有超过 memoryLimit，如果是的话，就调用 notLimited.signal() 方法，唤醒一下之前由于 memoryLimit 参数限制导致不能放入的对象。\n\n整个逻辑非常的清晰。\n\n而整个逻辑里面的核心逻辑就是调用 Instrumentation 类型的 getObjectSize 方法获得当前放入对象的一个 size，并判断当前已经使用的值加上这个 size 之后，是否大于了我们设置的最大值。\n\n所以，你用脚趾头猜也能猜到了，在 release 方法里面，肯定也是计算当前对象的 size，然后再从 memory 里面减出去：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a96229d26a584434a804d565b0f832ac~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n说穿了，也就这么屁大点事儿。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b32ce3caf70748b79d599d4010dd23e8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n然后，你再次审视一下这个 acquireInterruptibly 方法的 try 代码块里面的逻辑，你有没有发现什么 BUG：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/953e3853ca4d4c6ea330547bc43ea2a1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n如果你没反映过来，那我再提个醒：你认真的分析一下 sum 这个局部变量是不是有点不妥？\n\n你要是还没反应过来，那我直接给你上个代码。后面有一次提交，是把 sum 修改为了 memory.sum() ：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4455ae4cf771455fb28b547a0ca8a671~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n为什么这样改呢？\n\n我给你说个场景，假设我们的 memoryLimit 是 1000，当前已经使用的 memory 是 800，也就是 sum 是 800。这个时候我要放的元素计算出来的 size 是 300，也就是 objectSize 是 300。\n\nsum+objectSize=1100，比 memoryLimit 的值大，是不是在这个 while 判断的时候被拦截住了：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1480e30aab094bb5bcc23ebd964d4b45~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n之后，假设队列里面又释放了一个 size 为 600 的对象。\n\n这个时候执行 memory.add(-objectSize) 方法，memory 变为 200：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a57d2eb4b1c49509cbc41d36681fa9a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n那么会调用 signalNotLimited 方法，唤醒这个被拦截的这个哥们：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ed427fe312c42aca897d4d6445281f3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n这个哥们一被唤醒，一看代码：\n\n```\nwhile (sum + objectSize >= memoryLimit) {\n    notLimited.await();\n}\n复制代码\n```\n\n心里想：我这里的 sum 是 800，objectSize 是 300，还是大于 memoryLimit 啊，把我唤醒干啥玩意，傻逼吗？\n\n那么你说，它骂的是谁？\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de63b5c8f7a947debd400e581c9e96d7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n这个地方的代码肯定得这样，每次都查看最新的 memory 值才行：\n\n```\nwhile (memory.sum() + objectSize >= memoryLimit) {\n    notLimited.await();\n}\n复制代码\n```\n\n所以，这个地方是个 BUG，还是个死循环的 BUG。\n\n前面代码截图中还出现了一个链接，就是说的这个 BUG：\n\n> [github.com/apache/incu…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fapache%2Fincubator-shenyu%2Fpull%2F3335 \"https://github.com/apache/incubator-shenyu/pull/3335\")\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85aef720c2534593af4376965ca2f335~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n另外，你可以看到链接中的项目名称是 incubator-shenyu，这是一个开源的 API 网关：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afc1b166a93b419cb0add5bb9d6af3d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n**本文中的 MemoryLimitedLBQ 和 MemorySafeLBQ 最先都是出自这个开源项目。**\n\n## MemorySafeLBQ\n\n前面了解了 MemoryLimitedLBQ 的基本原理。\n\n接下来我带你看看 MemorySafeLBQ 这个玩意。\n\n它的源码可以通过这个链接直接获取到：\n\n> [github.com/apache/dubb…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fapache%2Fdubbo%2Fpull%2F10021%2Ffiles \"https://github.com/apache/dubbo/pull/10021/files\")\n\n也是拿出来就可以放到自己的项目跑，把文件作者修改为自己的名字的那种。\n\n让我们回到最开始的地方：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75b1f90173a144b09ba51e0f5da3cb7c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n这个 pr 里面说了，我搞 MemorySafeLBQ 出来，就是为了替代 MemoryLimitedLBQ 的，因为我比它好用，而且我还不依赖于 Instrumentation。\n\n但是看了源码之后，会发现其实思路都是差不多的。只不过 MemorySafeLBQ 属于是反其道而行之。\n\n怎么个“反其道”法呢？\n\n看一下源码：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22054ac70d6340699892654f36a98741~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\nMemorySafeLBQ 还是继承自 LinkedBlockingQueue，只是多了一个自定义的成员变量，叫做 maxFreeMemory，初始值是 256 \\* 1024 \\* 1024。\n\n这个变量的名字就非常值得注意，你再细细品品。maxFreeMemory，最大的剩余内存，默认是 256M。\n\n前面一节讲的 MemoryLimitedLBQ 限制的是这个队列最多能使用多少空间，是站在队列的角度。\n\n而 MemorySafeLBQ 限制的是 JVM 里面的剩余空间。比如默认就是当整个 JVM 只剩下 256M 可用内存的时候，再往队列里面加元素我就不让你加了。\n\n因为整个内存都比较吃紧了，队列就不能无限制的继续添加了，从这个角度来规避了 OOM 的风险。\n\n这样的一个反其道而行之。\n\n另外，它说它不依赖 Instrumentation 了，那么它怎么检测内存的使用情况呢？\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b3278d3b9964af7a118f8e6498ebeb4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n使用的是 ManagementFactory 里面的 MemoryMXBean。\n\n这个 MemoryMXBean 其实你一点也不陌生。\n\nJConsole 你用过吧？\n\n下面这个界面进去过吧？\n\n这些信息就是从 ManagementFactory 里面拿出来的：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c870a43094640718e14fa78145d808d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n所以，确实它没有使用 Instrumentation，但是它使用了 ManagementFactory。\n\n目的都是为了获取内存的运行状态。\n\n那么怎么看出来它比 MemoryLimitedLBQ 更好用呢？\n\n我看了，关键方法就是这个 hasRemainedMemory，在调用 put、offer 方法之前就要先调用这个方法：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dba4a200da744b1db885abd8c3aca24f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n而且你看 MemorySafeLBQ 只是重写了放入元素的 put、offer 方法，并不关注移除元素。\n\n为什么呢？\n\n因为它的设计理念是只关心添加元素时候的剩余空间大小，它甚至都不会去关注当前这个元素的大小。\n\n而还记得前面讲的 MemoryLimitedLBQ 吗？它里面还计算了每个元素的大小，然后搞了一个变量来累加。\n\nMemoryLimitedLBQ 的 hasRemainedMemory 方法里面也只有一行代码，其中 maxFreeMemory 是类初始化的时候就指定好了。那么关键的代码就是 MemoryLimitCalculator.maxAvailable()。\n\n所以我们看看 MemoryLimitCalculator 的源码。\n\n这个类的源码写的非常的简单，我全部截完都只有这么一点内容，全部加起来也就是 20 多行代码：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7aa5b9eb62c4d48aaf5211f708fe90f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n而整个方法的核心就是我框起来的 static 代码块，里面一共有三行代码。\n\n第一行是调用 refresh 方法，也就是对 maxAvilable 这个参数进行重新赋值，这个参数代表的意思是当前还可以使用的 JVM 内存。\n\n第二行是注入了一个每 50ms 运行一次的定时任务。到点了，就触发一下 refresh 方法，保证 maxAvilable 参数的准实时性。\n\n第三行是加入了 JVM 的 ShutdownHook，停服务的时候需要把这个定时任务给停了，达到优雅停机的目的。\n\n核心逻辑就这么点。\n\n从我的角度来说，确实是比 MemoryLimitedLBQ 使用起来更简单，更好用。\n\n最后，再看看作者提供的 MemorySafeLBQ 测试用例，我补充了一点注释，很好理解，自己去品，不再多说：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/265c15bad445461397de4ee0de05984a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n## 它是你的了\n\n文章里面提到的 MemoryLimitedLBQ 和 MemorySafeLBQ，我说了，这两个玩意是完全独立于框架的，代码直接粘过来就可以用。\n\n代码也没几行，不管是用 Instrumentation 还是 ManagementFactory，核心思想都是限制内存。\n\n思路扩展一下，比如我们有的项目里面用 Map 来做本地缓存，就会放很多元素进去，也会有 OOM 的风险，那么通过前面说的思路，是不是就找到了一个问题的解决方案？\n\n所以，思路是很重要的，掌握到了这个思路，面试的时候也能多掰扯几句嘛。\n\n再比如，我看到这个玩意的时候，联想到了之前写过的线程池参数动态调整。\n\n就拿 MemorySafeLBQ 这个队列来说，它里面的 maxFreeMemory 这个参数，可不可以做成动态调整的？\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d99047d858040fdb0737e21c0fad300~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n不外乎就是把之前的队列长度可调整修改为了队列占用的内存空间可调整。一个参数的变化而已，实现方案可以直接套用。\n\n这些都是我从开源项目里面看到的，但是在我看到的那一刻，它就是我的。\n\n现在，我把它写出来，分享给你，它就是你的了。\n\n不客气，来个三连就行。','2022-06-06 03:47:00',0000000008,'后端',8),(0000000029,'Java定时任务技术趋势','定时任务是每个业务常见的需求，比如每分钟扫描超时支付的订单，每小时清理一次数据库历史数据，每天统计前一天的数据并生成报表等等。','![Java 定时任务技术趋势](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52bbbe203f484f99a8e870dd0efb3893~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n定时任务是每个业务常见的需求，比如每分钟扫描超时支付的订单，每小时清理一次数据库历史数据，每天统计前一天的数据并生成报表等等。\n\n**01**\n\nJava 中自带的解决方案\n\nCloud Native\n\n1\n\n使用 Timer\n\n创建 java.util.TimerTask 任务，在 run 方法中实现业务逻辑。通过 java.util.Timer 进行调度，支持按照固定频率执行。所有的 TimerTask 是在同一个线程中串行执行，相互影响。也就是说，对于同一个 Timer 里的多个 TimerTask 任务，如果一个 TimerTask 任务在执行中，其它 TimerTask 即使到达执行的时间，也只能排队等待。如果有异常产生，线程将退出，整个定时任务就失败。\n\n```\nimport java.util.Timer;\nimport java.util.TimerTask;\n\npublic class TestTimerTask {\n\n\n    public static void main(String[] args) {\n        TimerTask timerTask = new TimerTask() {\n            @Override\n            public void run() {\n                System.out.println(\"hell world\");\n            }\n        };\n        Timer timer = new Timer();\n        timer.schedule(timerTask, 10, 3000);\n    }\n\n\n}\n复制代码\n```\n\n2\n\n使用 ScheduledExecutorService\n\n基于线程池设计的定时任务解决方案，每个调度任务都会分配到线程池中的一个线程去执行，解决 Timer 定时器无法并发执行的问题，支持 fixedRate 和 fixedDelay。\n\n```\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class TestTimerTask {\n\n\n    public static void main(String[] args) {\n        ScheduledExecutorService ses = Executors.newScheduledThreadPool(5);\n        //按照固定频率执行，每隔5秒跑一次\n        ses.scheduleAtFixedRate(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"hello fixedRate\");\n            }\n        }, 0, 5, TimeUnit.SECONDS);\n\n\n        //按照固定延时执行，上次执行完后隔3秒再跑\n        ses.scheduleWithFixedDelay(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"hello fixedDelay\");\n            }\n        }, 0, 3, TimeUnit.SECONDS);\n    }\n\n\n}\n复制代码\n```\n\n**02**\n\nSpring 中自带的解决方案\n\nCloud Native\n\nSpringboot 中提供了一套轻量级的定时任务工具 Spring Task，通过注解可以很方便的配置，支持 cron 表达式、fixedRate、fixedDelay。\n\n```\nimport org.springframework.scheduling.annotation.EnableScheduling;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\n@Component\n@EnableScheduling\npublic class MyTask {\n\n\n    /**\n     * 每分钟的第30秒跑一次\n     */\n    @Scheduled(cron = \"30 * * * * ?\")\n    public void task1() throws InterruptedException {\n        System.out.println(\"hello cron\");\n    }\n\n\n    /**\n     * 每隔5秒跑一次\n     */\n    @Scheduled(fixedRate = 5000)\n    public void task2() throws InterruptedException {\n        System.out.println(\"hello fixedRate\");\n    }\n\n\n    /**\n     * 上次跑完隔3秒再跑\n     */\n    @Scheduled(fixedDelay = 3000)\n    public void task3() throws InterruptedException {\n        System.out.println(\"hello fixedDelay\");\n    }\n\n\n}\n复制代码\n```\n\nSpring Task 相对于上面提到的两种解决方案，最大的优势就是支持 cron 表达式，可以处理按照标准时间固定周期执行的业务，比如每天几点几分执行。\n\n**03**\n\n业务幂等解决方案\n\nCloud Native\n\n现在的应用基本都是分布式部署，所有机器的代码都是一样的，前面介绍的 Java 和 Spring 自带的解决方案，都是进程级别的，每台机器在同一时间点都会执行定时任务。这样会导致需要业务幂等的定时任务业务有问题，比如每月定时给用户推送消息，就会推送多次。\n\n于是，很多应用很自然的就想到了使用分布式锁的解决方案。即每次定时任务执行之前，先去抢锁，抢到锁的执行任务，抢不到锁的不执行。怎么抢锁，又是五花八门，比如使用 DB、zookeeper、redis。\n\n1\n\n使用 DB 或者 Zookeeper 抢锁\n\n使用 DB 或者 Zookeeper 抢锁的架构差不多，原理如下：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7e60c68031648e28450bf57b529f19f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n1.  定时时间到了，在回调方法里，先去抢锁。\n2.  抢到锁，则继续执行方法，没抢到锁直接返回。\n3.  执行完方法后，释放锁。\n\n示例代码如下：\n\n```\nimport org.springframework.scheduling.annotation.EnableScheduling;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\n@Component\n@EnableScheduling\npublic class MyTask {\n    /**\n     * 每分钟的第30秒跑一次\n     */\n    @Scheduled(cron = \"30 * * * * ?\")\n    public void task1() throws Exception {\n        String lockName = \"task1\";\n        if (tryLock(lockName)) {\n            System.out.println(\"hello cron\");\n            releaseLock(lockName);\n        } else {\n            return;\n        }\n    }\n\n\n    private boolean tryLock(String lockName) {\n        //TODO\n        return true;\n    }\n\n\n    private void releaseLock(String lockName) {\n        //TODO\n    }\n\n\n}\n复制代码\n```\n\n当前的这个设计，仔细一点的同学可以发现，其实还是有可能导致任务重复执行的。比如任务执行的非常快，A 这台机器抢到锁，执行完任务后很快就释放锁了。B 这台机器后抢锁，还是会抢到锁，再执行一遍任务。\n\n2\n\n使用 redis 抢锁\n\n使用 redis 抢锁，其实架构上和 DB/zookeeper 差不多，不过 redis 抢锁支持过期时间，不用主动去释放锁，并且可以充分利用这个过期时间，解决任务执行过快释放锁导致任务重复执行的问题，架构如下：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2caaaf3e5d9492b8d3d7c46211d918b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n示例代码如下：\n\n```\n@Component\n@EnableScheduling\npublic class MyTask {\n    /**\n     * 每分钟的第30秒跑一次\n     */\n    @Scheduled(cron = \"30 * * * * ?\")\n    public void task1() throws InterruptedException {\n        String lockName = \"task1\";\n        if (tryLock(lockName, 30)) {\n            System.out.println(\"hello cron\");\n            releaseLock(lockName);\n        } else {\n            return;\n        }\n    }\n\n\n    private boolean tryLock(String lockName, long expiredTime) {\n        //TODO\n        return true;\n    }\n\n\n    private void releaseLock(String lockName) {\n        //TODO\n    }\n\n\n}\n复制代码\n```\n\n看到这里，可能又会有同学有问题，加一个过期时间是不是还是不够严谨，还是有可能任务重复执行？\n\n——的确是的，如果有一台机器突然长时间的 fullgc，或者之前的任务还没处理完（Spring Task 和 ScheduledExecutorService 本质还是通过线程池处理任务），还是有可能隔了 30 秒再去调度任务的。\n\n3\n\n使用 Quartz\n\nQuartz  **\\[**  **1\\]**   是一套轻量级的任务调度框架，只需要定义了 Job（任务），Trigger（触发器）和 Scheduler（调度器），即可实现一个定时调度能力。支持基于数据库的集群模式，可以做到任务幂等执行。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4ac8983c85741acaa5df47da5c57051~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\nQuartz 支持任务幂等执行，其实理论上还是抢 DB 锁，我们看下 quartz 的表结构：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/579296b3f6424e1c8806befd61732aaa~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n其中，QRTZ\\_LOCKS 就是 Quartz 集群实现同步机制的行锁表，其表结构如下：\n\n```\n--QRTZ_LOCKS表结构\nCREATE TABLE `QRTZ_LOCKS` (\n  `LOCK_NAME` varchar(40) NOT NULL,\n  PRIMARY KEY (`LOCK_NAME`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n--QRTZ_LOCKS记录\n+-----------------+\n| LOCK_NAME       |\n+-----------------+\n| CALENDAR_ACCESS |\n| JOB_ACCESS      |\n| MISFIRE_ACCESS  |\n| STATE_ACCESS    |\n| TRIGGER_ACCESS  |\n+-----------------+\n复制代码\n```\n\n可以看出 QRTZ\\_LOCKS 中有 5 条记录，代表 5 把锁，分别用于实现多个 Quartz Node 对 Job、Trigger、Calendar 访问的同步控制。\n\n**04**\n\n开源任务调度中间件\n\nCloud Native\n\n上面提到的解决方案，在架构上都有一个问题，那就是每次调度都需要抢锁，特别是使用 DB 和 Zookeeper 抢锁，性能会比较差，一旦任务量增加到一定的量，就会有比较明显的调度延时。还有一个痛点，就是业务想要修改调度配置，或者增加一个任务，得修改代码重新发布应用。\n\n于是开源社区涌现了一堆任务调度中间件，通过任务调度系统进行任务的创建、修改和调度，这其中国内最火的就是 XXL-JOB 和 ElasticJob。\n\n1\n\nElasticJob\n\nElasticJob  **\\[**  **2\\]**   是一款基于 Quartz 开发，依赖 Zookeeper 作为注册中心、轻量级、无中心化的分布式任务调度框架，目前已经通过 Apache 开源。\n\nElasticJob 相对于 Quartz 来说，从功能上最大的区别就是支持分片，可以将一个任务分片参数分发给不同的机器执行。架构上最大的区别就是使用 Zookeeper 作为注册中心，不同的任务分配给不同的节点调度，不需要抢锁触发，性能上比 Quartz 上强大很多，架构图如下：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acc44d1fdf7d4d0f99510889f33e8ae3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n开发上也比较简单，和 springboot 结合比较好，可以在配置文件定义任务如下：\n\n```\nelasticjob:\n  regCenter:\n    serverLists: localhost:2181\n    namespace: elasticjob-lite-springboot\n  jobs:\n    simpleJob:\n      elasticJobClass: org.apache.shardingsphere.elasticjob.lite.example.job.SpringBootSimpleJob\n      cron: 0/5 * * * * ?\n      timeZone: GMT+08:00\n      shardingTotalCount: 3\n      shardingItemParameters: 0=Beijing,1=Shanghai,2=Guangzhou\n    scriptJob:\n      elasticJobType: SCRIPT\n      cron: 0/10 * * * * ?\n      shardingTotalCount: 3\n      props:\n        script.command.line: \"echo SCRIPT Job: \"\n    manualScriptJob:\n      elasticJobType: SCRIPT\n      jobBootstrapBeanName: manualScriptJobBean\n      shardingTotalCount: 9\n      props:\n        script.command.line: \"echo Manual SCRIPT Job: \"\n复制代码\n```\n\n实现任务接口如下：\n\n```\n@Component\npublic class SpringBootShardingJob implements SimpleJob {\n\n\n    @Override\n    public void execute(ShardingContext context) {\n        System.out.println(\"分片总数=\"+context.getShardingTotalCount() + \", 分片号=\"+context.getShardingItem()\n            + \", 分片参数=\"+context.getShardingParameter());\n    }\n\n\n}\n复制代码\n```\n\n运行结果如下：\n\n```\n分片总数=3, 分片号=0, 分片参数=Beijing\n分片总数=3, 分片号=1, 分片参数=Shanghai\n分片总数=3, 分片号=2, 分片参数=Guangzhou\n复制代码\n```\n\n同时，ElasticJob 还提供了一个简单的 UI，可以查看任务的列表，同时支持修改、触发、停止、生效、失效操作。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53ff6105e00e439984d1e7b903a31e50~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n遗憾的是，ElasticJob 暂不支持动态创建任务。\n\n2\n\nXXL-JOB\n\nXXL-JOB  **\\[**  **3\\]**  是一个开箱即用的轻量级分布式任务调度系统，其核心设计目标是开发迅速、学习简单、轻量级、易扩展，在开源社区广泛流行。\n\nXXL-JOB 是 Master-Slave 架构，Master 负责任务的调度，Slave 负责任务的执行，架构图如下：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d2167c49c554d9bb0a2bf5dcfd41413~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\nXXL-JOB 接入也很方便，不同于 ElasticJob 定义任务实现类，是通过@XxlJob 注解定义 JobHandler。\n\n```\n@Component\npublic class SampleXxlJob {\n    private static Logger logger = LoggerFactory.getLogger(SampleXxlJob.class);\n\n\n\n\n    /**\n     * 1、简单任务示例（Bean模式）\n     */\n    @XxlJob(\"demoJobHandler\")\n    public ReturnT<String> demoJobHandler(String param) throws Exception {\n        XxlJobLogger.log(\"XXL-JOB, Hello World.\");\n\n\n        for (int i = 0; i < 5; i++) {\n            XxlJobLogger.log(\"beat at:\" + i);\n            TimeUnit.SECONDS.sleep(2);\n        }\n        return ReturnT.SUCCESS;\n    }\n\n\n\n\n    /**\n     * 2、分片广播任务\n     */\n    @XxlJob(\"shardingJobHandler\")\n    public ReturnT<String> shardingJobHandler(String param) throws Exception {\n\n\n        // 分片参数\n        ShardingUtil.ShardingVO shardingVO = ShardingUtil.getShardingVo();\n        XxlJobLogger.log(\"分片参数：当前分片序号 = {}, 总分片数 = {}\", shardingVO.getIndex(), shardingVO.getTotal());\n\n\n        // 业务逻辑\n        for (int i = 0; i < shardingVO.getTotal(); i++) {\n            if (i == shardingVO.getIndex()) {\n                XxlJobLogger.log(\"第 {} 片, 命中分片开始处理\", i);\n            } else {\n                XxlJobLogger.log(\"第 {} 片, 忽略\", i);\n            }\n        }\n\n\n        return ReturnT.SUCCESS;\n    }\n}\n复制代码\n```\n\nXXL-JOB 相较于 ElasticJob，最大的特点就是功能比较丰富，可运维能力比较强，不但支持控制台动态创建任务，还有调度日志、运行报表等功能。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82fac6afb00d41fc9c3c0623671a2720~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bf450ce61d143729d07573403886e64~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\nXXL-JOB 的历史记录、运行报表和调度日志，都是基于数据库实现的：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74371da10ba149249d0e7ce051a69241~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n由此可以看出，XXL-JOB 所有功能都依赖数据库，且调度中心不支持分布式架构，在任务量和调度量比较大的情况下，会有性能瓶颈。不过如果对任务量级、高可用、监控报警、可视化等没有过高要求的话，XXL-JOB 基本可以满足定时任务的需求。\n\n**05**\n\n企业级解决方案\n\nCloud Native\n\n开源软件只能提供基础的调度能力，在监管控上的能力一般都比较弱。比如日志服务，业界往往使用 ELK 解决方案；短信报警，需要有短信平台；监控大盘，现在主流的解决方案是 Prometheus；等等。企业想要有这些能力，不但需要额外的开发成本，还需要昂贵的资源成本。\n\n另外使用开源软件也伴随着稳定性的风险，就是出了问题没人能处理，想要反馈到社区等社区处理，这个链路太长了，早就产生故障了。\n\n阿里云任务调度 SchedulerX  **\\[**  **4\\]**  是阿里巴巴自研的基于 Akka 架构的一站式任务调度平台，兼容开源 XXL-JOB、ElasticJob、Quartz（规划中），支持 Cron 定时、一次性任务、任务编排、分布式跑批，具有高可用、可视化、可运维、低延时等能力，自带企业级监控大盘、日志服务、短信报警等服务。\n\n1\n\n优势\n\n### 安全防护\n\n*   多层次安全防护：支持 HTTPS 和 VPC 访问，同时还有阿里云的多层安全防护，防止恶意攻击。\n*   多租户隔离机制：支持多地域、命名空间和应用级别的隔离。\n*   权限管控：支持控制台读写的权限管理，客户端接入的鉴权。\n\n### 企业级高可用\n\nSchedulerX2.0 采用高可用架构，任务多备份机制，经历阿里集团多年双十一、容灾演练，可以做到任意一个机房挂了，任务调度都不会收到影响。\n\n### 商业级报警运维\n\n*   报警：支持邮件、钉钉、短信、电话，（其他报警方式在规划中）。支持任务失败、超时、无可用机器报警。报警内容可以直接看出任务失败的原因，以钉钉机器人为例。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26eb0073e9e6446aaf14788185a724ba~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   运维操作：原地重跑、重刷数据、标记成功、查看堆栈、停止任务、指定机器等。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a959c133f4014dbe8a4a922ee5f0c352~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 丰富的可视化\n\nschedulerx 拥有丰富的可视化能力，比如：\n\n*   用户大盘\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fea5d3c871e14528898a1f24bb6a1b7a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   查看任务历史执行记录\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdf5def7e22a44ab8e3516c309e6743f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   查看任务运行日志\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/038748cd08834f99919dc0c8adb80241~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   查看任务运行堆栈\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc2ea0307bef4da4af49f8e272133263~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   查看任务操作记录\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dbc506c15a3419d886257cba97c7708~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 兼容开源\n\nSchedulerx 兼容开源 XXL-JOB、ElasticJob、Quartz（规划中），业务不需要改一行代码，即可以将任务托管在 SchedulerX 调度平台，享有企业级可视化和报警的能力。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/707667d68d564dc5bc4afbe590ac651c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### Spring 原生\n\nSchedulerX 支持通过控制台和 API 动态创建任务，也支持 Spring 声明式任务定义，一份任务配置可以拿到任何环境一键启动，配置如下：\n\n```\nspring:\n   schedulerx2:\n      endpoint: acm.aliyun.com   #请填写不同regin的endpoint\n      namespace: 433d8b23-06e9-xxxx-xxxx-90d4d1b9a4af #region内全局唯一，建议使用UUID生成\n      namespaceName: 学仁测试\n      appName: myTest\n      groupId: myTest.group      #同一个命名空间下需要唯一\n      appKey: myTest123@alibaba  #应用的key，不要太简单，注意保管好\n      regionId: public           #填写对应的regionId\n      aliyunAccessKey: xxxxxxx   #阿里云账号的ak\n      aliyunSecretKey: xxxxxxx   #阿里云账号的sk\n      alarmChannel: sms,ding     #报警通道：短信和钉钉\n      jobs:\n         simpleJob:\n            jobModel: standalone\n            className: com.aliyun.schedulerx.example.processor.SimpleJob\n            cron: 0/30 * * * * ?   # cron表达式\n            jobParameter: hello\n            overwrite: true\n         shardingJob:\n            jobModel: sharding\n            className: ccom.aliyun.schedulerx.example.processor.ShardingJob\n            oneTime: 2022-06-02 12:00:00   # 一次性任务表达式\n            jobParameter: 0=Beijing,1=Shanghai,2=Guangzhou\n            overwrite: true\n         broadcastJob:   # 不填写cron和oneTime，表示api任务\n            jobModel: broadcast\n            className: com.aliyun.schedulerx.example.processor.BroadcastJob\n            jobParameter: hello\n            overwrite: true\n         mapReduceJob:\n            jobModel: mapreduce\n            className: com.aliyun.schedulerx.example.processor.MapReduceJob\n            cron: 0 * * * * ?\n            jobParameter: 100\n            overwrite: true\n      alarmUsers:     #报警联系人\n         user1:\n            userName: 张三\n            userPhone: 12345678900\n         user2:\n            userName: 李四\n            ding: https://oapi.dingtalk.com/robot/send?access_token=xxxxx\n复制代码\n```\n\n### 分布式跑批\n\nSchedulerX 提供了丰富的分布式模型，可以处理各种各样的分布式业务场景。包括单机、广播、分片、 MapReduce  **\\[**  **5\\]**  等，架构如下：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64824cd4746f4332972b72dc39fec165~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\nSchedulerX 的 MapReduce 模型，简单几行代码，就可以将海量任务分布式到多台机器跑批，相对于大数据跑批来说，具有速度快、数据安全、成本低、简单易学等特点。\n\n### 任务编排\n\nSchedulerX 通过工作流进行任务编排，并且提供了一个可视化的界面，操作简单，拖拖拽拽即可配置一个工作流。详细的任务状态图能一目了然看到下游任务为什么没跑，方便定位问题。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f6cb7be1a9b42c29038a220dcded80a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 可抢占的任务优先级队列\n\n常见场景是夜间离线报表业务，比如很多报表任务是晚上 1、2 点开始跑，要控制应用最大并发的任务数量（否则业务扛不住），达到并发上限的任务会在队列中等待。同时要求早上 9 点前必须把 KPI 报表跑出来，可以设置 KPI 任务高优先级，会抢占低优先级任务优先调度。\n\nSchedulerX 支持可抢占的任务优先级队列，可以在控制台动态配置：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d7bd4c6ecc14b11aa462862e6a49fc5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n2\n\nQ&A\n\n1.  Kubernetes 应用可以接入 SchedulerX 吗？\n\n——可以的，无论是物理机、容器、还是 Kubernetes pod，都可以接入 SchedulerX。\n\n2.  我的应用不在阿里云上，可否使用 SchedulerX？\n\n——可以的，任何云平台或者本地机器，只要能访问公网，都可以接入 SchedulerX。','2022-08-03 07:39:00',0000000009,'后端',44),(0000000030,'10 款更先进的开源命令行工具','也许是审美疲劳又或是好奇心作祟，你可曾好奇过：“这么多年过去了，开源世界里有没有可以替代这些“老态龙钟”的 Linux 命令，或者是更加好用的命令行工具呢？”','![10 款更先进的开源命令行工具](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e172f162bf54e4589e2c665ba80648e~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\nLinux 诞生于 1991 年，我们熟知的 `ls`、`cd`、`ps` 等命令也出生于那个年代。虽然它们都是 30 年前的产物，但是我们现在依旧每天都在用这些命令。\n\n也许是审美疲劳又或是好奇心作祟，你可曾好奇过：“**这么多年过去了，开源世界里有没有可以替代这些“老态龙钟”的 Linux 命令，或者是更加好用的命令行工具呢？**”\n\n今天 HelloGitHub 就整理了 10 款开源命令行工具，这些开源项目不仅实现了 和 Linux 命令相同的功能，而且它们与时俱进地加入更多新功能，从而在使用方式、性能和展示效果上更胜一筹，比如：更加人性化的参数设计、一目了然的展示效果、支持跨平台等。所以我称它们为：**更先进的命令行工具！**\n\n下面就让我们一同走进这些让人相见恨晚、爱不释手的开源命令行工具吧。\n\n为阅读起来更加直观，我把标题设定成了 `编号：项目名（可替代的命令）`\n\n## 1：dust（du）\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36c42d5e298f4f129cff627eefaa9f47~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   编程语言：Rust（96%）\n*   Star 数：4.4k\n*   可替代：`du` 命令\n*   介绍：能够一目了然地展示目录和文件大小的命令行工具。使用时无需加额外的参数，即可展示当前目录下的文件和目录的大小、包含的子目录列表（树状）以及占用空间的百分比（条形图）。\n*   用法：`dust`\n*   适用平台：Windows、Linux、macOS\n*   地址：[github.com/bootandy/du…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbootandy%2Fdust \"https://github.com/bootandy/dust\")\n\n## 2：duf（df）\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4549dd0089f94111b38d142d58edc553~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   编程语言：Go（94%）\n*   Star 数：9.3k\n*   可替代：`df` 命令\n*   介绍：通过彩色表格的方式展示磁盘使用情况的工具。不仅对设备进行了分类，还支持结果排序。\n*   用法：`duf`\n*   适用平台：Windows、Linux、macOS\n*   地址：[github.com/muesli/duf](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmuesli%2Fduf \"https://github.com/muesli/duf\")\n\n## 3：procs（ps）\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66eb7ab519454b18a3abfb08c8d5516a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   编程语言：Rust（99%）\n*   Star 数：3k\n*   可替代：`ps` 命令\n*   介绍：能够展示进程占用的 TCP/UDP 端口、Docker 容器名称等更多信息的命令行进程管理工具，以及轻松地按列排序和关键字过滤进程。\n*   用法：`procs 待过滤的关键字`\n*   适用平台：Linux、macOS 和 Windows 上存在一些问题\n*   地址：[github.com/dalance/pro…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdalance%2Fprocs \"https://github.com/dalance/procs\")\n\n## 4：bottom（top）\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb08fdfdfa9c462282bc95139da2d0e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   编程语言：Rust（99%）\n*   Star 数：4.4k\n*   可替代：`top` 命令\n*   介绍：图形化实时监控进程和系统资源的工具。支持实时展示 CPU、内存、硬盘、网络、进程、温度等指标，而且还可通过插件扩展可视化效果，相较于其它同类型的开源项目，该项目更加活跃。\n*   用法：`btm`\n*   适用平台：Windows、Linux、macOS\n*   地址：[github.com/ClementTsan…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FClementTsang%2Fbottom \"https://github.com/ClementTsang/bottom\")\n\n## 5：exa（ls）\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e4e1623ffeb4c6bb3073f1bf37a45f4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   编程语言：Rust（92%）\n*   Star 数：18.4k\n*   可替代：`ls` 命令\n*   介绍：更加人性化地显示目录下文件的工具。它通过不同颜色展示来区别文件类型，还支持以树状的方式展示文件层级、展示 Git 状态等方便的功能。\n*   用法：`exa -l`\n*   适用平台：Linux、macOS\n*   地址：[github.com/ogham/exa](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fogham%2Fexa \"https://github.com/ogham/exa\")\n\n## 6：zoxide（cd）\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa2ee230a3d24d928462ed673e580c10~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   编程语言：Rust（98%）\n*   Star 数：6.9k\n*   可替代：`cd` 命令\n*   介绍：更聪明的 `cd` 命令。能够记住你最常使用的目录，从而让目录跳转更加方便和快捷。\n*   用法：`z 目录`\n*   适用平台：Windows、Linux、macOS\n*   地址：[github.com/ajeetdsouza…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fajeetdsouza%2Fzoxide \"https://github.com/ajeetdsouza/zoxide\")\n\n## 7：ripgrep（grep）\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0040b23a68949a3a789924fdf4ae413~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   编程语言：Rust（94%）\n*   Star 数：45.6k\n*   可替代：`grep` 命令\n*   介绍：超快的文本搜索工具。不仅快还更加人性化，比如自动忽略 .gitignore 中的文件、自动递归搜索、自动高亮展示匹配的结果。\n*   用法：`rg \'关键字\' 目录`\n*   适用平台：Windows、Linux、macOS\n*   地址：[github.com/BurntSushi/…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FBurntSushi%2Fripgrep \"https://github.com/BurntSushi/ripgrep\")\n\n另外，HelloGitHub 之前还发过[一篇文章](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzA5MzYyNzQ0MQ%3D%3D%26mid%3D2247512232%26idx%3D1%26sn%3D355246e5c81365e7f88036458ae508d1%26chksm%3D905805f6a72f8ce0eef571bb14338b36bb32de2be9de529928aec7a52dbe790c0590f1e49c27%26token%3D441186140%26lang%3Dzh_CN%23rd \"https://mp.weixin.qq.com/s?__biz=MzA5MzYyNzQ0MQ==&mid=2247512232&idx=1&sn=355246e5c81365e7f88036458ae508d1&chksm=905805f6a72f8ce0eef571bb14338b36bb32de2be9de529928aec7a52dbe790c0590f1e49c27&token=441186140&lang=zh_CN#rd\")，详细介绍了搜索文件的开源项目：fd（find）的使用方法。\n\n## 8：bat（cat）\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ed7d990291a4b1593f1422e5fe90d4b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   编程语言：Rust（95%）\n*   Star 数：35.6k\n*   可替代：`cat` 命令\n*   介绍：默认就带自动翻页、行号、语法高亮、Git 集成等功能的升级版文件查看工具。\n*   用法：`bat 文件名`\n*   适用平台：Windows、Linux、macOS\n*   地址：[github.com/sharkdp/bat](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsharkdp%2Fbat \"https://github.com/sharkdp/bat\")\n\n## 9：httpie（curl）\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/460051ee30fb4153a2b5e9ee1e164ae8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   编程语言：Python（92%）\n*   Star 数：22.4k\n*   可替代：`curl` 和 `wget` 命令\n*   介绍：全能但不臃肿的命令行 HTTP 客户端。使用起来极其方便，支持请求、会话、下载、JSON 等功能。该项目经历了 Star 清零的事件（误操作），这才不到一年的时间，现在已经拥有超过 2 万的 Star 啦！\n*   用法：`http/https 地址`\n*   适用平台：Windows、Linux、macOS\n*   地址：[github.com/httpie/http…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fhttpie%2Fhttpie \"https://github.com/httpie/httpie\")\n\n## 10：hyperfine（time）\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14a4598cd1b5430c86493eb22ad46ef8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   编程语言：Rust（93%）\n*   Star 数：11.9k\n*   可替代：`time` 命令\n*   介绍：强大的命令行基准测试工具。支持任意 shell 命令、多次运行的统计分析和结果导出。\n*   用法：`hyperfine \'命令1\' \'命令2\'`\n*   适用平台：Windows、Linux、macOS\n*   地址：[github.com/sharkdp/hyp…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsharkdp%2Fhyperfine \"https://github.com/sharkdp/hyperfine\")\n\n## 最后\n\n时代在发展，技术在进步。**没有永久先进的工具，只有青出于蓝、更加好用的利器。**\n\n由于篇幅问题，本文只列举了 10 款可替代 Linux 命令的开源项目。如果想了解更多此类项目，这还有个开源项目：[modern-unix](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fibraheemdev%2Fmodern-unix \"https://github.com/ibraheemdev/modern-unix\") 它包含了 28 个常用的 Linux 命令的替代品。\n\n最后，如果本文分享的开源项目有帮助到你，**请记给它们点一个 Star，开源不易多行善举。**','2022-07-13 00:51:00',0000000010,'开发工具',5),(0000000031,'让MacBook成为生产力｜软件推荐｜环境配置','当拿到新mac，心情是喜悦同时又是复杂的，因为我的旧Mac陪我度过了很久，从本科到研究生，系统里面装了很多我自己已经不太记得的资源库，比如java、pyhton、c++、qt、opencv、openni、vtk、pcl、深度学习框架等等，导致旧mac已经足足有占用了400多G的空间。','![让MacBook成为生产力｜软件推荐｜环境配置](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c595a7cbf2734883a7f3aa37639a6ab5~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n# 引言\n\n当拿到新mac，心情是喜悦同时又是复杂的，因为我的旧Mac陪我度过了很久，从本科到研究生，系统里面装了很多我自己已经不太记得的资源库，比如java、pyhton、c++、qt、opencv、openni、vtk、pcl、深度学习框架等等，导致旧mac已经足足有占用了400多G的空间。\n\n因此，我并不打算使用迁移助手直接把旧mac的东西再搬过来，毕竟自己对mac也有足够的了解了，我需要新的开始。（这话怎么这么像渣男......我不是）特此记录一下，希望对你也有帮助。\n\n本文会持续更新的，建议收藏～\n\n# 装机必备\n\n先来安装一些通用的软件，日常操作使用比较频繁的～\n\n## 世界之窗——ClashX\n\n要和全世界优秀的程序员交流，访问Github、Google是程序员必备的技能之一，我用的是ClashX的代理。这里就不记录怎么用了。\n\n另一个比较好的推荐就是网易UU加速器，这个是免费的，访问Github、谷歌学术等网站是没有问题的。\n\n## 网上冲浪——Chrome\n\n为什么mac用户不用Safari？当然Safari很好用，但是我经常需要使用window系统，比如在实验室的主机上，所以之前做了一个决定，统一使用Chrome管理我存的书签。\n\n下载地址：[www.google.com/chrome/](https://link.juejin.cn?target=https%3A%2F%2Fwww.google.com%2Fchrome%2F \"https://www.google.com/chrome/\")\n\n## 压缩解压——MacZip\n\nMacZip（原名eZip）是一款支持压缩包内文件预览的全能型 Mac 解压缩应用。支持 rar, zip, 7z, tar, gz, bz2, iso, xz, lzma, apk, lz4 等超过 20 种常见压缩格式。完美处理加密解密、中文乱码等问题！批量文件加密，永久免费！\n\n下载地址：[ezip.awehunt.com/](https://link.juejin.cn?target=https%3A%2F%2Fezip.awehunt.com%2F \"https://ezip.awehunt.com/\")\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4dc6e4a6685c45d78552142afc95f044~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n## 办公套件——Office、WPS\n\n推荐大家使用WPS，真的好用，而且云盘很方便，支持国产！\n\n但是，唯一的痛点就是，每当写论文需要mathtype来编辑公式的时候，必须要回到Microsoft word。 对科研工作者不太友好。\n\n这里分享一个office安装包，天翼云盘下载，不限速但是需要下载客户端，[cloud.189.cn/t/zIzMJvmem…](https://link.juejin.cn?target=https%3A%2F%2Fcloud.189.cn%2Ft%2FzIzMJvmemEBf%25EF%25BC%2588%25E8%25AE%25BF%25E9%2597%25AE%25E7%25A0%2581%25EF%25BC%259Aap4b%25EF%25BC%2589 \"https://cloud.189.cn/t/zIzMJvmemEBf%EF%BC%88%E8%AE%BF%E9%97%AE%E7%A0%81%EF%BC%9Aap4b%EF%BC%89\")\n\n不得不说，云盘厂商基本都是一个套路，刚开始免费不限速，用户量上来了就开始会员制了。阿里云盘已经开始收费了。。。\n\n## markdown 笔记——typora\n\nTypora 是一款简洁的markdown编辑器、写作软件。它去除了预览窗口，模式切换器，语法符号以及所有其他不必要的干扰。将它们替换为真实的实时预览功能，以帮助您专注于内容本身。[cloud.189.cn/t/yYB36zr2a…](https://link.juejin.cn?target=https%3A%2F%2Fcloud.189.cn%2Ft%2FyYB36zr2aiAj%25EF%25BC%2588%25E8%25AE%25BF%25E9%2597%25AE%25E7%25A0%2581%25EF%25BC%259Aicf3%25EF%25BC%2589 \"https://cloud.189.cn/t/yYB36zr2aiAj%EF%BC%88%E8%AE%BF%E9%97%AE%E7%A0%81%EF%BC%9Aicf3%EF%BC%89\")\n\n我一般是配合github来做同步，之前也用过notion，手机电脑能够实时同步，但是还是感觉typora更简洁易用。\n\n## 截图录制编辑——Snagit\n\nTechSmith Snagit 2021 中文版是mac平台上功能最强大的屏幕截图屏幕录制软件，可让您在Mac上捕获屏幕截图、录制屏幕视频。支持滚动截图 (长截图)、网页截图、录制系统声音、录制麦克风、录制摄像头等功能。snagit 2021 内置独家的高级截图编辑器能够轻松创建高质量的截图，GIF动画和视频。截图软件有的功能 snagit 2021 基本都有，没有的它还有，使用流畅，功能强大，推荐大家使用！\n\n这里分享一个下载链接：[cloud.189.cn/t/677Jvm36z…](https://link.juejin.cn?target=https%3A%2F%2Fcloud.189.cn%2Ft%2F677Jvm36ziQj%25EF%25BC%2588%25E8%25AE%25BF%25E9%2597%25AE%25E7%25A0%2581%25EF%25BC%259Axvs1%25EF%25BC%2589 \"https://cloud.189.cn/t/677Jvm36ziQj%EF%BC%88%E8%AE%BF%E9%97%AE%E7%A0%81%EF%BC%9Axvs1%EF%BC%89\")\n\n## 媒体播放——IINA\n\nIINA 是一款采用现代设计和流线型功能的在线mac视频播放器，可以观看视频，管理播放列表，处理媒体内容或为电影加载字幕提等等。IINA mac可以加载本地文件或提供视频URL，IINA mac可以使用所有流行的媒体格式。而且可以快速更改界面主题，调整默认行为和用户界面，决定是否要自动加载字幕，配置新的键绑定等。\n\n这是一款 Github 开源应用。下载地址：[github.com/iina/iina/r…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fiina%2Fiina%2Freleases \"https://github.com/iina/iina/releases\")\n\n## 视频下载\n\nDownie for Mac 是一款Mac OS平台上最好用的Mac视频下载工具，Downie for mac 支持1000多个不同的视频网站视频下载，功能强大使用简单。\n\n下载链接：[cloud.189.cn/t/ru6neifEB…](https://link.juejin.cn?target=https%3A%2F%2Fcloud.189.cn%2Ft%2Fru6neifEBZVr%25EF%25BC%2588%25E8%25AE%25BF%25E9%2597%25AE%25E7%25A0%2581%25EF%25BC%259A2gu8%25EF%25BC%2589 \"https://cloud.189.cn/t/ru6neifEBZVr%EF%BC%88%E8%AE%BF%E9%97%AE%E7%A0%81%EF%BC%9A2gu8%EF%BC%89\")\n\n## 图像处理\n\nAdobe Photoshop 2022 是一款专业强大的图片处理工具，设计师必备工具，这个无需多做介绍了吧。[cloud.189.cn/t/iAZjqyB7Z…](https://link.juejin.cn?target=https%3A%2F%2Fcloud.189.cn%2Ft%2FiAZjqyB7ZVvm%25EF%25BC%2588%25E8%25AE%25BF%25E9%2597%25AE%25E7%25A0%2581%25EF%25BC%259Auef9%25EF%25BC%2589 \"https://cloud.189.cn/t/iAZjqyB7ZVvm%EF%BC%88%E8%AE%BF%E9%97%AE%E7%A0%81%EF%BC%9Auef9%EF%BC%89\")\n\nPixelmator Pro 是一款任何人都可以使用的专业图像编辑工具。Pixelmator Pro旨在使每个人都可以使用最强大的专业图像编辑工具。拥有大量用于编辑和修饰照片，创建图形设计，绘画，绘制矢量图形以及添加令人惊叹的效果的工具，这是一款可以替代Photoshop的图像编辑器。[cloud.189.cn/t/FRZ7raJFV…](https://link.juejin.cn?target=https%3A%2F%2Fcloud.189.cn%2Ft%2FFRZ7raJFVFFn%25EF%25BC%2588%25E8%25AE%25BF%25E9%2597%25AE%25E7%25A0%2581%25EF%25BC%259Ahv7d%25EF%25BC%2589 \"https://cloud.189.cn/t/FRZ7raJFVFFn%EF%BC%88%E8%AE%BF%E9%97%AE%E7%A0%81%EF%BC%9Ahv7d%EF%BC%89\")\n\n## 视频工具——VideoProc\n\nVideoProc Converter 4K 是 Mac 平台上的一款集视频编辑、视频格式转换、在线视频下载、DVD转换、屏幕录像于一体的mac全能视频编辑工具。可以转换格种视频及音频格式，编辑4K、5K、8K视频。轻松剪辑、合并、裁切、分割、添加视频水印、导出字幕等操作。可以加载DVD及ISO镜像，支持下载多个在线视频下载，可以录制屏幕、录制摄像头、录iPhone界面等，功能非常强悍！[cloud.189.cn/t/EZfqU3Ija…](https://link.juejin.cn?target=https%3A%2F%2Fcloud.189.cn%2Ft%2FEZfqU3Ija2Iz%25EF%25BC%2588%25E8%25AE%25BF%25E9%2597%25AE%25E7%25A0%2581%25EF%25BC%259A1nvq%25EF%25BC%2589 \"https://cloud.189.cn/t/EZfqU3Ija2Iz%EF%BC%88%E8%AE%BF%E9%97%AE%E7%A0%81%EF%BC%9A1nvq%EF%BC%89\")\n\n# 系统环境\n\n一些经常会用到的系统资源工具\n\n## 系统命令\n\n```\n# 取消4位数密码限制\npwpolicy -clearaccountpolicies\n\n# 更改密码\npasswd\n复制代码\n```\n```\n# APP安装开启任何来源\nsudo spctl --master-disable\n复制代码\n```\n```\n# 修改主机名\nsudo scutil --set HostName {自定义主机名}\n复制代码\n```\n```\n# 修改共享名称\nsudo scutil --set ComputerName {自定义电脑名}\n复制代码\n```\n\n## 包管理器——Homebrew\n\nHomebrew是Mac OS 不可或缺的套件管理器。\n\n安装 [Homebrew](https://link.juejin.cn?target=https%3A%2F%2Fbrew.sh%2Findex_zh-cn \"https://brew.sh/index_zh-cn\")\n\n```\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n复制代码\n```\n\n将以上命令粘贴至终端。\n\n**使用方法：**\n\n```\n# 更新 Homebrew\nbrew update\n\n#  搜索相关的包\nbrew search [关键词]\n\n# 查看包的信息\nbrew info [软件名]\n\n# 查看已安装的包\nbrew list\n\n# 更新某个软件\nbrew upgrade [软件名]\n\n# 清理所有软件的旧版\nbrew cleanup\n\n# 卸载某个软件\nbrew uninstall [软件名]\n\n# 安装某个软件\nbrew install [软件名]\n复制代码\n```\n\n**注意事项：**\n\n*   Homebrew 会将软件包安装到独立目录，并将其文件软链接至 `/usr/local` 。\n\n    ```\n    $ cd /usr/local\n    $ find Cellar\n    Cellar/wget/1.16.1\n    Cellar/wget/1.16.1/bin/wget\n    Cellar/wget/1.16.1/share/man/man1/wget.1\n\n    $ ls -l bin\n    bin/wget -> ../Cellar/wget/1.16.1/bin/wget\n    复制代码\n    ```\n\n*   Homebrew 不会将文件安装到它本身目录之外，所以您可将 Homebrew 安装到任意位置。\n\n*   M1的Homebrew会把程序安装到/opt/homebrew/Cellar这个目录中，Intel的会把程序安装在/usr/local/Cellar中。\n\n\n## Xcode\n\n官网：[developer.apple.com/cn/xcode/](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fcn%2Fxcode%2F \"https://developer.apple.com/cn/xcode/\")\n\nXcode是运行在操作系统Mac OS X上的集成开发工具，由Apple Inc开发；Xcode是开发macOS和iOS应用程序的最快捷的方式；Xcode具有统一的用户界面设计，编码、测试、调试都在一个简单的窗口内完成。\n\n不搞ios开发可不装\n\n## 苹果开发者工具 command line tools\n\nCommand Line Tools 是苹果的一个小型独立包，适用于 macOS，为终端扩展了额外的功能。包括但不限于：svn、git、make、GCC、clang、perl、size、strip、strings、libtool、cpp、what、codesign以及其他很多能够在Linux中找到的命令。这个程序员必装！\n\n对于 macOS 的普通用户来说，主要是使用它的签名功能，就是给没签名的应用/签名失效的应用进行签名啦。因为苹果的应用不签名或者签名失效基本上就会闪退无法运行。\n\n大家只需打开终端，然后在终端中执行 `xcode-select --install` 就会打开安装程序，然后按提示安装即可。\n\n## Git\n\nMac上是自带git的，所以不需要自己下载和安装，command line tools也包含了git，但如果你需要安装新的版本可以使用homebrew安装，或者去官网下载引导安装程序。\n\n检查git是否已安装 `git --version`\n\n官方网站地址：[git-scm.com](https://link.juejin.cn?target=https%3A%2F%2Fgit-scm.com%2F \"https://git-scm.com/\")\n\n点击Downloads --> 选择macOS --> 点击Binary installer的installer或者是2.33.0这两个链接中的一个：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c292916193da42dd8ee0471a66e8863b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n引导安装： ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12c359af850847a795900afc2a91c6f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n**2\\. 配置github的ssh**\n\n终端输入：\n\n```\nssh-keygen -t rsa -C \"你的git用户名或者是你的邮箱名\"\n复制代码\n```\n\n按下enter，输入自定义密码，然后可以看到id\\_rsa的文件名和路径(/User/用户名/.ssh/id\\_rsa)。 这是个隐藏文件夹，默认情况下我们看不到。为了找到这个隐藏文件夹，快捷键shift+command . (别忽略command后面那个点，每个人设置的快捷键不同，我的是默认快捷键)。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd2df0d8463f484cbc9ec121d0e2b641~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n找到秘钥文件，打开id\\_rsa.pub文件，将全部内容全部copy到github上做添加配置：\n\n*   github主页点击右上角头像-->setting-->SSH and GPG Keys --> new SSH key\n\n\n**3\\. git的一些基本命令使用**（以下命令需要在git仓库文件夹 下面操作）：\n\n```\n`git init` 初始化仓库，把一个普通文件夹变成git仓库，使用git命令去管理（同目录下多出一个.git文件夹）\n\n`git add` 文件名/     git add -all 添加文件到追踪暂存区，用来追踪文件，只有追踪的文件才能被提交到远程仓库\n\n`git status`     查看当前git仓库的修改文件的状态，哪些修改文件追踪了，哪些没有被追踪\n\n`git commit -m “xxx”`     提交本次修改到历史版本记录，xxx是对这次提交的说明\n\n`git log`   查看历史版本记录 git log -p 是查看详细提交代码\n\n`git reset` 版本号 --hard     回滚到指定版本\n\n`git reflog`      记录每次提交的版本号\n\n`git remote add origin xxxx`     添加别名映射，将远程仓库地址xxx映射为origin\n\n`git remote -v`     查看当前有哪些别名映射\n\n`git remote delete origin`     删除origin别名映射\n\n`git pull origin master -f`     拉取远程origin仓库的内容到本地仓库 -f是强制选项\n\n`git push origin master`    推送本地仓库的历史修改到远程仓库\n\n`git checkout -b dev` 新建并且切换到dev分支\n\n`git checkout master` 切换到master分支（如果分支已存在，就不用加上-b，如果没存在，就加上-b新建并且切换）\n\n`git merge dev` 将分支dev合并到master分支（在master分支上进行）\n\n`git branch -v` 查看当前有哪些分支，绿色的表示当前所在分支\n复制代码\n```\n\n## cmake\n\n官网下载地址：[cmake.org/download/](https://link.juejin.cn?target=https%3A%2F%2Fcmake.org%2Fdownload%2F \"https://cmake.org/download/\")\n\n**cmake配置**\n\n打开cmake.app\n\n从菜单栏选择：Tools--How to Install For Command Line Use\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5637c8ec59646ef929f75374f48b3e3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n使用提供的第二种方法：\n\n```\nsudo \"/Applications/CMake.app/Contents/bin/cmake-gui\" --install\n复制代码\n```\n\n这样就能在终端使用cmake了\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41997131840c4be8babeff04e91f6431~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n## 终端美化——oh-my-zsh\n\nmac系统默认的shell就是zsh，其实不止一种，可以用命令`cat /etc/shells`查看。\n\n默认的白底黑字很简洁，但是不够现代化，我们需要更花哨好看以及实用的代码高亮主题。\n\nzsh的功能极其强大，只是配置过于复杂，而**Oh-my-zsh**这个插件，可以让**zsh**更加容易上手。\n\n查看官方教程，项目地址：[github.com/ohmyzsh/ohm…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fohmyzsh%2Fohmyzsh \"https://github.com/ohmyzsh/ohmyzsh\")\n\n**官方配置安装**\n\n打开终端，输入官方提供的脚本：\n\n```\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n复制代码\n```\n\nLinux同样适用的，前提是你的网络能访问到github，如果你的设备无法有效访问GitHub，可以使用国内大牛的脚本：\n\n```\nzsh -c \"$(curl -fsSL \'https://api.host.mintimate.cn/fileHost/public/download/1P0R\')\"\n复制代码\n```\n\n**切换主题**\n\n可以在这查看主题样式：[github.com/ohmyzsh/ohm…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fohmyzsh%2Fohmyzsh%2Fwiki%2Fthemes \"https://github.com/ohmyzsh/ohmyzsh/wiki/themes\")\n\n记住你喜欢的主题名～\n\n在你的用户目录下，按住`command+shift+.` 找到隐藏文件`.zshrc`修改自己想要的主题名。\n\n找到文件中的ZSH\\_THEME=配置项，等号后面修改为\"主题名\"，例如我改成了\n\n```\nZSH_THEME=\"steeef\"\n复制代码\n```\n\n使用命令`source ~/.zshrc`或重启终端就会生效。\n\n**粘贴自动转义问题**\n\n使用**Oh-my-zsh**，默认是使用自动粘贴转义。但是这样容易出差错，比如在粘贴 URL 的时候，会自动转义\"? = &\"等特殊字符。为此，如果需要关闭自动转义，可以打开`~/.zshrc`文件，添加一行`DISABLE_MAGIC_FUNCTIONS=true`或者取消其注释\n\n**自动提示补全和语法高亮插件**\n\n1.下载高亮插件：\n\n```\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting\n复制代码\n```\n\n2.下载自动提示补全插件：\n\n```\ngit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions\n复制代码\n```\n\n3.修改 `.zshrc` 文件：\n\n将文件中的`plugins=(git)`配置项，修改为`plugins=(git zsh-syntax-highlighting zsh-autosuggestions)`\n\n运行`source ~/.zshrc`生效，现在我们的终端更华丽了\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc53eb7df42e4379b96deb8edfef3821~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n# 语言及开发工具\n\n## vscode\n\nVisual Studio Code 是一款现代 Web 和云应用的跨平台源代码编辑器。强大的插件市场可以让你完全自定义你的专属编辑器。\n\n官方下载地址：[code.visualstudio.com/Download](https://link.juejin.cn?target=https%3A%2F%2Fcode.visualstudio.com%2FDownload \"https://code.visualstudio.com/Download\")\n\n解压后，移动到应用程序目录即可\n\n一般用来阅读或编辑单个文件，因为比较轻量，也可以配合各个语言的插件来运行调试。\n\n## GitPod\n\ngitpod.io 是一个的在线的编程环境。 只需要浏览器打开[gitpod.io/ ](https://link.juejin.cn?target=https%3A%2F%2Fgitpod.io%2F%25C2%25A0 \"https://gitpod.io/%C2%A0\") 用 github 账号登录，就可以编码运行而无需其他配置。\n\n## Java\n\noracle jdk下载：[www.oracle.com/java/techno…](https://link.juejin.cn?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fdownloads%2F%23java11-mac \"https://www.oracle.com/java/technologies/downloads/#java11-mac\")\n\nopenjdk下载：[jdk.java.net/](https://link.juejin.cn?target=https%3A%2F%2Fjdk.java.net%2F \"https://jdk.java.net/\")\n\n推荐安装8或11版本\n\n顺便聊一下jdk和openjdk的区别：\n\n2009年被oracle收购之前，sun公司将jdk源代码开源，形成了openjdk，但是，在sun开源jdk源代码的时候，其中有一小部分非核心功能的源代码，因为产权问题无法完全开源，因此使用了其他有同样功能的开源代码。\n\nopenjdk中，只包含jdk中最最核心的功能，还有其他的一些第三方实现的功能，或者是插件，可以说openjdk是jdk的极简版本。包含在openjdk源代码中的绝大部分代码和oralce jdk 一模一样。\n\njdk就可以理解为openjdk的一个分支：不仅大家的代码是相同的，而且oracle jdk还会和openjdk保持同步，oracle jdk一旦发现openjdk中的一些bug，oracle在修复之后，把这些修复bug的代码提交给openjdk\n\n另外IBM, Google, FaceBook，阿里巴巴等公司都从OpenJdk中，拿到源代码，然后，经过修改，增加适用自己业务场景的功能，从而形成自己的jdk。\n\n## Golang\n\n官方下载地址：[golang.org/dl](https://link.juejin.cn?target=https%3A%2F%2Fgolang.org%2Fdl \"https://golang.org/dl\")\n\n中文网下载:[studygolang.com/dl](https://link.juejin.cn?target=https%3A%2F%2Fstudygolang.com%2Fdl \"https://studygolang.com/dl\")\n\n按照引导程序安装即可，终端执行 `go version` 查看是否安装成功\n\n## C++\n\n安装Xcode或者前面安装苹果开发者工具 command line tools 的时候其实已经安装了C++\n\n终端执行命令`clang++ --version`可以检查是否安装及版本\n\n## Python\n\n官方地址：[www.python.org/](https://link.juejin.cn?target=https%3A%2F%2Fwww.python.org%2F \"https://www.python.org/\")\n\n也可以使用homebrew直接安装 `brew install python3`\n\n不过用python大家一般都是直接安装[Anaconda](https://link.juejin.cn?target=https%3A%2F%2Fwww.anaconda.com%2Fproducts%2Fdistribution \"https://www.anaconda.com/products/distribution\")更好管理环境\n\n## JetBrains全家桶\n\n在官网下载安装自己需要的 IDE，例如我常用的有Goland、IDEA、CLion、Pycharm\n\n下载地址：[www.jetbrains.com/](https://link.juejin.cn?target=https%3A%2F%2Fwww.jetbrains.com%2F \"https://www.jetbrains.com/\")\n\n据说教育邮箱最多支持同时三台机器在线。\n\n# 总结\n\n本文梳理了推荐MacBook安装的一些高效软件，能够满足绝大部分的办公以及日常生活需求。其次，陈述了对于开发者必备的环境配置要求。最后总结了一些开发语言和工具的下载地址以及安装注意事项。\n\n暂时先更新到这里，很晚啦～','2022-07-04 19:09:00',0000000011,'开发工具',178),(0000000032,'为啥谷歌的内部工具不适合你？','我一直在思考一个问题，为啥国外的好工具/好实践到了国内就变味了。难理解，难使用，用不顺，效果差......总会有这样那样的问题。','![为啥谷歌的内部工具不适合你？](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48b4443715fc4b1fbc709f4e7984a30c~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n我一直在思考一个问题，为啥国外的好工具/好实践到了国内就变味了。难理解，难使用，用不顺，效果差......总会有这样那样的问题。最近正好看到了一篇文章《离开谷歌的副作用：外面很难找到这么好用的开发工具》，越发觉得之所以用不好，效果差，源头上这些工具可能就不适合你。这里的「你」不是单指某一个公司，而是众多的国内公司。\n\n很多谷歌出来的小伙伴感叹「离开谷歌之后，很难再享受到这些称手的开发工具了」。是的，世界上很少有公司能有谷歌内部那么多牛逼的工具，这是事实。在硅谷几家互联网公司横着跳也许落差没那么大，如果要是回到国内，环境的「水土不服」「难落地」可能是最大的问题，至于「工具不好用」我个人觉得倒没那么重要，顶多不顺手不好用，但不至于呆不下去。\n\n> 国内的很多公司也都在向外看，这是很好的。之前的老东家也经常到硅谷去「开天眼」，主要是到互联网公司参观、学习、交流，顺便可以和一些大牛聊聊，如果能拉几位大牛入伙那就更好了。\n\n国内外公司软件开发大环境上有很大的差异。主要体现在以下几个方面\n\n# 「生存」阶段，先活下来再说\n\n国内的众多企业还处在「生存」阶段，更注重商业目标，尤其是互联网企业，生存都是问题。小车能跑就行，至于轮胎是固特异、马牌还是米其林，生存期的很多公司考虑的并不多，即便考虑了，也不是第一位的问题。\n\n# 国内的企业赚钱难度高\n\n即便国内的企业度过了创业初期，千军万马中活下来了，很多时候赚的钱也都是小钱、辛苦钱，而不是像谷歌摇钱树「在线广告」那样赚得多赚得容易。也就不会长期投入大量的人力物力到基础设施底层工具的建设上。\n\n整体上，我认为国内的很多公司在工具建设基础设施投入上是在上升的，尤其是BAT。简单说，腾讯赚钱了，tapd、工蜂、CoDesign等也对外服务了；阿里赚钱了招了很多牛逼的人开源了众多的框架、工具，比如Druid、Dubbo、RocketMQ、Nacos等等，阿里达摩院也在进行基础科学和颠覆式技术创新研究等；百度的自动驾驶 Apollo RT6 具备了L4 级别的自动驾驶。\n\n> 如果互联网公司都赚不到钱，又有哪些公司能低成本地赚到钱，去做那些「长期而重要」的事情？我们要允许一部分人一部分产业先富起来，先富的带动后富的，逐步实现共同富裕。\n\n# 国内的软件开发复杂度没那么高\n\n2015年谷歌已经有20亿代码行，2019年达到25亿行，这在现在也都是很大的一坨。众所周知谷歌采用的是单根代码树，除了几个特殊的业务，比如安卓代码，几乎所有业务都在一个代码库中，且很少用三方代码，不重复。而国内的实情是1）国内没那么高的代码量，2）众多公司采用微服务，一个仓库一个服务，复杂度大幅降低 3）国内大公司除了 BAT，都是近些年快速发展起来的，历史包袱少。所以整体上说，我们是需要很多的工具，但是我们遇到的情况比谷歌简单的多，我们可选的工具列表要比谷歌多很多，我们有更多不错的工具可以选。\n\n# 每个工具的背后都有大量基础设施的支撑\n\n拔出萝卜带出泥。想引入一个工具，背后可能需要涉及众多的工具，可能需要众多工具的相互打通、数据流转，流程梳理固化，团队配合。另外就是单点、局部的工具优化优先级和重要性都比从根本上系统性地解决效能问题低。不要选择太小众的工具，对公司、团队和个人都没有好处，日后的维护和二次开发都会成问题。\n\n# 工具的背后是企业文化\n\n当你接受谷歌的工具时，某种程度上你还需要接受工具背后它的文化，这样才能把工具用对、用好。否则很容易「形相似，意有别」。比如在谷歌推广并发扬光大的 OKR，国内几乎成了另外一种形式上的 KPI。\n\n# 国内公司的考核机制\n\n国内公司的考核机制往往也不利于基础工具的发展。国外做工具升职加薪和做业务并无太大差别，而国内很多公司的考核向业务倾斜，同样都是 CRUD，为啥做业务的 6个月年终奖，做基础工具的4个月年终奖？做业务可以随着风口一起飞，业务增长奖金翻倍，做工具的呢？自己做出工具来，还要能「自举」。自己尝鲜、自己推广、自己运营、自己支撑。业务做不好，客户骂公司，绝对不会骂单独一个人；基础工具做不好内网直接找到人， IM 直接喷。所以选择做内部基础设施做工具链的都是心中有真爱的。\n\n# 短周期小投入高产出的预期\n\n上了这套流程或者工具，我们能省几个研发人员？或者说同样的人员一个迭代能多做几个功能点？按照我们刚才聊的全流程打通、状态自动流转，数据收集和度量，我们投入5 个人半年能搞定么？在公司人员一定的情况下，研发效能基础工具的改进能改善产研团队的工作体验、提高整体效率和质量在一个相对稳定的水平。在公司人员越来越多的情况下，它仅能保证效率和质量处于一个相对合理的水平，而不至于下降太快。公司人员越多，基础设施建设带来的整体业务价值提升也就越高。激进大体上看是好的，激进一点、着点急上点火才有动力有心思有想法去搞新的东西，但是太激进也待商榷。工具的建设非一朝一夕，需要长时间地积累和改进优化。\n\n# 怎么才能做好呢\n\n**华为：先僵化-后优化-再固化**\n\n对于引进先进的管理体系和管理规则，华为花了20亿摸索出来的方法是：先僵化-后优化-再固化\n\n*   先僵化：一成不变地原样照抄。找准一个学习标杆，别人怎么做你就怎么做，不管自己理解不理解，先来个死搬硬套再说。\n*   后优化：在新制度实施一段时间后，根据实际情况逐步改进优化流程，使之更加有效，以期取得更好效果。\n*   再固化：一旦经过实践证明效果最佳，固定下来以后都按这个执行，不允许随意更改。\n\n上面的方法需要1）巨大的投入 2）强大的执行力 3）恰当的时间点和决策。而且每一步都要经历一些阵痛，若非华为强大的执行力，真不是很容易落地下去。\n\n**公司内生**\n\n我觉得人员有限、资源缺乏的情况下，公司内生是一个比较好的策略。怎么内生呢？没有钱的公司就用开源软件，有一点的找商业软件，很有钱的自研；投入的资源多，得到的产品体验、功能、个性需求支持也就越多。不同段位的公司得找到与自己适配的策略和实现路径，搭配错了空生烦恼且同时浪费心智。怎么解决这个问题呢？找人吧，可参考《找到能做好研发效能的人》。\n\n# 全文总结\n\n有些时候不是我们用不好国外的很多工具，而是这些工具根本就不适合你。做很多事情都要结合现实去搞，不能一味照抄国外，当然也不能一味照抄国内的一线大厂，否则很容易造成「没有大公司的命，却得了大公司的病」。脚踏实地日拱一卒也是一种小确幸。','2022-07-25 23:38:00',0000000011,'开发工具',16),(0000000033,'越折腾越好用的 3 款开源APP','这种应用在刚装完时一般都是功能简陋、毫无惊艳的地方，但会随着用户为满足自身需求挖掘应用的功能，逐渐地发现它们的强大之处！','![越折腾越好用的 3 款开源 APP](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aded4caefef544718e7351ce0c92ae2e~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n携手创作，共同成长！这是我参与「掘金日新计划 · 8 月更文挑战」的第3天，[点击查看活动详情](https://juejin.cn/post/7123120819437322247 \"https://juejin.cn/post/7123120819437322247\")\n\n高中的时候我特别喜欢捣鼓手机，然后我一个哥们儿在我的强烈推荐下买了个 HTC Dream(G1) 手机。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecc1f55299dc4de493035c6379e057b0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\nG1 作为谷歌的第一个亲儿子，它出厂搭载的是 Android 1.5 系统，但当时已经出到了 2.1 版本。所以，我就每天逛各大手机论坛找 ROM 给他刷机各种折腾，但我那哥们儿很挑剔，每次刷完都会反馈一堆问题。不仅如此，**他还经常为了找到一个好用的 APP，会把能找到同类型 APP 装一遍，然后逐一评测**。但就算如此，还是很难找到一款让他十分满意的 APP...那一段时间，我们沉浸在各种 ROM 和 APP 中乐此不疲。\n\n后来我才明白，他要找的是**高自由度的 APP**，此类应用会给用户留下很大的**可玩空间** 比如：自定义主题、内容、功能等。\n\n这种应用在刚装完时一般都是功能简陋、毫无惊艳的地方，但会随着用户为满足自身需求挖掘应用的功能，逐渐地发现它们的强大之处！\n\n那么 GitHub 上有没有这种手机 APP 呢？\n\n终于，经过我不懈地努力找到了！本期 HelloGitHub 就给大家介绍 3 款**高自由度**、**经得起折腾**的开源 APP。\n\n## 一、记忆神器：Anki\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dc67196c7c14c62a6854d5cdb8e1f92~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 1.1 介绍\n\n这是一款帮助记忆的工具。它将知识内容以卡片的形式展现，然后通过间隔重复的方式记忆知识点，还可以根据遗忘曲线安排复习计划，帮助用户将知识点牢牢记住。\n\n相较于我们常见的记忆单词 APP，它支持导入包括单词在内的各种类型的知识牌组，这些牌组可以是别人分享整理好的，也可以自己亲手制作。有了这些牌组**可以让你充分地利用零碎时间，学习一门语言、地理知识、复习知识点、准备考试等**，而且数据还支持多端同步。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06eb737f663242f0834527308231296a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n> 平台：Windows、Linux、macOS、iOS、Android\n>\n> 项目：[github.com/ankitects](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fankitects \"https://github.com/ankitects\")\n>\n> 下载：[apps.ankiweb.net/](https://link.juejin.cn?target=https%3A%2F%2Fapps.ankiweb.net%2F \"https://apps.ankiweb.net/\")\n\n### 1.2 上手\n\n因为刚装好的 Anki 是没有记忆卡片的，所以需要自行下载。步骤如下：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fdd5c2f11f040eabe58c280d74ae204~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n①点击“+” -> ②选择“获取共享牌组” -> ③进入“Anki 牌组网站” ->\n\n④搜索或者选择牌组 -> ⑤点击“Download”下载牌组 -> ⑥下载完成后，打开方式选“Anki”\n\n等待导入完成后，就可以选择牌组进行学习了！后面还可以根据自己的需求制作完全适合自己的知识卡片。\n\n但由于篇幅问题，这里就不介绍如何自制牌组了，感兴趣的小伙伴可以自行查阅下相关资料。\n\n## 二、强大的手机终端：Termux\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bac5d3c1975648bbb0ea0c925deec3d4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 2.1 介绍\n\n一款适用于 Android 设备的终端模拟器。它支持常用的 Linux 命令，而且还可以通过 `pkg` 命令安装更多工具，比如：clang、Python、MySQL、Git、Vim、SSH、htop 等，让手机瞬间变成便携式 Linux 计算机，通过手机就可以完成：远程连接服务、运行代码片段、编译代码、更新开源项目等操作。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1638b40a713e4ad485365e7bb703afd4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n> 项目：[github.com/termux/term…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftermux%2Ftermux-app \"https://github.com/termux/termux-app\")\n>\n> 下载：[f-droid.org/en/packages…](https://link.juejin.cn?target=https%3A%2F%2Ff-droid.org%2Fen%2Fpackages%2Fcom.termux%2F \"https://f-droid.org/en/packages/com.termux/\")\n\n虽然 Termux 仅支持 Android 设备，但是 iOS 用户也有同样的神器：iSH。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fd686a25b364ac0a01f4ef8af713ae4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n> 项目：[github.com/ish-app/ish](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fish-app%2Fish \"https://github.com/ish-app/ish\")\n>\n> 下载：[ish.app/](https://link.juejin.cn?target=https%3A%2F%2Fish.app%2F \"https://ish.app/\")\n\n### 2.2 上手\n\nTermux 安装上没有什么要说的，根据提示一步步确认就行了。因为它过于强大功能太多，介绍起来无法做到面面俱到，所以这里就先简单介绍下**如何快速上手和我常用的包**。\n\n1.  安装软件：`pkg install 包名`，如果安装过程中遇到卡顿可尝试替换成[清华镜像](https://link.juejin.cn?target=https%3A%2F%2Fmirrors.tuna.tsinghua.edu.cn%2Fhelp%2Ftermux%2F \"https://mirrors.tuna.tsinghua.edu.cn/help/termux/\")\n2.  安装 git：通过 Git 管理 GitHub 上的项目\n3.  安装 openssh：远程管理服务器，scp 远程传输文件\n4.  安装 python：在手上运行 Python 代码，比如：一条命令启动文件服务器、you-get 下载视频等\n5.  支持 nohup：后台常驻、定时脚本\n6.  安装 mariadb：远程连接数据库查询数据\n\n如果你有一个闲置 Android 手机，给它装上 Termux 后。手机摇身一变就是一个没有公网 IP 的 Linux 服务器，虽然没有公网 IP 但是搭建的服务器，可以借助 ngrok、frp 等内网穿透工具实现公网访问。\n\n由于我没有 iOS 设备，所以就没有介绍 iSH，但两者玩法应该差不多。\n\n## 三、家庭影院级别的媒体库：Kodi\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90d309888a1049b79080ea71454cf275~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 3.1 介绍\n\nKodi 是由 XBMC 基金会开发的开源媒体播放器，原名为 XBMC 因为起初是为 Xbox 设计的软件，后来才扩展到了手机、PC、电视盒子等设备上。\n\n它本质上是一个媒体播放器，但我更愿称其为“数字媒体的娱乐中心”。因为它不仅支持播放本地视频，还支持播放网络存储设备(NAS)、投屏、直播流、电视、播客等源。而且界面炫酷支持中文，还拥有丰富的插件库。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cd44ec6dced4202934491f4bbef8c84~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n> 项目：[github.com/xbmc/xbmc](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxbmc%2Fxbmc \"https://github.com/xbmc/xbmc\")\n>\n> 下载：[kodi.tv/](https://link.juejin.cn?target=https%3A%2F%2Fkodi.tv%2F \"https://kodi.tv/\")\n\n### 3.2 上手\n\n刚装完进去，啥都没有而且界面还是英文，不慌一步步来。\n\n#### 1.设置中文\n\n把界面语言换成中文，步骤如下：\n\n①点击左上角“⚙️” -> ②选择“Interface” -> ③进入“Skin” ->\n\n④把“Fonts”改成“Arial base” -> ⑤进入“Regional” -> ⑥把“Language”改成“Chinese”\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9005ce23cd014a759c631fcd7b6f8bc0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n至此，中文界面就设置好了。\n\n#### 2.电影\n\n回到首页在“电影”分类中，可以选择影片进行播放。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4d78e625dc3492da1341737260956ed~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n#### 3.电视\n\n下载“电视源”地址的 m3u 文件到手机里备用。\n\n> 电视源：[iptv-org.github.io/iptv/countr…](https://link.juejin.cn?target=https%3A%2F%2Fiptv-org.github.io%2Fiptv%2Fcountries%2Fcn.m3u \"https://iptv-org.github.io/iptv/countries/cn.m3u\")\n\n进入“电视”分类，根据提示进入插件安装界面，找到“IPTV Simple Client”插件点击安装，等待安装完成。\n\n然后点击插件的“设置”选项，把位置切换成“本地路径”，选择上面下载好的 `cn.m3u` 文件，回到首页电视分类就可以观看电视啦。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc80b8a7e2524e8f8dfdd91f6f746922~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n**提示**：如遇卡顿是电视源的问题，可自行寻找更加优质的电视源替代。\n\n#### 4.投屏\n\n进入 Kodi 电视端，点击左上角“⚙️”，进入服务的“UPnP/DLNA”选项，开启“启用 UPnP”支持和“允许通过 UPnP 远程控制”，即可开启投屏功能，后面手机上投屏的时候就可以看到”Kodi“选项了。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0a6a398aecc47669eace8eded332bd6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n**这里只介绍了 Kodi 基本功能**，但它真正的威力需要配合 NAS 和各种插件才能充分表现出来，但由于篇幅问题这里就不展开讲了。如果你要折腾 NAS 这里推荐一个开源的 NAS 媒体库工具：[nas-tools](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjxxghp%2Fnas-tools \"https://github.com/jxxghp/nas-tools\")，我只能帮到这里啦。\n\n## 四、最后\n\n以上介绍的 3 款开源 APP，它们无一例外**在刚安装好的时候啥都没有，都需要折腾一下才能真正用起来**，可能很多人就是因为这一点与它们擦肩而过。希望本文的内容，能够帮助那些起初不知道它们或者一直想尝试但无从下手的小伙伴们，快速掌握最基本的使用方法，享受“折腾” APP 的乐趣。\n\n其实“折腾”也就是熟悉的过程，虽然有的时候会遇到问题或者卡住，但只要渡过了适应期，后面就是一劳永逸，回头看的时候会觉得一切都值得。\n\n以上就是本期的所有内容了，如果您觉得我写得还不错：**求赞、求收藏、求转发**，您的支持就是对我最大的鼓励！我们下期见～','2022-08-10 00:41:00',0000000010,'开发工具',15),(0000000034,'github访问很慢，又没有梯子该怎么办？','作为国内的用户，我相信绝大多数的家人们都遇到过一个问题，那就是访问github的时候非常非常慢。甚至有的时候访问网站页面直接死掉。这个时候该有人说了，我有梯子我不怕，上网速度嗖嗖的。','### 前情提要\n\n作为国内的用户，我相信绝大多数的家人们都遇到过一个问题，那就是访问github的时候非常非常慢。甚至有的时候访问网站页面直接死掉。这个时候该有人说了，我有梯子我不怕，上网速度嗖嗖的。\n但是，首先国家是不允许私人搭梯子的，是违法的哦。如果去买的话，好像价格也不便宜。那我们这个时候该怎么办？毕竟使用github也是我们的日常。\n\n### 如果没有梯子的话，就看看下面的方法吧\n\n#### 根据评论区里的评论现进行总结\n\n*   **第一种方式**：\n    *   名称及路径：[FastGithub](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdotnetcore%2FFastGithub \"https://github.com/dotnetcore/FastGithub\")\n    *   推荐人(名称加主页地址)：\n        *   [尼斯湖皮皮怪](https://juejin.cn/user/4262160330145496 \"https://juejin.cn/user/4262160330145496\")\n        *   [avionEngine](https://juejin.cn/user/1346244869364782 \"https://juejin.cn/user/1346244869364782\")\n        *   [tqqj](https://juejin.cn/user/3646422756107838 \"https://juejin.cn/user/3646422756107838\")\n*   **第二种方式**：\n    *   名称及路径：[dev-sidecar](https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Finteresting-goods%2Fdev-sidecar%3F_from%3Dgitee_search \"https://gitee.com/interesting-goods/dev-sidecar?_from=gitee_search\")\n    *   推荐人(名称加主页地址)：\n        *   [CoderFXJ](https://juejin.cn/user/3642028720663127 \"https://juejin.cn/user/3642028720663127\")\n        *   [Harvey在掘金](https://juejin.cn/user/3157453124144423 \"https://juejin.cn/user/3157453124144423\")\n*   **第三种方式**：\n    *   名称及路径：[动态更改本地指向的github的cdn和ip地址](https://link.juejin.cn?target=https%3A%2F%2Fraw.hellogithub.com%2Fhosts \"https://raw.hellogithub.com/hosts\")\n    *   可搭配使用自动动态更改工具（具有一定的小风险）：[SwitchHosts](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Foldj%2FSwitchHosts \"https://github.com/oldj/SwitchHosts\")\n    *   楼主评价：目前在用的方式，稳定性在网络波动的时候有点差。可以优先借鉴其他方式。\n    *   推荐人(名称加主页地址)：\n        *   [Pandamo](https://juejin.cn/user/237150240515742 \"https://juejin.cn/user/237150240515742\")\n    *   教程：[blog.csdn.net/lilyssh/art…](https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Flilyssh%2Farticle%2Fdetails%2F118192010 \"https://blog.csdn.net/lilyssh/article/details/118192010\")\n*   **第四种方式**：\n    *   名称及路径：[steam++](https://link.juejin.cn?target=https%3A%2F%2Fsteampp.net%2F \"https://steampp.net/\")\n    *   更新：现已更名为：**Watt Toolkit**\n    *   推荐人：\n        *   [chunshand](https://juejin.cn/user/114004937933352 \"https://juejin.cn/user/114004937933352\")\n        *   [雨下林](https://juejin.cn/user/1205526509131127 \"https://juejin.cn/user/1205526509131127\")\n        *   [Awesome\\_白嫖党](https://juejin.cn/user/3069492196025901 \"https://juejin.cn/user/3069492196025901\")\n        *   [杰酱94109](https://juejin.cn/user/3808364011729902 \"https://juejin.cn/user/3808364011729902\")\n        *   [Xyon](https://juejin.cn/user/2101921959652285 \"https://juejin.cn/user/2101921959652285\")\n        *   [殇琴羽](https://juejin.cn/user/4019470240590008 \"https://juejin.cn/user/4019470240590008\")\n        *   [文件传偷住手](https://juejin.cn/user/3593626753186477 \"https://juejin.cn/user/3593626753186477\")\n        *   [Cowjiang](https://juejin.cn/user/2982303362204381 \"https://juejin.cn/user/2982303362204381\")\n\n*   **第五种方式**：\n    *   名称：镜像\n    *   地址：[hub.fastgit.xyz/](https://link.juejin.cn?target=https%3A%2F%2Fhub.fastgit.xyz%2F \"https://hub.fastgit.xyz/\")\n    *   缺点：不能登录，只能用来搜索开源项目下载\n    *   推荐人：[Luoooo](https://juejin.cn/user/2400989125290423 \"https://juejin.cn/user/2400989125290423\")\n*   **第六种方式**：\n    *   名称：UU加速器的学术资源加速\n    *   地址：直接百度一下就行\n    *   缺点：标有限时免费，不知道什么时候会收费\n*   **第七种方式**：\n    *   名称：搭梯子\n    *   不建议，违法。\\\\color{red}不建议，违法。不建议，违法。\n\n#### 目前我在用的方式，需要搭配自动修改工具并监听配置文件才可以。上面有介绍\n\n*   **首先我们得先获取github的global.ssl.fastly地址。**\n    *   方式：**[github.global.ssl.fastly.net.ipaddress.com/#ipinfo](https://link.juejin.cn?target=http%3A%2F%2Fgithub.global.ssl.fastly.net.ipaddress.com%2F%23ipinfo \"http://github.global.ssl.fastly.net.ipaddress.com/#ipinfo\")** 访问这个网址。会得到CDN和IP地址。\n    *   如截图所示:![WX20220424-223428@2x.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51fa9e4fcbc34c6d8c077271f6a09ec7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n    *   从图中我们可以看到IP地址是：199.232.69.194\n*   **然后我们再获取github的地址**\n    *   方式：**[github.com.ipaddress.com/#ipinfo](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com.ipaddress.com%2F%23ipinfo \"https://github.com.ipaddress.com/#ipinfo\")** 访问这个网址，会得到CDN和IP地址\n    *   如截图所示：![WX20220424-223705@2x.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90a49e01e1b94651af2f847ecc14ffd3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n    *   从图中我们可以看到IP地址是：140.82.114.4\n*   **最后一步就是修改我们的HOSTS文件**\n    *   **Mac OS系统**\n        1.  直接打开终端\n        2.  输入：sudo vim /etc/hosts\n        3.  输入本机的开机密码\n        4.  然后会看到如下图：![WX20220424-224208@2x.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/859f4f8516b14e68b52778955c7e6144~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n        5.  图中我已经把地址和IP都映射好了。\n        6.  最后就是打开浏览器实际测试了。\n    *   **Windows系统**\n        1.  打开c盘，按照这个路径C:\\\\Windows\\\\System32\\\\drivers\\\\etc\\\\hosts找到hosts文件\n        2.  用文本编辑器打开文件\n        3.  然后直接把：140.82.114.4 github.com 和 199.232.69.194 github.global.ssl.fastly.net复制进去。\n        4.  保存文件，并关闭。然后打开github看看吧\n\n### 这是对比图\n\n*   第一张是没有改之前的，第二张是改之后的。\n\n![WX20220424-225449@2x.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3365df4ef914cbcbcef199b35adfbee~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n![WX20220424-231819@2x.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f04bc03bcf249d69280933a31813557~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)','2022-04-24 15:20:00',0000000009,'开发工具',8),(0000000035,'2个未来技术概念：Web3.0 和元宇宙','最近互联网世界的两个流行语Web 3.0和 元宇宙。看到这些新平台提供的发展潜力，许多公司正在探索 Web 3.0 和元宇宙技术所提供的可能性。','![2个未来技术概念：Web3.0 和元宇宙](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60d1d3522ed0482884feda86eac39b47~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n最近互联网世界的两个流行语 `Web 3.0` 和 元宇宙。看到这些新平台提供的发展潜力，许多公司正在探索 `Web 3.0` 和元宇宙技术所提供的可能性。虽然这两种技术趋势都在描述数字现实和网络的未来，但它们在做什么和如何去做方面是不同的。但是，这两个概念及其功能彼此不同。下面就来了解这两个流行语，以更好地了解互联网的未来发展方向。\n\n### 定义\n\n简而言之，元宇宙揭示了将在互联网上拥有的不断扩展的日常体验（例如游戏、社交、学习和工作），而 `Web 3.0` 试图通过去中心化技术解决互联网当前的问题（例如所有权、隐私和控制）。\n\n#### 什么是元宇宙？\n\n![1648207430537.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a510a28265d4b8ead53712c4757545d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n元宇宙（Metaverse）是来自 1992 年科幻小说《雪崩》出版物存在的一个术语。在小说中，作者将元宇宙（Metaverse）描述为基于虚拟现实的互联网继任者。这本书设想了一个未来，人们可以在虚拟世界中用自己的化身并与他人互动。这就是大多数人理解的元宇宙（Metaverse）：使用增强现实 (AR) 和虚拟现实 (VR) 技术构建的 3D 沉浸式世界。在那里，用户可以通过笔记本电脑、台式机和 VR 耳机等设备作为 3D 化身相互交流和互动。元宇宙可以是中心化的、去中心化的或两者兼而有之。\n\n#### 什么是 Web 3.0？\n\n![1648207461060.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24ce3c6efe764c48b4fdb4684b5d8e7d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n与此同时，号称网络的第三波浪潮，即 `Web 3.0`，是以太坊的联合创始人 `Gavin Wood` 在 2014 年首次提出的一个术语。它的定义要广泛得多，也更难确定。尽管如此，它通常指的是使用分散的基于区块链的机制将用户的数据存储在区块链上并赋予它们控制权。\n\n`Web 3.0` 是从 `Web 2.0`（万维网开发的第二次浪潮）在后端和基础设施变化方面向前迈出的重要一步。`Web 2.0` 是关于将网络带给大众，而 `Web 3.0` 是关于权力下放和从中央当局手中夺回控制权。`Web 2.0` 和 `Web 3.0` 最显着的区别在于后者基于区块链技术。区块链是一个分布式数据库，允许安全、透明和防篡改的交易。它还使其成为开发在公共区块链或点对点网络上运行的去中心化应用程序 (dApp) 的理想选择。\n\n### 涉及的技术\n\n`Web 3.0` 由区块链技术支持的去中心化网络组成，它还采用了尖端技术，如人工智能 (AI)、机器学习 (ML) 和语义网（一种新形式的网络内容，关注意义而非数据结构），提供更加民主化、高效和个性化的用户体验；它优先考虑集体所有权、个性化和内容共享。\n\n另一方面，元宇宙（Metaverse）专为虚拟世界而设计， 元宇宙（Metaverse） 中的体验构建块包括 AR、VR 和 MR（混合现实）。AR将虚拟物品融入到我们身边的物理环境中，而VR技术让你通过3D计算机建模进入3D虚拟世界。增强现实眼镜和虚拟现实耳机是带我们进入虚拟世界的设备。\n\n### 可能的场景\n\n去中心化自治组织 (DAO)、去中心化金融 (DeFi) 和不可替代代币 (NFT) 是 `Web3.0` 中出现的一些产物。例如，用户现在可以通过购买存在于区块链网络上的代币来拥有互联网的一部分：可替代的（例如比特币和以太币等加密货币）和不可替代的（例如 NFT 艺术收藏品）。\n\n至于元宇宙（Metaverse），可以看到不同的领域，如游戏、社交网络/娱乐和房地产，现在都在进入虚拟现实技术，为用户提供更逼真和身临其境的体验。例如，`Horizon Worlds` 是 Facebook（或 Meta）发布的社交 VR 平台，人们可以在其中与他人互动和玩游戏。还可以使用虚拟办公室应用程序（例如 Nth Floor）安排与元宇宙中的同事的工作会议。它的另一个主要机会是新的营销机会，许多品牌，如耐克、H&M 和沃尔玛，都在创建自己的虚拟世界，用户可以在其中购买产品并与品牌建立联系。此外，元宇宙中还有区块链场景，例如虚拟世界 Decentraland 和视频游戏平台 Sandbox。这些应用程序是完全去中心化的，这意味着它们归用户所有或通过 DAO 控制。\n\n### 总结\n\n总而言之，虽然这两个概念在本质上并不相同，但它们肯定在许多方面相互关联，并彻底改变了未来互联网和世界。','2022-03-25 11:34:00',0000000008,'人工智能',4),(0000000036,'31年前的Beyond演唱会，是如何超清修复的？','1991年，29岁的黄家驹率领Beyond乐队登上红馆，举办了连续5天的“生命接触”演唱会。\n\n31年来，经典曲目《光辉岁月》《喜欢你》《不再犹豫》《灰色轨迹》《真的爱你》《再见理想》.......始终留在歌迷心里。','1991年，29岁的黄家驹率领Beyond乐队登上红馆，举办了连续5天的“生命接触”演唱会。\n\n31年来，经典曲目《光辉岁月》《喜欢你》《不再犹豫》《灰色轨迹》《真的爱你》《再见理想》.......始终留在歌迷心里。\n\n然而，当初留下的影像却存在模糊、褪色等多种瑕疵。\n\n7月3日晚，超清修复版Beyond演唱会精选在抖音、西瓜视频、鲜时光TV、今日头条同步直播，超1.4亿人次收看。\n\n随着Beyond的歌声响起，几代歌迷的记忆被唤醒了。\n\n这次超清修复版演唱会上线，是火山引擎多媒体实验室、火山引擎音频技术团队通过画质和音质两个维度的修复，重现了一场音乐盛宴。\n\n接下来，就带大家了解这次超清修复背后的技术亮点。\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85f5df2274e84c87ac22fb456c35ea55~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n图：修复前后对比\n\n**画质修复，再现Beyond风采**\n\n1991年的演唱会中，Beyond四子的服装造型、表情、对白，为人们津津乐道。\n\n火山引擎多媒体实验室通过画质修复，再现了他们的风采。\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd5c04a8b5ba4dd288fa6e84127fc762~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n图：戴着戒指耳环的黄家驹\n\n实验室遇到的第一个难题，是画面清晰度。\n\n大家在看早期视频时，经常有一个感觉，就是条纹多、看不清楚。其中一个主要原因是，早期视频大多采用“隔行扫描”方式处理和显示。而目前主流的视频，用的是“逐行扫描”。\n\n逐行扫描比较容易理解，就是将每一帧从左到右、从上到下扫描完成后，输出一张完整的画面。这需要较大的带宽来传输，在早期难以实现。\n\n于是，人们用隔行扫描来解决：将画面分为两个场，先扫描奇数行像素，再扫描偶数行像素。凭借“视觉暂留效应”，在快速播放时，两个场互相补足，让人眼看到完整的画面。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6051b7daab649ee9ade283a52280bb3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n但由于两个场的画面并非同时出现，如果在新式设备上直接播放，就会产生闪烁和条纹。\n\n这就需要“去交错”：将隔行扫描讯号转换为逐行扫描讯号。\n\n传统的去交错方法只能输入单张画面，对运动的感知不强，难以处理运动场景的模糊情况。实验室对此做了改进，设计了多图输入的神经网络，可以恢复更多细节。\n\n在处理完格式转换问题之后，实验室对视频进行了“超分辨率重建”，该过程可以将视频的分辨率档位从低清处理至超高清，同时在缺少纹理的区域生成更丰富的信息。\n\n对比可以看出，乐队拨弄琴弦的身影，变得更加清晰。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fb2a38731b4487f8afc56e6de42078d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n图：弹奏吉他的黄贯中\n\n在清晰度之外，影片还存在褪色、颜色异常、过亮过暗等问题。如何在解决褪色的同时保留演唱会的复古感，成为了修复的第二大难题。\n\n实验室先对画质进行检测，并依据美学评分，在色调、亮度、对比度、饱和度方面，针对人像和背景区域，分别进行增强。\n\n根据不同画面的统计信息，算法还进行了自适应，使亮区与暗区都能得到最佳表现。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/720296a9ed4448d096c86d69e29bffcd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n图：色彩亮度增强前后\n\n第三个难题，是人像修复。\n\n面部表情是歌手传达情感的重要部分。然而，在演唱会的许多片段中，人脸都存在压缩损伤、模糊、低分辨率等问题。\n\n火山引擎多媒体实验室自研人像增强算法，基于深度学习模型，在消除整体模糊和压缩损伤的同时，进一步做了五官重建，对眼睛、嘴巴、耳朵、皮肤甚至发丝都进行了细节重建和纹理添加，使人脸清晰度更高、更真实。\n\n同时，针对演唱会多角度的人脸场景，包括正脸、侧脸、俯视、仰视，以及被乐器或话筒遮挡的人脸，算法都做了稳定性强的修复。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1502cfd493ed4f118c577e1faee4e38f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n黄家驹在演唱歌曲\n\n修复之后，原本模糊的人脸变得清晰，《光辉岁月》的激情、《灰色轨迹》的悲伤、《真的爱你》的温暖，都更能走进歌迷内心。\n\n**音质修复**\\*\\*，聆听31年前的震撼\\*\\*\n\n这场流传31年的演唱会，曾惊艳过无数歌迷。\n\n然而，早期视频存在各种音质问题，在听感上也不免打折扣。火山引擎音频技术团队通过AI音质修复算法，弥补了这一遗憾。\n\n音质修复算法包含三个模块，第一是降噪模块。\n\n因为早期演唱会收音条件有限，加上环境嘈杂，片子里就出现了许多噪声。\n\n然而，传统降噪方案主要针对人声，而音乐在经过降噪算法处理后，会被不小心“误伤”。\n\n不过，我们的技术团队实现了音乐和人声的兼容，既可以保留这两个部分，也能同时抑制噪声。\n\n如果还不够直观，可以看看下面这张频率分布图：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0eca8d18eef4d009720ff0104546270~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n图：降噪前\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17cd91f07613480dbd0398de46f66d37~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n图“降噪后\n\n降噪前，左边无声段噪声明显，右边音乐段因为掺杂着噪声，图片看起来比较浑浊。而在降噪后，整张图变得清晰了。\n\n这意味着，噪声不管在无声段还是音乐段，都被消除了。\n\n第二个模块是超分模块。这个词听起来有点拗口，其实原理不难理解。\n\n声音的本质是振动，振动频率的单位是赫兹（Hz）。我们听到的声音有高有低，就是因为频率高低不同。如果音频的高频信息更丰富，人耳听起来也会更明亮。\n\n举个例子，女生说话频率比男生高，所以声音也更亮。\n\n早期演唱会的收音设备、录制硬件或存储压缩条件有限，导致高频区域的信息被移除，音质受损。技术团队将人声部分进行频带扩展，恢复了部分高频信息，提升了音质。这就是“超分”。\n\n下面的这段来自《午夜怨曲》，从频率分布图可以看出，超分处理后，一方面，原始音频大于18kHz的高频信息得到了一定程度的拓展补全；另一方面，10kHz和18kHz之间的高频信息同样得到了增强。在听感上，处理后的声音更加清晰明亮。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2daab3ac4c4e47d5a844d60c40e62255~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n图：左为超分前，右为超分后\n\n修复后，当黄家驹唱起《光辉岁月》时，我们也更能感受到声音里澎湃的激情。\n\n聊完降噪、超分，还有响度模块。\n\n响度其实就是音量。同样是因为收音，有时候相对于乐器声和环境音，唱歌的声音反而过小。响度模块的任务就是，单独提取出唱歌的部分进行调整，然后再和其他声音混合，使整体听感更加舒适。\n\n通过响度修复，记忆中的声音，也更能萦绕耳畔。\n\n“喜欢你\n\n那双眼动人\n\n笑声更迷人”……\n\n31年过去，Beyond的歌声始终陪伴着我们。修复，是为了让这份陪伴在岁月的流淌中变得更加光辉。\n\n我们将持续行动，让经典焕发新生。','2022-07-04 04:20:00',0000000007,'人工智能',10),(0000000037,'阿里云人脸人体--人像素描风格化效果体验','','先上效果图：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d147b2ba58e469f95c35ba488906a73~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)​\n\n原图：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2f1f7b967b24701a918ae538415d145~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)​\n\n感觉变素描后更胖了一些。\n\n使用前提：\n\n1.开通人脸人体服务(开通不用钱)，下载sdk。\n\n2.创建Accesskey（到处都需要）\n\n3.图片要上传到OSS上（上海地区）。\n\n相关内容可以参考：[《【详细】阿里云人脸识别-人脸检测体验（基于python）》](https://link.juejin.cn?target=https%3A%2F%2Fwww.fearlazy.com%2Findex.php%2Fpost%2F325.html \"https://www.fearlazy.com/index.php/post/325.html\")\n\n图片限制：\n\n格式为JPG、JPEG或PNG。 大小小于10M，分辨率介于100x100到2000x2000。\n\n上代码：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e626b877236a4ec983ec4567c948bcad~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)​\n\n素描化使用模块GenerateHumanSketchStyleRequest。请求需要设置图片URL。\n\n还有一个是图像返回形式head为大头照(默认)、full是全身照。\n\n推荐使用大头照。\n\n请求返回结果数据只有一个ImageURL表示处理后的图片地址。\n\n\n\\---> 文章来源于我的个人博客：fearlazy\n\\---> 编程是一件怎么也学不会的事情，但是如果能享受学习的过程也是挺好的。','2021-10-30 14:46:00',0000000006,'人工智能',3),(0000000038,'有哪些 GitHub 项目的 README 堪称教科书？','详细的项目README，可以参考我的这几个项目。对于想要参与开源项目，自己做开源项目，从开源项目中学习，我的GitHub很值得来看一下。','我敢说我的GitHub开源项目，每个README都是十分规范的。\n\n其实做项目是按照整个产品思维来梳理的。\n\n需要在readme中说清楚几件事：\n\n*   这个项目是什么\n*   跟同类产品/工具有什么独特之处\n*   怎么用，更快的用起来\n*   遇到问题怎么反馈\n*   更新日志，之后的规划（可选）\n*   LICENSE\n*   如何参与贡献（可选）\n\n详细的项目README，可以参考我的这几个项目。对于想要参与开源项目，自己做开源项目，从开源项目中学习，我的GitHub很值得来看一下。\n\n[github.com/Charmve](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2FCharmve \"https://link.zhihu.com/?target=https%3A//github.com/Charmve\")\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b1135fb6e4b4317b9f5fd698e84f254~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n\\[[github.com/Charmve/Sur…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FCharmve%2FSurface-Defect-Detection%25E2%2580%258B \"https://github.com/Charmve/Surface-Defect-Detection%E2%80%8B\")\n\ngithub.com/Charmve/Surface-Defect-Detection\\]([link.zhihu.com/?target=htt…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2FCharmve%2FSurface-Defect-Detection \"https://link.zhihu.com/?target=https%3A//github.com/Charmve/Surface-Defect-Detection\"))\n\n目前最全的工业缺陷检测数据集仓库，包含十余种类型数据集，还有最近几年缺陷检测顶会论文。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28d51aed86ed47df8b92aa9a7d5b5bf5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bdc39e5fc9e40dda1e69f10c1746798~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d69bf725fc074d509e437a2214610fef~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a283d32c0dcf425d8de9c0d2fe430840~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### L0CV 一种结合了代码、图示和HTML的在线学习媒介\n\n上线一周持续登陆GitHub中文榜前三！\n\n\\[[github.com/Charmve/com…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FCharmve%2Fcomputer-vision-in-action%25E2%2580%258B \"https://github.com/Charmve/computer-vision-in-action%E2%80%8B\")\n\ngithub.com/Charmve/computer-vision-in-action\\]([link.zhihu.com/?target=htt…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2FCharmve%2Fcomputer-vision-in-action \"https://link.zhihu.com/?target=https%3A//github.com/Charmve/computer-vision-in-action\"))\n\n更多项目，在我的GitHub账号主页，repos和stars可以查看到，都为大家分类准备好了。\n\n作为一个五年的GitHuber，真心希望开源社区越来越好！\n\n如果你已经看到这里了，可以双击屏幕点个赞吗？我想在知乎给大家带来自动驾驶、C++、视觉感知算法相关的内容，希望做一个传播者，做一个自媒体人。**谢谢！**\n\n[我相信你一定会关注我的GitHub账号！2 赞同 · 1 评论文章](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F517864402 \"https://zhuanlan.zhihu.com/p/517864402\")\n\n2022.05.31 更新\n\n没想到这么多人关注了我的GitHub和知乎，也收到一些私信，大家的关注度还是很高的，我来更新下。大家基本都是在关注，如何具体规划，如何面试、求职。\n\n校招和跳槽每次都会给自己多个选择，然后再去做自己的取舍。这样不至于太匆忙，太被动。校招时也收到了第一个互联网大厂的offer，美团、字节、苏宁、快手、乐鑫科技等，由于在校时一直的规划是做科研，20年毕业时找工作时间很短（三月份开始），我特别焦虑，最后集中临时抱佛脚，在面试中复习总结，全靠每场面试扩充自己的题库，这个过程中也一直总结，发布后收到了很多赞同。现在已经在GitHub和CSDN发布，[leetcode](https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fsearch%3Fq%3Dleetcode%26search_source%3DEntity%26hybrid_search_source%3DEntity%26hybrid_search_extra%3D%257B%2522sourceType%2522%253A%2522answer%2522%252C%2522sourceId%2522%253A2495227205%257D \"https://www.zhihu.com/search?q=leetcode&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2495227205%7D\")\n\n高频题和详细解题总结，八股文分类整理，有需要的可以看看：《大厂后端/算法面经分类整理》专栏概述 (字节+美团+华为+阿里等)》\n\n\\[《大厂后端/算法面经分类整理》专栏概述 (字节+美团+华为+阿里等)​\n\nblog.csdn.net/Charmve/article/details/111051085\\]([link.zhihu.com/?target=htt…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fblog.csdn.net%2FCharmve%2Farticle%2Fdetails%2F111051085 \"https://link.zhihu.com/?target=https%3A//blog.csdn.net/Charmve/article/details/111051085\"))\n\n我本科学的是[电子信息科学与技术](https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fsearch%3Fq%3D%25E7%2594%25B5%25E5%25AD%2590%25E4%25BF%25A1%25E6%2581%25AF%25E7%25A7%2591%25E5%25AD%25A6%25E4%25B8%258E%25E6%258A%2580%25E6%259C%25AF%26search_source%3DEntity%26hybrid_search_source%3DEntity%26hybrid_search_extra%3D%257B%2522sourceType%2522%253A%2522answer%2522%252C%2522sourceId%2522%253A2495227205%257D \"https://www.zhihu.com/search?q=%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2495227205%7D\")，在校时做了很多实践项目，参加了很多大赛：电子设计竞赛、数学[建模](https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fsearch%3Fq%3D%25E5%25BB%25BA%25E6%25A8%25A1%26search_source%3DEntity%26hybrid_search_source%3DEntity%26hybrid_search_extra%3D%257B%2522sourceType%2522%253A%2522answer%2522%252C%2522sourceId%2522%253A2495227205%257D \"https://www.zhihu.com/search?q=%E5%BB%BA%E6%A8%A1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2495227205%7D\")大赛、挑战杯、互联网+，还有一些机器人的比赛，也收获了不错的成绩，毕业后我把相关的资料全部整理开源至GitHub：[github.com/Charmve](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%253A%2F%2Fgithub.com%2FCharmve \"https://link.zhihu.com/?target=http%3A//github.com/Charmve\") 。\n\n毕业后第一年开始转计算机视觉，也做了大量工作，论文阅读以及代码复现，开源项目等等。在GitHub的[repo](https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fsearch%3Fq%3Drepo%26search_source%3DEntity%26hybrid_search_source%3DEntity%26hybrid_search_extra%3D%257B%2522sourceType%2522%253A%2522answer%2522%252C%2522sourceId%2522%253A2495227205%257D \"https://www.zhihu.com/search?q=repo&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2495227205%7D\")和stars中可以看到，现在也会长期维护，每个项目都会自己从框架到实现，亲力亲为。\n\n所以我花了两三年时间，建立了以公众号为中心的迈微AI研习社社群，论文解读、技术分析、商业参考等文章以文字形式发布在公众号和知乎，涉及的实践项目源代码和工程管理以GitHub为中心发布，以实际[软件工程](https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fsearch%3Fq%3D%25E8%25BD%25AF%25E4%25BB%25B6%25E5%25B7%25A5%25E7%25A8%258B%26search_source%3DEntity%26hybrid_search_source%3DEntity%26hybrid_search_extra%3D%257B%2522sourceType%2522%253A%2522answer%2522%252C%2522sourceId%2522%253A2495227205%257D \"https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2495227205%7D\")化角度管理和运维。\n\n希望这些经历和规划给大家鼓励，我也希望找到那个一同进步的人。\n\n一个人可以走很快，但一群人可以走很远！','2022-07-05 08:35:00',0000000005,'人工智能',2),(0000000039,'Mac Pro M1测试PyTorch GPU','这几天暑假回家被社区集中隔离，进来就带了台笔记本每天实在是太无聊了。想起来之前刷到最新版本的Pytorch貌似已经支持M1芯片的GPU加速，趁着有时间动手试试看效果怎么样','# 前言\n\n这几天暑假回家被社区集中隔离，进来就带了台笔记本每天实在是太无聊了。想起来之前刷到最新版本的Pytorch貌似已经支持M1芯片的GPU加速，趁着有时间动手试试看效果怎么样（**目前还是预览版所以对性能啥的也没有期待纯粹好玩**）\n\n# 安装\n\n安装部分还是挺简单的，之前装过tf的M1适配环境，所以这次继续在之前这个环境装个Pytorch。\n\n第一步还是打开官网[Pytorch官网](https://link.juejin.cn?target=https%3A%2F%2Fpytorch.org%2F \"https://pytorch.org/\")，找到安装部分选择好平台啥的，最重要的是选择预览版本。截图如下\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5c4ed1fb58845599411a2ccbc27ab51~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n`pip3 install --pre torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/nightly/cpu` 运行这行命令进行安装，然后下面来开始测试一下\n\n# 开始测试\n\n首先查看相关的信息\n\n```\nimport torch\ntorch.__version__\n\nprint(f\"{torch.backends.mps.is_available(),torch.backends.mps.is_built()}\")\n\na=torch.rand(5).to(\"mps\")\na\n复制代码\n```\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed33d582d0e046679e609002d0a9c3e0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n可以看到Pytorch为M1系列添加了新的后端，不是**cuda**而是**mps**，如果去看官方文档还会发现很多其他接口。目前就这个效果来看确实能使用M1的GPU，但是效果如何呢？我本来想类似于cuda一样使用`torch.cuda.list_gpu_processes()`来查看GPU相关信息，但是貌似他们还没有写mps对应的方法。那就写个简单的demo测试一下，不知道M1的GPU到底适配性如何了。\n\n这里先贴一张系统信息的图\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c900e3b490f439386ca4e760772558c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n内存一共16G，不知道拉满能用多少\n\n这次的测试代码就是利用resnet18微调训练cifar10，优化器还是使用`Ranger`，代码如下\n\n```\ndef get_dataloader(batch_size):\n    data_transform = {\n        \"train\": transforms.Compose([transforms.Resize(96),\n                                     transforms.ToTensor()]),\n        \"val\": transforms.Compose([transforms.Resize(96),\n                                   transforms.ToTensor()])\n    }\n    train_dataset = torchvision.datasets.CIFAR10(\'./p10_dataset\', train=True, transform=data_transform[\"train\"], download=True)\n    test_dataset = torchvision.datasets.CIFAR10(\'./p10_dataset\', train=False, transform=data_transform[\"val\"], download=True)\n    print(\'训练数据集长度: {}\'.format(len(train_dataset)))\n    print(\'测试数据集长度: {}\'.format(len(test_dataset)))\n    # DataLoader创建数据集\n    train_dataloader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)\n    test_dataloader = DataLoader(test_dataset, batch_size=batch_size, shuffle=True)\n    return train_dataloader,test_dataloader\n\ndef show_pic(dataloader):#展示dataloader里的6张图片\n    examples = enumerate(dataloader)  # 组合成一个索引序列\n    batch_idx, (example_data, example_targets) = next(examples)\n    classes = (\'airplane\', \'automobile\', \'bird\', \'cat\', \'deer\', \'dog\', \'frog\', \'horse\', \'ship\', \'truck\')\n    fig = plt.figure()\n    for i in range(6):\n        plt.subplot(2, 3, i + 1)\n        # plt.tight_layout()\n        img = example_data[i]\n        print(\'pic shape:\',img.shape)\n        img = img.swapaxes(0, 1)\n        img = img.swapaxes(1, 2)\n        plt.imshow(img, interpolation=\'none\')\n        plt.title(classes[example_targets[i].item()])\n        plt.xticks([])\n        plt.yticks([])\n    plt.show()\n\ndef get_net(): #获得预训练模型并冻住前面层的参数\n    net = timm.create_model(\'resnet18\', pretrained=True, num_classes=10)\n    #print(summary(net, input_size=(3, 224, 224)))\n    \'\'\'Freeze all layers except the last layer(fc or classifier)\'\'\'\n    for param in net.parameters():\n        param.requires_grad = False\n    # nn.init.xavier_normal_(model.fc.weight)\n    # nn.init.zeros_(model.fc.bias)\n    net.fc.weight.requires_grad = True\n    net.fc.bias.requires_grad = True\n    return net\n\ndef train(net, loss, train_dataloader, valid_dataloader, device, batch_size, num_epoch, lr, lr_min, optim=\'sgd\', init=True, scheduler_type=\'Cosine\'):\n    def init_xavier(m):\n        #if type(m) == nn.Linear or type(m) == nn.Conv2d:\n        if type(m) == nn.Linear:\n            nn.init.xavier_normal_(m.weight)\n\n    if init:\n        net.apply(init_xavier)\n\n    print(\'training on:\', device)\n    net.to(device)\n\n    if optim == \'sgd\':\n        optimizer = torch.optim.SGD((param for param in net.parameters() if param.requires_grad), lr=lr,\n                                    weight_decay=0)\n    elif optim == \'adam\':\n        optimizer = torch.optim.Adam((param for param in net.parameters() if param.requires_grad), lr=lr,\n                                     weight_decay=0)\n    elif optim == \'adamW\':\n        optimizer = torch.optim.AdamW((param for param in net.parameters() if param.requires_grad), lr=lr,\n                                      weight_decay=0)\n    elif optim == \'ranger\':\n        optimizer = Ranger21((param for param in net.parameters() if param.requires_grad), lr=lr,weight_decay=0,num_epochs=num_epoch,num_batches_per_epoch=len(train_dataloader),use_warmup=False,use_madgrad=False)\n    if scheduler_type == \'Cosine\':\n        scheduler = CosineAnnealingLR(optimizer, T_max=num_epoch, eta_min=lr_min)\n\n    if scheduler_type == \'Cyclic\':\n        scheduler =CyclicLR(optimizer,base_lr=lr_min,max_lr=lr)\n\n    train_losses = []\n    train_acces = []\n    eval_acces = []\n    best_acc = 0.0\n    for epoch in range(num_epoch):\n\n        print(\"——————第 {} 轮训练开始——————\".format(epoch + 1))\n\n        # 训练开始\n        net.train()\n        train_acc = 0\n        for batch in tqdm(train_dataloader):\n            imgs, targets = batch\n            imgs = imgs.to(device)\n            targets = targets.to(device)\n            output = net(imgs)\n\n            Loss = loss(output, targets)\n\n            optimizer.zero_grad()\n            Loss.backward()\n            optimizer.step()\n\n            _, pred = output.max(1)\n            num_correct = (pred == targets).sum().item()\n            acc = num_correct / (batch_size)\n            train_acc += acc\n        scheduler.step()\n        print(\"epoch: {}, Loss: {}, Acc: {}\".format(epoch+1, Loss.item(), train_acc / len(train_dataloader)))\n        train_acces.append(train_acc / len(train_dataloader))\n        train_losses.append(Loss.item())\n\n        # 测试步骤开始\n        net.eval()\n        eval_loss = 0\n        eval_acc = 0\n        with torch.no_grad():\n            for imgs, targets in valid_dataloader:\n                imgs = imgs.to(device)\n                targets = targets.to(device)\n                output = net(imgs)\n                Loss = loss(output, targets)\n                _, pred = output.max(1)\n                num_correct = (pred == targets).sum().item()\n                eval_loss += Loss\n                acc = num_correct / imgs.shape[0]\n                eval_acc += acc\n\n            eval_losses = eval_loss / (len(valid_dataloader))\n            eval_acc = eval_acc / (len(valid_dataloader))\n            if eval_acc > best_acc:\n                best_acc = eval_acc\n                torch.save(net.state_dict(),\'best_acc.pth\')\n            eval_acces.append(eval_acc)\n            print(\"整体验证集上的Loss: {}\".format(eval_losses))\n            print(\"整体验证集上的正确率: {}\".format(eval_acc))\n    return train_losses, train_acces, eval_acces\n\ndef show_acces(train_losses, train_acces, valid_acces, num_epoch):#对准确率和loss画图显得直观\n    plt.plot(1 + np.arange(len(train_losses)), train_losses, linewidth=1.5, linestyle=\'dashed\', label=\'train_losses\')\n    plt.plot(1 + np.arange(len(train_acces)), train_acces, linewidth=1.5, linestyle=\'dashed\', label=\'train_acces\')\n    plt.plot(1 + np.arange(len(valid_acces)), valid_acces, linewidth=1.5, linestyle=\'dashed\', label=\'valid_acces\')\n    plt.grid()\n    plt.xlabel(\'epoch\')\n    plt.xticks(range(1, 1 + num_epoch, 1))\n    plt.legend()\n    plt.show()\n\nif __name__ == \'__main__\':\n    train_dataloader, test_dataloader = get_dataloader(batch_size=1024)\n    show_pic(train_dataloader)\n    device = torch.device(\"mps\")\n    net = get_net()\n    loss = nn.CrossEntropyLoss()\n    train_losses, train_acces, eval_acces = train(net, loss, train_dataloader, test_dataloader, device, batch_size=1024, num_epoch=10, lr=0.1, lr_min=1e-5, optim=\'ranger\',scheduler_type=\'Cyclic\',init=False)\n    show_acces(train_losses, train_acces, eval_acces, num_epoch=10)\n复制代码\n```\n\n最终结果 ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d76407b80e340efaa893342b900a749~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n当然，我还拿出了很多年前本科大二买的一台1060笔记本一起跑这段代码，结果如下 ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76d18981942547cbafe950f9098eac18~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n老的笔记本显存只有6G，但是从结果来看由于图片很小所以显存没占满并且速度还比M1快很多，差不多只用M123\\\\frac{2}{3}32​的时间就可以训练结束，这个差距还是挺大的。\n\n# 总结\n\n尝试了一次训练后，其实对M1挺失望的。或许它的优势也就是显存大一点而已，但是目前新款的笔记本或者游戏本显存也有12G，并且价格还没有它高。我们一般在笔记本上搞深度学习只是为了调通代码测试一下大概的效果，真正训练还是放到服务器上跑。所以唯一值得欣慰一点的就是用M1会减轻一点身体负担，毕竟通常游戏本加电源啥的那一套相比Mac来说还是太重了,其他的对于深度学习来说实在想不出优点(**如果有人爱面子啥的那勉强也能凑一个**)。\n\n综上，即使现在主流的两大框架`TensorFlow2`和`Pytorch`都支持M1及以上芯片的GPU加速，但是如果真的为了深度学习来专门买那就是智商税。平时搞搞前后端开发啥的很推荐，易携带而且续航，无噪音，编译速度快；搞深度学习的话不如花一半左右的钱买个高档显存大点的游戏本，效果会好很多。','2022-08-03 11:07:00',0000000004,'人工智能',4),(0000000040,'从一线开发到技术总监，你就差一个赶鸭子上架','鸭子都是被赶上架子的，不敢上，永远不可能完全准备好。','_“鸭子都是被赶上架子的，不敢上，永远不可能完全准备好。”_\n\n_“不要沉湎于疫情带来的挫败，现在或许正是你开展业务的窗口期。”_\n\n在 7 月 7 日开播的猿桌派第三季首期节目中，新任主理人**融云海外业务总经理宋清晨**与 **NextBillion.AI CTO 郑少麟**、**某知名集团公司副总裁沈旸**一起，放眼全球市场，探讨开发者生态和开源社区建设。\n\n三位嘉宾都有丰富的国内外生活和工作经验，并在各自的领域积累深厚，成果颇丰。**嘉宾不吝分享，节目金句频出**，奉上完整版回放和精彩内容集锦。\n\n# **关于人生选择不要怕赶鸭子上架，不要只看眼前得失**\n\n![微信图片_20220720121816.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4b6933103544ad68241a115a9388395~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?) **郑少麟，NextBillion.AI CTO**\n\n我在做决定的时候有两个很重要的原则。第一个是，鸭子都是被赶上架子的。\n\n我最初对这句话有感触，是在 10 年前。当时有一个老板邀请我跟他一起创业，做技术总监，但在这之前，我只做过十几人团队的经理。当时我对技术总监没什么概念，感觉也没有准备好。\n\n一个长辈跟我说，可能当这个岗位要做的 100 件事，你都会了，你就准备好了。但你不在这个岗位上，哪有机会去做这 100 件事呢？所以**你永远不会准备好，有这个机会就要上。**\n\n后来这就变成我的一个普适性原则，帮助我在一些关键选择上去做正确而困难的事。没做过没关系，既然有人给你机会，说明他对你的信心甚至可能大于你自己，那你为什么不迎难而上呢？可能一开始你会进入一种非常焦虑的状态，但只要用你的聪明才智去努力攻克它，你会得到非常快且大的进步。\n\n第二个原则是要**看远期利益，而不是近期得失**。经常有朋友会问我，有两个 Offer 怎么选？他总会告诉我 A 和 B 分别给多少薪水之类的信息。我说这个区别其实最不重要，除非你眼下处于非常艰难的状态。否则，比眼下这个数字更重要的是成长空间，这个也是很多时候在驱动着我前进的一个点。\n\n# **关于疫情不要沉湎于挫折，总有事情可以做**\n\n![微信图片_20220720121825.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80dff76b5ed74ca0bf31cd9cf5f24158~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?) **沈旸，某知名集团公司副总裁**\n\n疫情确实给全球都带来了特别大的影响，但是很多事情从历史上看都会过去的。从另一个角度来讲，挑战总是伴随着机遇。**疫情是一个特殊的场景，能诞生特殊的技术和商业模式。** 很有可能一个商业模式或者技术错过这个窗口期，就没办法孵化出来。\n\n所以这几年要关注适合这个时期的一些技术场景，然后在这种情况下做快速的突破和尝试，比如远程办公体系。可能以前推广这个体系时，很难说服老板。但是今天大家就是要做这方面的预案，这是一个现实。怎么让远程沟通效率更高，更好地实现虚拟背景和降噪，现在是这些技术落地的好机会。\n\n前几年我们在推电子签章技术的时候，发现阻力其实并不是说技术多难，而是因为它是一个生态，即使公司内部的法务认同这套体系，还有外部的客户甚至法院等等是否认同的问题。现在因为疫情，政府都在推广电子签章、电子印章这套体系。在这个时间点，它的发展速度比往年可能要快几十上百倍。\n\n所以疫情确实对经济发展造成了影响，但是所有人都在受影响，去埋怨或者抱怨没什么用，不要陷在挫折里，反而要适应时势去发展业务。**永远有做不完的事，总有一些事情是比较适合当今这个状况去推动的。**\n\n# **关于开发者开发者应该作为技术伙伴而被重视**\n\n![微信图片_20220720121835.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/428fd074deab4eab9e7ae057436a2c70~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?) **宋清晨，融云海外业务总经理**\n\n第一，开发者现在确实越来越被作为一个产品用户而被重视，因为对于云或者其他 ToB 的业务来说，虽然都是企业在购买服务，但实质上最终用这款产品的人是开发者。所以从产品和行业发展的角度来说，**开发者本身就具有非常大的成长性和商业价值。**\n\n第二，我认为站在开源角度来看，开发者其实还是技术的合作伙伴。很多公司做开源的其中一个目的，是更好地吸引市场上的人才，以及把自己的标准变成整个行业的标准。在这个过程中，开源技术被越来越多开发者使用后，能逐渐让自己的标准被更多人认可。开发者就成为了开源技术上的一个合作伙伴。\n\n第三，说到开发者生态运营，我认为是需要放到不同的场景上具体做分析的。一个公司逐渐发展壮大和建立了更多基础服务后，开发者会越来越倾向于使用这些基础套件，也会基于开源项目的平台，甚至是技术环境来做开发，最终让项目达到盈利的目的，实现双赢。\n\n# **关于开源代码开放不等于开源**\n\n![微信图片_20220720121845.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a162254e9f88491799e5e66f2501a985~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?) **猿桌派 3，全球视野，全新篇章**\n\n**沈旸：** 我们第一个开源项目特别有意思，是做了一个画架构图的项目，辛辛苦苦做完后，放到 GitHub 上，只有 8 个 Star。它给我的一个启示是，代码开放不等于开源，**很牛的代码开放，如果没有传播效应，也可能没什么太大用处。**\n\n而像分布式数据库这样的开源体系就是正面的一个例子。在很多公司里，我们发现它其实是从 DBA 往上推的。DBA 掌握的东西很重要，一个数据库多少 T 的数据级，而且关乎公司系统，但又跟应用和开发没关系，容易背锅又处在鄙视链底端。DBA 最关心是，当数据量弹性增长很多的时候，怎么保证不在半夜被叫起来面对库不小心被删了还没有备份的噩梦。\n\n他们会自己主动尝试用分布式数据库，越来越多人加入进来，大家也会提更多的需求到社区里，开源项目会逐渐壮大。然后会有很多基于数据库的第三方服务公司一起加入建设生态，围绕 DBA 的生态，去完成很多基于 DBA 的开发工具和运维工具。一旦这个体系完成，它的力量就会很庞大，迁移的成本会比较大，具有一定的护城河。\n\n**郑少麟：** 对地图行业来说，数据和引擎是两大核心。地图引擎一直以来是有一些开源的项目，但我们更多可能从一个声誉的角度来看，开源是为了让我们在市场中有声音，让大家通过一些比较酷的开源技术认识到我们公司。\n\n但通过它来得到商业价值，我们在地图行业目前没有找到一个好的模式。\n\n对于来源的未来，我的期待是融合，希望大家不要重复造轮子，而是要充分的交流、沟通，各自在擅长的领域去积累，然后一起来把整个技术水平提高上去。\n\n**宋清晨：** 开源社区的发展需要依赖开发者的注入，要让开发者在开源社区逐步建立成就感，再用这个成就感去壮大开发者规模量。\n\n开发者的主动参与，会积极地去影响原有开源社区的代码甚至环境，让它逐步完善和强大。我觉得这是让开源社区更有价值的一个方向。\n\n另一个重点是，我们**真正要尊重技术和开源社区的开发者**，开源技术不一定是来自大公司，只有真正调动了开发者的参与感，才是一个更值得期待的未来。','2022-07-20 08:53:00',0000000003,'阅读',27),(0000000041,'代码注释的艺术，优秀代码真的不需要注释吗？','一段糟糕的代码，往往大家最低的预期是把注释写清楚，最合理的做法通常应该对代码做优化。如果我们将代码真正做到了优秀，我们是否还需要注释？','简介： 一段糟糕的代码，往往大家最低的预期是把注释写清楚，最合理的做法通常应该对代码做优化。如果我们将代码真正做到了优秀，我们是否还需要注释？\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8dbaf4ce5b241a8afbffe1a692f0266~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp \"image.png\")\n\n作者 | 谦风\n来源 | 阿里开发者公众号\n\n### 前言\n\n前天回家路上，有辆车强行插到前面的空位，司机大哥吐槽“加塞最可恶了”，我问“还有更可恶的吗”，司机大哥淡定说道“不让自己加塞的”。似乎和我们很类似，我们程序员届也有这2件相辅相成的事：最讨厌别人不写注释，更讨厌让自己写注释。\n一段糟糕的代码，往往大家最低的预期是把注释写清楚，最合理的做法通常应该对代码做优化。如果我们将代码真正做到了优秀，我们是否还需要注释？\n\n### 注释的意义\n\n```\n; **************************************************************************\n; * RAMinit Release 2.0 *\n; * Copyright (c) 1989-1994 by Yellow Rose Software Co. *\n; * Written by Mr. Leijun *\n; * Press HotKey to remove all TSR program after this program *\n; **************************************************************************\n; Removed Softwares by RI:\n; SPDOS v6.0F, WPS v3.0F\n; Game Busters III, IV\n; NETX ( Novell 3.11 )\n; PC-CACHE\n; Norton Cache\n; Microsoft SmartDrv\n; SideKick 1.56A\n; MOUSE Driver\n; Crazy (Monochrome simulate CGA program)\n; RAMBIOS v2.0\n; 386MAX Version 6.01\n复制代码\n```\n\n注释是对代码的解释和说明，本质目的是为了增强程序的可读性与可解释性。注释会随着源代码，在进入预处理器或编译器处理后会被移除。这是雷布斯1994年写的一段MASM汇编代码，注释与代码整体结构都非常清晰。如果说代码是为了让机器读懂我们的指令，那注释完全就是为了让我们了解我们自己到底发出了哪些指令。\n\n### 争议与分歧\n\n注释的起源非常早，我们甚至已经查阅不到注释的由来，但现在任何一种语言，甚至几乎任何一种文本格式都支持各式各样的注释形式。\n但如何使用注释，其实一直是一个备受争论的话题。当我们接手一段‘祖传代码’时，没有注释的感觉简直让人抓狂，我们总是希望别人能提供更多的注释。但软件届也有一段神话传说，叫做『我的代码像诗一样优雅』。有注释的代码都存在着一些瑕疵，认为足够完美的代码是不需要注释的。\n\n### 坏代码的救命稻草\n\n> The proper use of comments is to compensate for our failure to express ourself in code.\n> \\-- Robert C. Martin 《Clean Code》\n> 译：注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败\n\nClean Code 的作者Robert C. Martin可以说是注释的极力否定者了，他认为注释是一种失败，当我们无法找到不用注释就能表达自我的方法时，才会使用注释，任何一次注释的使用，我们都应该意识到是自己表达能力上的失败。\nPH&V的系统架构师和负责人Peter Vogel，同样也是一名坚定的注释否定着，他发表了一篇文章 why commenting code is still bad 来表述为代码添加注释在某种程度上可能是必要的，但确实没有价值。\n事实上，我们也确实经历着非常多无价值的注释，以及完全应由代码来承担解释工作的“职能错位”的注释。\n\n#### 零注释\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ab45febd4f3405b9c21980b95e88cc1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp \"image.png\")\n\n糟糕的代码加上完全不存在的注释，我喜欢称呼它们为『我和上帝之间的秘密』，当然过2个月后也可以称之为『上帝一个人的秘密』。\n压垮程序员最后一根稻草的，往往都是零注释。可以没有文档，可以没有设计，但如果没有注释，我们每一次阅读都是灾难性的。当我们抱怨它一行注释都没有时，其实我们是在抱怨我们很难理解代码想要表达的含义，注释是直接原因，但根本原因是代码。\n零注释往往和坏代码一起生活，“没有注释”的吐槽，其实本质上直击的是那堆歪七扭八的英文字母，到底它们想表达什么！\n\n#### 无用注释\n\n```\n/**\n * returns the last day of the month\n * @return the last day of the month\n */\npublic Date getLastDayOfMonth(Date date) {\n    Calendar calendar = new GregorianCalendar();\n    calendar.setTime(date);\n    calendar.set(Calendar.DAY_OF_MONTH, calendar.getActualMaximum(Calendar.DAY_OF_MONTH));\n    return calendar.getTime();\n}\n复制代码\n```\n\n这是典型的废话注释，读代码时代码本身就能很好的表达具体的含义，我们完全不需要看注释，并且注释也不会给我们提供更多有效的信息。无用注释或许是零注释的另一个极端，我们担心自己写的代码被人所吐槽，于是尽可能去补全注释，当你为 getLastDayOfMonth() 补一段 get last day of month 的注释时，恭喜你，你得到了双倍的代码。\n\n#### 代码优于注释\n\n> \"Comments Do Not Make Up for Bad Code\"\n> \\-- Robert C.Martin 《Clean Code》\n> 译：注释不能美化糟糕的代码\n\n当需要为一段代码加上注释时，说明代码已经不能很好的表达意图，于是大家开始为这段代码添加注释。Robert C.Martin在 Clean Code 中提出一个观点：注释不能美化糟糕的代码。能用代码表达的直接用代码表达，不能用代码表达的，你再想想，如何能用代码表达。\n复杂的代码最直接的表现就是不够直观、难以理解，加上注释后往往会清晰很多，但你是愿意看这段代码\n\n```\n// 判断是否活跃用户\nif((customer.getLastLoginTime().after(dateUtils.minusDays(new Date(),15)) && customer.getCommentsLast30Days() > 5)\n    || orderService.countRecentDaysByCustomer(customer,30) > 1)\n复制代码\n```\n\n还是这段代码？\n\n```\nif(customer.isActive())\n复制代码\n```\n\n糟糕代码的存在，通常是我们写注释的常见动机之一。这种试图粉饰可读性差的代码的注释称之为『拐杖式注释』，即使大名鼎鼎的JDK，也存在这样的拐杖式注释。\n\n```\npublic synchronized void setFormatter(Formatter newFormatter) {\n    checkPermission();\n    // Check for a null pointer\n    newFormatter.getClass();\n    formatter = newFormatter;\n}\n复制代码\n```\n\n这是取自JDK java.util.logging.Handler类的setFormatter方法，作者为了不让空指针异常下传，提前做一次空指针检查。没有这段注释我们完全不知道游离的这句 newFormatter.getClass() 到底要做什么，这段注释也充分表达了作者自己也知道这句代码难以理解，所以他加上了注释进行说明。但我们完全可以用 Objects.requireNonNull() 来进行替代。同样的代码作用，但可读性可理解性大不一样，JDK里的这段代码，确实让人遗憾。\n\n#### 注释否定论\n\n> \"If our programming languages were expressive enough, or if we had the talent to subtly wield those languages to express our intent, we would not need comments very much—perhaps not at all.\"\n> \\-- Robert C.Martin 《Clean Code》\n> 译：若编程语言足够有表达力，或者我们长于用这些语言来表达意图，就不那么需要注释--也许根本不需要\n\n通过代码进行阐述，是注释否定论的核心思想。当你花功夫来想如何写注释，让这段代码更好的表达含义时，我们更应该重构它，通过代码来解释我们的意图。每一次注释的编写，都是对我们代码表达能力上的差评，提升我们的归纳、表达、解释能力，更优于通过注释来解决问题。当代码足够优秀时，注释则是非必须的。并且需求在不断调整，代码一定会随之变动，但注释可能慢慢被人遗忘，当代码与注释不匹配时，将是更大的灾难。\n\n### 软件设计的乌托邦\n\n曾经我的确对优秀的代码不断钻研，对代码本身所蕴含的能量无比坚信。如同当科学代替鬼神论走上历史舞台时，即使存在有科学解释不了，我们依然坚信只是科学还需要发展。当代码别人无法理解时，我会认为是我表述不够精准，抽象不够合理，然后去重构去完善。\n有一次给老板review代码，当时老板提出，“你的代码缺缺少注释”，我说不需要注释，代码就能自解释。于是老板现场读了一段代码，“query-customer-list 查询客户”、“transfer-customer-to-sales 分发客户到销售”、“check-sales-capacity 检查销售库容”，每一个类每一个函数，一个单词一个单词往外蹦时，你会发现好像确实都能读懂，于是老板回了一个“好吧”。\n\n#### 美丽的乌托邦\n\n> \"\'good code is self-documenting\' is a delicious myth\"\n> \\-- John Ousterhout《A Philosophy of Software Design》\n> 译：‘好的代码自解释’是一个美丽的谎言\n\n在软件设计中，总有一些软件工程师所坚信的诗和远方，有的是大洋彼岸的美好国度，有的或许是虚无缥缈的理想乌托邦。John Ousterhout教授在 A Philosophy of Software Design 中提到一个观念，‘好的代码自解释’是一个美丽的谎言。\n我们可以通过选择更好的变量名，更准确的类与方法，更合理的继承与派生来减少注释，但尽快如此，我们还是有非常多的信息无法直接通过代码来表达。这里的信息，或许不单单只是业务逻辑与技术设计，可能还包括了我们的观感，我们的体验，我们的接纳程度以及第一印象带来的首因效应。\n\n### 好代码的最佳僚机\n\n> You might think the purpose of commenting is to \'explain what the code does\', but that is just a small part of it.The purpose of commenting is to help the reader know as much as the writer did.\n> 译：你可能以为注释的目的是“解释代码做了什么”，但这只是其中很小一部分，注释的目的是尽量帮助读者了解得和作者一样多\n> \\-- Dustin Boswell《The Art of Readable Code》\n\n如同John Ousterhout教授一样，The Art of Readable Code 的作者Dustin Boswell，也是一个坚定的注释支持者。与Robert C.Martin类似，Dustin Boswell同样认为我们不应该为那些从代码本身就能快速推断的事实写注释，并且他也反对拐杖式注释，注释不能美化代码。\n但Dustin Boswell认为注释的目的不仅解释了代码在做什么，甚至这只是一小部分，注释最重要的目的是帮助读者了解得和作者一样多 。编写注释时，我们需要站在读者的角度，去想想他们知道什么，这是注释的核心。这里有非常多的空间是代码很难阐述或无法阐述的，配上注释的代码并非就是糟糕的代码，相反有些时候，注释还是好代码最棒的僚机。\n\n#### 更精准表述\n\n> There are only two hard things in Computer Science: cache invalidation and naming things.\n> \\-- Phil Karlton\n> 译：计算机科学中只有两个难题：缓存失效和命名\n\nMartin Fowler在他的 TwoHardThings 文章中引用了Phil Karlton的一段话，命名一直都是一件非常难的事情，因为我们需要将所有含义浓缩到几个单词中表达。很早之前学Java，接触到很长的类名是ClassPathXmlApplicationContext。可能有人认为只要能将含义准确地表达出来，名字长一些无所谓。那如果我们需要有一段处理有关“一带一路”的内容，那我们的代码可能是这样的\n\n```\npublic class TheSilkRoadEconomicBeltAndThe21stCenturyMaritimeSilkRoad {\n\n}\n复制代码\n```\n\n他非常准确的表达了含义，但很明显这不是我们期望的代码。但如果我们辅以简单的注释，代码会非常清晰，说明了简称，也说明了全意，表述更精准。\n\n```\n/**\n * 一带一路\n * 丝绸之路经济带和21世纪海上丝绸之路\n */\npublic class OneBeltOneRoad {\n\n}\n复制代码\n```\n\n#### 代码层次切割\n\n函数抽取是我们经常使用且成本最低的重构方法之一，但并非银弹。函数并非抽得越细越好，如同分布式系统中，并非无限的堆机器让每台机器处理的数据越少，整体就会越快。过深的嵌套封装，会加大我们的代码阅读成本，有时我们只需要有一定的层次与结构帮助我们理解就够了，盲目的抽取封装是无意义的。\n\n```\n/**\n * 客户列表查询\n */\npublic List queryCustomerList(){\n    // 查询参数准备\n    UserInfo userInfo = context.getLoginContext().getUserInfo();\n    if(userInfo == null || StringUtils.isBlank(userInfo.getUserId())){\n        return Collections.emptyList();\n    }\n    LoginDTO loginDTO = userInfoConvertor.convertUserInfo2LoginDTO(userInfo);\n    // 查询客户信息\n    List<CustomerSearchVO> customerSearchList = customerRemoteQueryService.query(loginDTO);\n    Iterable<CustomerSearchVO> it = customerSearchList.iterator();\n    // 排除不合规客户\n    while(it.hasNext()){\n        CustomerSearchVO customerSearchVO = it.next();\n        if(isInBlackList(customerSearchVO) || isLowQuality(customerSearchVO)){\n            it.remove();\n        }\n    }\n    // 补充客户其他属性信息\n    batchFillCustomerPositionInfo(customerSearchList);\n    batchFillCustomerAddressInfo(customerSearchList);\n}\n复制代码\n```\n\n其实细看每一处代码，都很容易让人理解。但如果是一版没有注释的代码，可能我们会有点头疼。缺少结构缺少分层，是让我们大脑第一感观觉得它很复杂，需要一次性消化多个内容。通过注释将代码层次进行切割，是一次抽象层次的划分。同时也不建议大家不断去抽象私有方法，这样代码会变得非常割裂，并且上下文的背景逻辑、参数的传递等等，都会带来额外的麻烦。\n\n#### 母语的力量\n\n其实上述例子，我们更易阅读，还有一个重要的原因，那就是母语的力量。我们天然所经历的环境与我们每天所接触到的事物，让我们对中文与英文有完全不一样的感受。我们代码的编写本质上是一个将我们沟通中的“中文问题”，翻译成“英文代码”来实现的过程。而阅读代码的人在做得，是一件将“英文代码”翻译成“中文表述”的事情。而这之中经过的环节越多，意思变味越严重。\n\n```\nTaskDispatch taskDispatch = TaskDispatchBuilder.newBuilder().withExceptionIgnore().build();\ntaskDispatch\n        // 外贸信息\n        .join(new FillForeignTradeInfoTask(targetCustomer, sourceInfo))\n        // 国民经济行业、电商平台、注册资本\n        .join(new FillCustOutterInfoTask(targetCustomer, sourceInfo))\n        // 客户信息\n        .join(new FillCustomerOriginAndCategoryTask(targetCustomer, sourceInfo))\n        // 客户扩展信息\n        .join(new FillCustExtInfoTask(targetCustomer, sourceInfo))\n        // 收藏屏蔽信息\n        .join(new FillCollectStatusInfoTask(targetCustomer, sourceInfo, loginDTO()))\n        // 详情页跳转需要的标签信息\n        .join(new FillTagInstanceTask(targetCustomer, sourceInfo, loginDTO()))\n        // 客户信息完整度分数\n        .join(new FillCustomerScoreTask(targetCustomer, sourceInfo))\n        // 潜客分层完整度\n        .join(new FillCustomerSegmentationTask(targetCustomer, sourceInfo))\n        // 填充操作信息\n        .join(new FillOperationStatusTask(targetCustomer, sourceInfo, loginDTO))\n        // 认证状态\n        .join(new FillAvStatusTask(targetCustomer, loginDTO))\n        // 客户地址和组织\n        .join(new FillCompanyAddressTask(targetCustomer, loginDTO))\n        // 违规信息\n        .join(new FillPunishInfoTask(targetCustomer, sourceInfo))\n        // 填充客户黑名单信息\n        .join(new FillCustomerBlackStatusTask(targetCustomer, sourceInfo))\n        // 填充客户意愿度\n        .join(new FillCustIntentionLevelTask(targetCustomer, sourceInfo));\n        // 执行\n        .execute();\n复制代码\n```\n\n这是一段补齐客户全数据信息的代码，虽然每一个英文我们都看得懂，但我们永远只会第一眼去看注释，就因为它是中文。并且也因为有这些注释，这里非常复杂的业务逻辑，我们同样可以非常清晰的了解到它做了哪些，分哪几步，如果要优化应该如何处理。这里也建议大家写中文注释，注释是一种说明，越直观越好。\n\n### 注释的真正归属\n\n#### 复杂的业务逻辑\n\n```\n// Fail if we\'re already creating this bean instance:\n// We\'re assumably within a circular reference.\nif (isPrototypeCurrentlyInCreation(beanName)) {\n    throw new BeanCurrentlyInCreationException(beanName);\n}\n// Check if bean definition exists in this factory.\nBeanFactory parentBeanFactory = getParentBeanFactory();\nif (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n    // Not found -> check parent.\n    String nameToLookup = originalBeanName(name);\n    if (args != null) {\n        // Delegation to parent with explicit args.\n        return parentBeanFactory.getBean(nameToLookup, args);\n    }\n    else {\n        // No args -> delegate to standard getBean method.\n        return parentBeanFactory.getBean(nameToLookup, requiredType);\n    }\n}\n复制代码\n```\n\n这是Spring中的一段获取bean的代码，spring作为容器管理，获取bean的逻辑也非常复杂。对于复杂的业务场景，配上必要的注释说明，可以更好的理解相应的业务场景与实现逻辑。\n截取自：\norg.springframework.beans.factory.support.AbstractBeanFactory#doGetBean\n\n#### 晦涩的算法公式\n\n```\n/**\n * Returns the value obtained by reversing the order of the bits in the\n * two\'s complement binary representation of the specified {@code long}\n * value.\n */\npublic static long reverse(long i) {\n    // HD, Figure 7-1\n    i = (i & 0x5555555555555555L) << 1 | (i >>> 1) & 0x5555555555555555L;\n    i = (i & 0x3333333333333333L) << 2 | (i >>> 2) & 0x3333333333333333L;\n    i = (i & 0x0f0f0f0f0f0f0f0fL) << 4 | (i >>> 4) & 0x0f0f0f0f0f0f0f0fL;\n    i = (i & 0x00ff00ff00ff00ffL) << 8 | (i >>> 8) & 0x00ff00ff00ff00ffL;\n    i = (i << 48) | ((i & 0xffff0000L) << 16) |\n        ((i >>> 16) & 0xffff0000L) | (i >>> 48);\n    return i;\n}\n复制代码\n```\n\n这是JDK中Long类中的一个方法，为reverse方法添加了足够多的注释。对于几乎没有改动且使用频繁的底层代码，性能的优先级会高于可读性。在保证高效的同时，注释帮助我们弥补了可读性的短板。\n截取自java.lang.Long#reverse\n\n#### 不明所以的常量\n\n```\n/**\n * The bin count threshold for using a tree rather than list for a\n * bin.  Bins are converted to trees when adding an element to a\n * bin with at least this many nodes. The value must be greater\n * than 2 and should be at least 8 to mesh with assumptions in\n * tree removal about conversion back to plain bins upon\n * shrinkage.\n */\nstatic final int TREEIFY_THRESHOLD = 8;\n复制代码\n```\n\n这是JDK中HashMap的一个常量因子，记录由链表转向红黑树的链表长度阈值，超过该长度则链表转为红黑树。这里记录了一个8，不仅记录了该常量的用途，也记录了为什么我们定义这个值。经常我们会发现我们代码中存在一个常量等于3、等于4，有时我们不知道这些3和4是干什么的，有时我们不知道为什么是3和4。\n截取自java.util.HashMap#TREEIFY\\_THRESHOLD\n\n#### 意料之外的行为\n\n```\nfor (int i = 0; i < 3; i++) {\n    // if task running, invoke only check result ready or not\n    Result result = bigDataQueryService.queryBySQL(sql, token);\n    if (SUCCESS.equals(result.getStatus())) {\n        return result.getValue();\n    }\n    Thread.sleep(5000);\n}\n复制代码\n```\n\n代码及注释所示为每5秒check一下是否有结果返回，远程服务将触发与获取放在了一个接口。没有注释我们可能认为这段代码有问题，代码表现的含义更像是每5秒调用一次，而非每5秒check一次。为意料之外的行为添加注释，可以减少对代码的误解读，并向读者说明必要的背景及逻辑信息。\n\n#### 接口对外API\n\n```\n/**\n * <p>Checks if a CharSequence is empty (\"\"), null or whitespace only.</p>\n * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n * StringUtils.isBlank(null)      = true\n * StringUtils.isBlank(\"\")        = true\n * StringUtils.isBlank(\" \")       = true\n * StringUtils.isBlank(\"bob\")     = false\n * StringUtils.isBlank(\"  bob  \") = false\n *\n * @param cs  the CharSequence to check, may be null\n * @return {@code true} if the CharSequence is null, empty or whitespace only\n */\npublic static boolean isBlank(final CharSequence cs) {\n    final int strLen = length(cs);\n    if (strLen == 0) {\n        return true;\n    }\n    for (int i = 0; i < strLen; i++) {\n        if (!Character.isWhitespace(cs.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n复制代码\n```\n\n我们经常使用的StringUtils工具类中的isBlank方法，写了非常详情的注释，不仅包括方法的逻辑，入参的含义，甚至还包括具体示例。我们平常定义的二方库中的HSF、HTTP接口定义，同样需要有清晰详尽的注释，这里的注释甚至经常会多过你的代码。\n截取自org.apache.commons.lang3.StringUtils#isBlank\n\n#### 法律文件信息\n\n```\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n复制代码\n```\n\n与法律相关的注释，在开源软件库中较经常遇到。涉及到一些版权及著作声明时，我们需要在源文件顶部放置法律相关注释。当然，我们不需要将所有法律信息写到注释中，如例子中的跳链，引用一份标准的外部文档，会是一个更好的选择。\n\n### 写在最后\n\n注释并不会妨碍你写出优雅简洁的代码，它只是程序固有的一部分而已。我们不用过分在意我们的代码是否可以脱离注释，也不需要强调因为我们的代码符合什么原则，满足什么约定，所以代码是优秀的注释是冗余的。代码是一门艺术，并不会因为满足三规九条它就一定完美，因为艺术，是不可衡量的。\n参阅书籍\n《A Philosophy of Software Design》：[www.amazon.com/-/zh/dp/173…](https://link.juejin.cn?target=https%3A%2F%2Fwww.amazon.com%2F-%2Fzh%2Fdp%2F173210221X%2Fref%3Dsr_1_1 \"https://www.amazon.com/-/zh/dp/173210221X/ref=sr_1_1\")\n《Clean Code》：[baike.baidu.com/item/代码整洁之道…](https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E4%25BB%25A3%25E7%25A0%2581%25E6%2595%25B4%25E6%25B4%2581%25E4%25B9%258B%25E9%2581%2593%2F9226259 \"https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/9226259\")\n《The Art of Readable Code》：[github.com/niexiaolong…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fniexiaolong%2Fniexiaolong.github.io%2Fblob%2Fmaster%2Fthe-art-of-readable-code.pdf \"https://github.com/niexiaolong/niexiaolong.github.io/blob/master/the-art-of-readable-code.pdf\")\n\n《你好，低代码》制造业最佳实践系列\n\n深度解读低代码平台，走近宜搭，了解低代码在企业数字化中的实践和经验。\n\n手把手教学库存管理系统，商品有序管理，库存精确计算等。','2022-06-23 09:54:00',0000000002,'阅读',4),(0000000042,'面试自我介绍5句话公式','想进入大厂必不可少的就是面试了，面试就是一个让面试官快速的了解你，并相信你有足够的能力可以胜任这份工作的过程，一份好的自我介绍可以让面试官对你眼前一亮，方便后面的问题展开。','马上进入三月份，各个大厂的春招也陆续开了，正是大家所谓的“金三银四”的时期。\n\n想进入大厂必不可少的就是面试了，面试就是一个让面试官快速的了解你，并相信你有足够的能力可以胜任这份工作的过程，一份好的自我介绍可以让面试官对你眼前一亮，方便后面的问题展开。\n\n也有很多学妹也问过我，应该怎么进行自我介绍呢？一开口就紧张又应该怎么办？\n\n我自己作为面试官，今天就来和大家聊一聊应该怎么自我介绍才能用简洁精炼的语言介绍自己。\n\n**自我介绍**大家可以参考这个模板：**我是谁+从哪里来+我做过什么+有什么成绩+为什么能胜任。**\n\n给大家举个栗子：面试官你好，我叫敖丙，18年毕业于毕业于XX大学电子信息工程专业。之前任职于XX公司，担任软件开发工程师一职，在职期间主要负责电商活动相关的项目研发，对线上问题处理、性能调优、线程并发能问题都有自己的理解，对行业相关业务的研发设计流程也十分熟悉。因此决定面试**咱们**（一个小心机哈哈～）公司的电商软件研发岗位，希望能获得此次机会，谢谢。\n\n这个介绍说清楚了自己的基本情况，阐述了自身优势、亮点，表达了求职动机，体现了求职意愿， 我觉得是个比较好的自我介绍。\n\n不过话又说回来，大家应该怎么准备自己的自我介绍呢？又应该如何克服面试中的紧张呢？\n\n### 三个小tips：\n\n1.  把自我介绍写下来，做到言简意赅，语言精炼，个人觉得一分钟内能说完最好，多了面试官也记不住。\n\n2.  不断练习，大声朗读，记得要有情感和抑扬顿挫，不要像背的。\n\n3.  拿手机录下来反复看自己的自我介绍，直到完美。\n\n\n### 一定要注意的点：\n\n*   要有亮点：别说一些跟工作无关的废话，比如热爱运动，性格开朗啥的，相信我面试官不关心这些的\n\n*   不要做简历复读机：大量复述那些简历中有的技能和经验，那就是在浪费时间\n\n*   一定要体现个人经历和岗位的相关性（这点非常重要）\n\n    温馨提示：根据不同行业的公司准备不同的简历和自我介绍，胜率会更高哦。\n\n\n我是敖丙，我会在求职季不断更新求职面试相关的经验和经历，大家有想知道关于面试的问题也欢迎积极在评论区留言～我们下期见～','2022-02-23 01:16:00',0000000001,'阅读',4),(0000000043,'如何在繁重的工作中持续成长？','在加班文化盛行的互联网文化中，很多开发者为自己的个人成长感到迷茫。这篇文章将会从我的个人经历出发，从打破成长的误区、如何高效的利用时间、以及坚持沉淀和写作三个方面介绍，如何在繁重的工作中也可以做到持续成长。','在本届稀土技术大会上，我做了一次关于成长的分享，以下是分享的全文～\n\n在加班文化盛行的互联网文化中，很多开发者为自己的个人成长感到迷茫。这篇文章将会从我的个人经历出发，从打破成长的误区、如何高效的利用时间、以及坚持沉淀和写作三个方面介绍，如何在繁重的工作中也可以做到持续成长。\n\n# 认知：打破成长误区\n\n首先，我想跟大家谈几个关于成长的认知。包括我在我的职业生涯的前期，以及我身边的一些同事和读者，对成长的一些误区。\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e075b4b46dc148ea9ad703ff9f435e6b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n你觉得自己处在下面哪个状态里面呢？\n\n如果你不知道该做点什么，只是机械的重复着每天的工作，那很有可能处在了迷茫期。\n\n如果你感觉做什么事都什么动力，上班的时候就想着下班，那你可能处在了舒适区。\n\n迷茫和舒适可能都会让我们处于一个停滞不前的状态，最好的状态就是两者之间，持续提升自己、持续保持成长。这个时候有的同学可能会说了，工作真的太忙了，真的没时间顾及个人的成长啊。\n\n## 误区1：个人成长和工作相互冲突\n\n这就是我想说的第一个误区，很多同学觉得个人的成长和工作互相冲突的。其实恰恰相反，因为工作和成长本身就是密不可分的。比如：\n\n*   业务能力：对工作中业务的深入理解，可以让你在大部分没有深入理解业务的同事里面脱颖而出，甚至可以让你成为某个领域的专家，这就是最直接的成长。\n\n*   编码能力：有的同学可能会去刻意的学习一些，看起来很高深的算法去提升编码能力。其实仔细想一想，你能够在工作里面把你的业务代码重构的更清晰一点，或者说在开始编写业务代码之前，就把你的代码架构，设计的更合理一点，这可能是个更好的选择。\n\n*   编码技巧：有的同学可能会去想做一些开源库的源码的解读分析，希望从里面能获得一些编码技巧，其实在工作中能把平时的 Code Review 做好，你也可能会从很多经验丰富的同事中获得很多收获，而且这些收获都是可以直接运用到工作里面的。\n\n*   影响力：在平时工作中的，各项技术方案的设计和评审也可以无形中提升你在团队内的影响力，当然以上的前提是，你一定要认真对待。\n\n所以我一直认为个人的成长有很大一部分都来源于工作，关键是你怎么看待成长和工作的关系。切忌为了所谓了个人成长而怠慢了平时的工作，**从工作中谋求成长才是最佳的选择**。\n\n## 误区2：做自己没了解过的事情才是成长\n\n第二个误区：很多同学觉得一定要做自己没了解过的事情才是成长。其实在平时的工作中，只是被动执行着一件事情，和将一件事情做到极致，最终取得的结果是完全不同的。**与其浪费一些时间去了解一些可能未来不可能在工作中用到的技术，为什么不能选择把现在手上负责的事情做到极致呢？**\n\n## 误区3：学的东西越多，成长越快\n\n第三个误区：和前面的问题很类似，学的东西越多一定成长越快吗？实际上往往会起到相反的作用。\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d0f0423e9564c7791d2cf61a7bb72c8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n一个人的脑容量和记忆力是有限的，拓宽自己的眼界和知识广度是完全没问题的，这可以让我们在思考问题的时候思维更加活跃，但是拓宽知识广度的前提一定是你已经有了一项非常擅长的方向，前面的 15% 带给你的收益要比后面的 85% 大很多。\n\n那么怎么才能让我们有限的脑容量和记忆力发挥出更大的作用呢？选择合适的方向是最重要的。\n\n以我个人的经验来看，**一定要选择你工作中可能会用到的方向，或者说可以落地到工作中的方向**。比如，你想要研究性能优化，你现在的工作是 TOB 方向，那么一定要把重点放在研究 PC 场景下的性能优化。如果你想研究 TS，那一定要争取把工作中项目的 TS 覆盖率和编写质量提升上去。\n\n这样，你的个人成长才能更好的融入到工作中，才可以让你受益最大化。大家一定要明白这一点，否则你可能付出再多的努力都是徒劳的。\n\n# 实施：如何高效的利用时间\n\n在前面，我们纠正了几个关于成长的误区，但是当我们满怀期望的去投入到我们选择的方向中去的时候，可能就要面临一个新的问题。时间不够用啊，特别是在互联网公司上班的同学，因为大环境的影响可能工作都非常的卷，怎么才能高效的利用时间呢？\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a31fd8fa864d42c48c37eb58ed329ef4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n我一直在坚持对外输出一些技术文章和分享，在社区也比较活跃，所以我经常听到读者对我提这样的问题：\n\n> 为什么字节工作这么忙，你还能持续输出这么多内容？\n\n你可能会觉得，我是不是可能会在工作中偷懒，或者说放水呢？我身边比较熟悉我的同事可能都知道，我在工作中基本上也是最卷的那一个，我也经常听到同事对我这样的评价：\n\n> 感觉他可能是晚上不睡觉。\n>\n> 为什么感觉他的一天可以当两天用？\n\n我当然不可能不睡觉啊，我更没有“时间转换器”这样的神器。人的一天只有24小时，我其实只是“时间管理”方面做的好一点而已。\n\n## 关于时间的困惑\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/140082eeaf0244f58aad527db9647ad6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n为什么做好“时间管理”这么重要呢，我们先来看看下面几个场景，大家是不是也有过这样的想法？\n\n*   当我们面前有一大堆需要处理的事情的时候，很多同学第一想法就是先把最简单的完成了\n\n    *   混乱型，缺乏对时间和精力最基本的安排\n\n*   有时候我们从早到晚忙了一天，很累，但是又感觉自己什么也没做\n\n    *   缺乏对事情优先级的判断和复盘，会让我们丧失对工作的成就感\n\n*   还没有到 DeadLine，再躺一会吧\n\n    *   拖延症嘛，确知道我要干什么，就是提不起动力\n\n其实，如果我们不去对时间做一些思考，不引入一些适合自己的方法的话，上面这些问题我们是很难规避掉的。\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b65cb05cfb94850a52e3f98a371b663~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n这可以用我们物理学里面非常重要的一条定律来解释，就是熵增定律。\n\n> 在一个**孤立**系统里，如果没有**外力**做功，其总混乱度（即熵）会不断增大。\n\n因为事情总是向着熵增的方向发展的，所以所有符合熵增的，都非常容易和舒适的。比如我们喜欢做简单的事情、不喜欢把事情安排的很有序；喜欢拖延、不喜欢自律。但是，熵增定律也是一直被认为是让全宇宙都很绝望的定律，因为持续的熵增会让事物走向衰退。这个概念往大了讲，就是地球必定会走向灭亡。回到我们现实生活中来，就是人一定会在熵增的过程中走向衰退。所以薛定谔在他著名的生物学著作《生命是什么》里面也有提到过：\n\n> 人活着就是在对抗熵增定律。\n\n怎么对抗呢？其实从它的概念里面我们就可以知道，**想要避免熵增，光靠自然的变化是很难的，我们必须引入一些外力。**\n\n## 常见的时间管理法\n\n回到时间管理，有哪些外力呢？我们可以先来看几个方法论。\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d63236c615dc4a4e87121f1c8ed863a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   **GTD** **时间管理法**：通过记录的方式把头脑中的各种事情移出来，然后整理安排自己去执行。它的核心是围绕 收集、清理、组织、回顾、执行，五个点来管理时间：\n\n    *   收集：所有需要消耗时间的事情收集到一个地方，比如说我们看到了一篇文章，现在没时间看，要先收藏起来；老板临时安排了一件事情，但是现在有其他更高优的事情，要先记录下来。这都是收集的过程。\n    *   清理：这个过程其实就是清理我们的收集箱，因为收集的过程往往都是很匆忙的，不会经过过多的思考。我执行之前很难从一大堆收集来的事情里面去挑出来现在要做的那一件。所以要有一个定期清理的过程。\n    *   组织：清理出来的事项，我们需要把它们进行更细粒度的安排，比如较大的事项我们要进行合理拆分。根据事情不同的优先级和重要程度，我们要把它们分配到不同的日程里面去。\n    *   执行：根据我们之前已经组织好的事项按照具体的时间和地点去执行就好了。\n    *   复盘：定期进行回顾检查，因为计划肯定赶不上变化，我们要随时对我们已经安排好的事项进行调整。\n\n*   **三只青蛙时间管理法：** 如果现在有三只青蛙，先把最大最丑的那只吃掉。也就是说当你面临三个重要任务的时候，先做更艰巨、更重要的那一个。这个其实本质上就是对事情优先级的管理。\n\n*   **番茄时间管理法**：把执行的时间划分为多个番茄时间。一个番茄时间包含两个部分：25 分钟的工作学习和 5 分钟的休息。当每四个番茄时间之后呢，可以暂时停止一下工作，进行一次较长时间的休息，大约 15 到 30 分钟。这里有一个很重要的点，就是一个番茄时间是不可再分割的。这个法则可以帮助我们专注的执行，同时也能做到张弛有度。\n\n**时间管理的方法论还有很多，但是大家一定要避免进行生搬硬套**。每个人可能实际情况都不一样，适合的方法也不一样，比如我就觉得 GTD 太复杂了，所以我根据自己的实际情况对它进行了一些删减，同时在不同的步骤里又融入了其他的方法。我把它分为记录、整理、执行三个步骤。\n\n## 记录：提醒事项\n\n第一步，是记录。我会将我所有现在不能立刻去做，但是需要做的事情记录下来。你可以把它类比于 GTD 里面的收集阶段，但是又不完全一样。\n\n**我在记录的时候会明确的将这件事情打上标签**，比如：\n\n*   **工作执行上的**：老板临时安排了一件什么工作、昨天评审了一个需求；\n\n*   **技术写作上的**：刚刚收到邮件，Chrome 更新了 104 版本，要研究一下有哪些策略变化；\n\n*   **日常生活上的**：酱油快吃完了，下次去超市买一瓶。\n\n按照标签归类可以让我更清晰的知道我需要在何时何地去完成这些事情，会让我后续的步骤更加轻松。当然，我实际的标签要比这个更复杂一点，每个人可能需要根据自己的实际情况去进行不同的归类。\n\n**如果这件事情有明确要完成的时间，一定要挂上 DeadLine 的时间提醒**。注意这里不是要执行这件的时间，而是这件事情完成的截止时间，这可以让我们在后续的优先级判定中更轻松。\n\n> 注意：执行时间需要根据我们当前已有的事项安排以及这件事情的紧急重要程度综合判定，而截止时间往往是很明确的。\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4050f32b86b7405ab330ab1f23d504ed~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n那记录这一步用到的工具呢，其实我们的需求非常明确：\n\n*   有一个 TODO List 功能\n\n*   可以对每条 TODO 进行标签归类\n\n*   可以有时间提醒功能\n\n*   可以跨平台，在 PC、App 上都可以同步操作\n\n之前我也尝试了很多个 App，最后，我发现苹果的提醒事项简直是为我量身定做的，可以满足上面我提到的所有要求，而且功能非常简洁，就只有我要的这几个功能。\n\n好，现在我们已经把所有需要做的事情记录下来了，我们要在什么地点什么时间把这些事情完成掉呢？之前张一鸣在他的一次采访里曾经有这样一句话，我印象非常深刻：\n\n> 更大的效率来自于重要事情上做得好，而不是在处处做得好。\n\n事情是永远做不完的，但是时间是恒定有限的，我们在提醒事项里记录的事项会越来越多，下面最重要的就是如何在有限的时间里把这其中最重要的事情完成掉，以取得最大的收益了。\n\n## 整理：优先级 & 制定计划\n\n下一步是整理，也就是把我记录的事项按照优先级和重要程度安排到具体的执行计划中去。这一步实际上是我对 GTD 中清理和组织两个步骤的融合。\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ab3d2ba12dd455bb11e6aca8d9e5163~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n这里用到了一个非常重要的法则，就是四象限法则，我们根据事情的重要和紧急程度分成四类：\n\n*   **重要且紧急的事情**：如果我现在没有其他重要紧急的事情，我一般会选择立刻去做。如果现在没时间的话，那我就会把它安排到最近的时间中去。\n\n*   **重要不紧急的事情**：既然事情很重要，我们一定要把它做好。如果事情比较大，我们可以把它拆分成一些小的任务，有计划的安排到日程中去。这里我可能会用到两个工具，第一个是需求管理工具，它可以让帮助我更好的进行任务拆分、团队协作、跟进进度等等，在这一步实际上就完成了从代办事项到需求管理的转换，相信每个公司都有自己的需求管理工具，你们也可以自己选择；第二个是日程管理工具，它可以更细粒度的安排我们在什么时间执行什么事情，避免事情过多的时候不知道该做什么，比如字节的同学大部分应该都会用飞书的日程管理，**它不应该只作为一个约会的工作，更建议大家把自己的事情和计划也记录上去。**\n\n*   **不重要但紧急的事情**：这种事情，我们可以把它让给别人去做，对你来讲可能不重要，对其他人来讲可能就是一次机会，所以这里其实也是想说，不一定所有的事情都要亲力亲为，其他人不一定会比你完成的差，或者说**在你有其他事情并行的前提下，做对 “取舍” 是很重要的**。\n\n*   **不重要也不紧急的事情：** 这种事干脆连计划也不要做了，什么时候前面三种事没有了，再拿出来看这些事情。另外也不建议就把它们放在待办事项本来的位置，因为随着时间的积累这种堆积会让你的记录很难整理。建议把它们单独归置到一个或多个归档区域，下次在做整理的时候也要拿出来看看，因为不紧急的事情随着时间的推移也有可能变得紧急。\n\n但是，计划永远赶不上变化，你可能已经安排好了你一天的规划，但是突然接到了其他的事情，这是非常正常的，这种场景基本上也发生在我每天的生活工作里面，我相信大家也都一样。\n\n结果其实只有两个，做还是不做。如果做，是现在做，还是以后做。我们同样可以用四象限法则思考：\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c9c6c95a1094e09b24ae75b8faf9a72~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n**如果是不重要也不紧急的事情，现在就直接和对方说 No，如果事情很重要，但是不紧急，你依然可以现在和对方说 NO，但是你可以和对方明确 DeadLine，然后将它记录到待办事项中去**。我见过很多同学不太会拒绝，可能遇到了临时的事情立刻就去做了，实际上你现在做和以后做这件事可能没有什么区别，对方可能也不着急，只是需要你一个排期，但是这可能会导致你现在高优先级的事情 Delay。这也有可能是导致你四处救火，但是一天下来却又觉得什么也没干的原因。\n\n如果是重要紧急的事情，那需要和你现在在做的事情对比一下，**如果确实比现在的事情优先级要高，就乐观的面对计划调整就好了，你要明白，这依然只是你在在重复执行你的 “整理” 这个过程**。还是那句话，事情是做不完的，但是时间是有限的，我们只要按照我们的标准对事情进行记录、整理、执行，不管是之前计划好的事情，还是临时新增的事情，根据我们的方法最终都可以被安排到具体的计划中。严格执行我们既定的标准，乐观的面对计划调整。\n\n## 执行：张弛有度的专注\n\n最后，就是执行阶段了。对我而言，番茄时间管理法还是很不错的，只不过我可能会适当的调整一个番茄钟的时间，我会把一个番茄钟的时间调的更长一点，这个因人而异，大家可以多尝试一下，找到自己更舒服的时间。\n\n对于短时间休息，方式有很多种。比如，远眺放松一下眼睛属于休息、站立活动一下脊椎属于休息，回复一些消息也属于休息。如果只是坐在座位上刷刷手机，这种休息可能没有什么意义。长时间休息，我会选择处理一些临时插件来的事情、包括重新进行记录、安排的步骤、或者解答一些问题、做一些 CodeReview 等等。\n\n番茄钟有个非常重要的特点，就是**执行时一定要保持专注，如果不是什么特别重要、紧急的事情一定不能打断这个种**，尽量到达休息时间再去处理其他事情，养成这样的习惯，就算时间很少，执行一件事的效率也会非常高。\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/144bae01573f466a8fedd30a6f5c6e0b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n在工具上，市面上有非常多使用番茄时间管理法的工具，做的花里胡哨的，选择使用也是因人而异。如果你自控能力较差，你可以选择一个帮你自动锁屏、屏蔽其他应用的 App。不过我更倾向于更简洁一点的，只需要带有番茄钟和休息时间的倒计时提醒以及简单的统计功能就可以了。\n\n以上就是我的时间管理方法，其实可以看作是一个精简版的 GTD，我把 GTD 中的清理、组织和复盘进行了合并。同时在每个步骤里根据我的个人情况融入了一些其他方法。大家也可以根据自己的实际情况，磨合出属于自己的一套方法。现在方法有了，如何能把这套方法实施下去，做到知行合一，就很关键了。我这里也有一些自己总结出的一些技巧分享给大家。\n\n## 技巧：找出事情的交集\n\n我们会在记录的阶段堆积出非常多需要做的事情，虽然是一件一件记的，但是没必要一件一件的去执行。**我们只要在整理阶段更好的找到这些事情的交集，就可以更高效的利用有限的时间。**\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d0ce369fe9942f2ab9dddbee1bf6aa9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n比如，我们在写作的 tag 里记录了最近要输出一篇技术文章，另外在工作的 tag 里记录了系统稳定性很差，需要进行一次优化。那么两者的交集就可以是：研究并落地系统稳定性方案，并将实践经验整理成一篇技术文章。\n\n## 技巧：高效沟通\n\n在现阶段的工作中，和别人交流沟通，会占用掉我非常大一部分时间。我们需要评需求、跟进度、推专项、解答问题等等，如果这些事情都要靠打字来完成，效率是非常低的。一般来讲，**面对面沟通的效率要大于语音沟通，而语音沟通的效率要大于打字。**\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75bbbc4eb8a441df8818d18e2541b29c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n因为我们在打字时，就算加了再多的表情和语气词也很难清晰的感受到对方的语气、态度、心情，更是很难探寻出一些深层次的想法，打字时的无效沟通会浪费掉大量的时间。所以，当我要沟通一件稍微复杂一点的事情的时候，如果需要沟通的人离我很近，我一定会选择面对面沟通；如果和我不在一个位置，我会尝试语音沟通；如果对方短时间内无法语音交流，再选择打字沟通。\n\n当然，这里只针对一些比较复杂的内容沟通，如果你需要沟通的内容有明确的结论比如：有、没有、对、错，这样的答案，打字反而更省事一点。\n\n## 技巧：碎片时间\n\n最后一个，就是碎片时间了。这个也是因人而异的，在我的日常生活里有两段非常固定的碎片时间。因为我住的离公司比较远，所以我每天通勤时间是很长的。大概上班要一个小时、下班要40分钟。但是这两段时间对我是非常重要的。\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35b8077f250549cf84c4a8fa56cb64ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n我一般会在上班通勤中进行 “整理” 这个步骤，定制我一天的计划。如果当天事情堆积较多，我会在晚上通勤的时间进行适当调整，补充到第二天的计划中。剩下的时间就是阅读了，我在一周中大部分的阅读时间就来自于这两段通勤。这里的阅读不仅仅会包括一些技术文章和书籍，也会包括当天工作中要涉及的一些文档。这不仅让我可以快速调整进入工作状态，也能让我持续保持接收新鲜事物。所以，在我之前的工作经历里面，对通勤距离一直都是很包容的。甚至中间有一段时间我搬到了离公司很近的地方，还让我非常不适应。\n\n我相信大家或多或少在平时也都会有这样的碎片时间，因为你不可能所有的时间都花费在紧张的工作中，毕竟人的精力是有限的，不可能所有时间都在保持专注。**所以怎么去安排好这些碎片时间，可能会成为你能脱颖而出的一个制胜法宝**。\n\n# 秘诀：坚持沉淀和写作\n\n关于时间的分享都是这么多，下面我们来聊聊沉淀和写作。我认为它是能让我们保持持续成长的秘诀。\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ede3a6ba46f240dbacb8f16285f15d3c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n技术写作不一定是对外发表的一篇文章，我个人把写作分成了两类：\n\n*   个人的沉淀：可以是平时的工作记录、一些知识碎片、你的个人知识体系等等；\n\n*   对外的分享：包括工作中的技术方案、对外发表的技术文章等的。\n\n两者各有各的好处，我建议大家两类写作都要执行起来，我们可以先从最简单的个人沉淀开始。\n\n## 个人沉淀\n\n### 有什么好处？\n\n做个人沉淀有什么好处呢，首先就是可以帮助我们巩固记忆。关于记忆，我相信大家在上学的时候都学过一个理论，如果我们记住了一个知识点，那么一个月过后，你对它的记忆可能只会剩下 20%。当然如果是天才的话我们就不说了哈，我相信大部分人，包括我也是一样的。\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20a4fc43d5de42ed884e1ec1ce4b3808~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n比如，有时候我们完成了一件工作，可能当时成就感挺强的，但是如果不进行总结和沉淀，过了一段时间你会发现脑子里关于它的记忆已经剩不下什么了，可能到达一定的时间之后，这件事是不是你做的好像没有什么区别了。所以很多同学工作很长时间了，但是又想不明白自己做了什么，虽然表面上工作经验多一点，但是跟刚毕业的同学有什么区别呢？相反，如果你每完成一件工作就进行适当的沉淀和总结，那结果可能就完全不一样了。一段时间之后你会清晰的知道你学到了什么，留下了什么，甚至对你工作中遗留的痛点以及对未来的规划都会非常清晰。\n\n另外一个非常重要的点，就是我们可以把工作中沉淀下来的工作总结、知识碎片，完善到我们的知识体系中去。我认为**一套自己的知识体系是每个人在成长过程中不可或缺的一部分**。它的作用非常大，首先它可以让我们对自己的认知更加清晰。比如：我到底了解多少内容、我最擅长什么、我有哪些能力比较欠缺、欠缺的这些能力哪些是工作中需要用到的？\n\n其实就这简单的几点好多同学都说不清楚。另外它也可以作为我们的知识索引，就像前面提到的：就算我们及时进行了沉淀和总结，也不可能保留 100% 的记忆，但是当我们用到这些知识的时候，有一个地方能够进行快速索引帮我们找到它们，就可以帮我们节省大量的时间。\n\n### 构建个人知识系统\n\n所以下面我们来看看怎么通过沉底和总结构建我们的个人知识系统。一个基本的个人知识系统需要满足下面三个要点：\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/216e30e49001424ca9332bf58705c8c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   **方便管理：** 整个流程我们不要设计的太复杂太长，否则很难持续下去。我曾经也沉迷于各种花里胡哨的笔记软件的迁移，后来发现很多功能都用不上、复杂的流程也比较难坚持下去，其实只要能满足我们对知识管理最基本的要求，最简洁的就是最好的。\n\n*   **要体系化：** 比如我们可以用思维导图的方式将你的整个知识体系呈现出来，否则如果只是杂乱无章的记录，没有成体系的整理。那后面这个知识系统肯定会废掉，这其实还是一个熵增的过程。我们必须要经过体系化的整理才能将知识变得有序，避免系统崩溃。另外，体系化的组织会让我们随时看到我们的知识体系是不断扩充的，这会让你非常有成就感。同时知识体系完善的过程中，你也能清晰的看到你的强项和欠缺之处，让我们对自己有更清晰的认知，也能让我们有针对性的制定学习计划。\n\n*   **方便提取：** 如果知识的获取路径很深，就算是记录下来，那后续可能也要吃灰了，所以快速索引的能力还是很重要的。\n\n就像上面的时间管理一样，知识管理也是因人而异的，大家需要根据自己的个人情况选择适合自己的方法，下面讲讲我对知识管理是怎么做的。\n\n### 如何做好知识管理\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f8ef6cef63c49d4bc48936ee10b188c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n最下面的提醒事项和飞书日程其实也是上面我们时间管理的一部分，所以我的时间管理和知识管理也是有交集的。最直接的就是对外部输入的记录了，我把它们分成三类：\n\n*   **需要执行的事情，我会记录在提醒事项中**：提醒事项中的记录我会通过整理，将他们转换成飞书日历中的日程和计划，在执行之后，我会对完成的事情进行复盘和反思，整理成文章，完善到知识库里。\n\n*   **平时的一些灵感、想法、以及一些碎片的知识，我会通过语雀小记记录下来：** 语雀小记中的知识碎片，我也会通过定期的归档和总结完善到知识库里。\n\n*   **平时看到的一些不错的文章，我会在 Cubox 中收藏下来：** 在阅读中产生的记录和思考，我会记录在小记中，如果有完整的总结和沉淀，我会直接记录到知识库中。\n\n知识库里的内容，已经经过了分类和系统化的总结，我会将新增的内容完善到知识网络中。其实知识网络也就是对知识库中分类和目录的组织。经过长时间的沉淀和整理，我的知识网络和知识库已经非常复杂了，所以我对我个人的认知是非常清晰的。我知道我掌握了哪些技能和知识，我在利用的时候可以随时随地的把它们提取出来，同时我也知道我有哪些分支是比较薄弱的，如果这些分支我比较感兴趣，或者说和我未来的工作可能有交集，我就会有针对性的去学习他们。\n\n## 对外分享\n\n### 有什么好处\n\n下面我们再来说说对外的分享，能够将自己的写作内容对外输出，其实好处就更大了，这里我说三点。\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9b4ffdef43444ae9334ef8b7950bea2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n首先关于个人对知识的理解方面，有时自己理解一个知识其实是比较容易的，可能你读完一篇相关的文章，就会觉得自己已经理解了。但是当你尝试把自己理解到的知识给别人也讲明白的时候，会发现可能远远不是你想的那么简单。**你可能需要数倍的深度理解才能做到把一个知识给其他人讲明白**。当然，对外的分享除了带给你个人的提升，还会给你的职场带来收益，比如可以提升你个人影响力，带动团队的整体技术氛围等等。下面跟大家介绍几个我的写作方面的经验。\n\n### 写作技巧：先枝后叶\n\n个人的沉淀，最终是给我们自己看的，所以写的再乱，只要我们自己能理解就没问题。 但是**文章如果是要对外分享的，一定有拥有清晰的条理和结构，最好是先枝后叶，先把文章整体的结构和大纲列好，再往里填充完善**。在结构上有很多法则可以大家可以套用，一个最简单的法则就是 2W1H 法则，也就是：是什么、为什么、怎么做。比如我最近的一篇讲解 Early Hints 的文章是这样拆解的：\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2947ba73374d49848ff0920682fed7a8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   **Why**：为什么需要 Early Hints？资源加载的性能问题\n\n*   **What**： Early Hints 到底是什么？HTTP 的 103 状态码、什么样的网站适合 Early Hints\n\n*   **How**：如何启用 Early Hints\n\n拥有一个好的结构和大纲不仅会让你的写作更加轻松也会让读者更加舒服。\n\n### 写作技巧：善用图片\n\n第二点就是善用图片。**有时候可能需要一大堆文字描述才能说明白的内容，一张图片就能搞定**。\n\n比如：我们要在文章中讲解怎么理解负载均衡这个概念？\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9ca0efad5664963a595f81c87478c2c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n我们可以在图中发现：前面是众多的服务窗口，下面有很多用户需要服务，我们需要一个工具或策略来帮助我们将如此多的用户分配到每个窗口，来达到资源的充分利用以及更少的排队时间。\n\n我们有三种测策略可以选择：\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d2d557aca6d4757841b9cb64901acda~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   第一种是默认的轮询策略，也就是将所有客户端请求轮询分配给服务端。\n\n*   第二种是将请求优先分配给压力较小的服务器。\n\n*   第三种是有限选择响应时间最快的服务器。\n\n大家可以看一下，是不是增加了几张图片，就可以胜过大批量的文字描述呢？\n\n### 写作技巧：从读者角度思考\n\n最后一个我想说的就是，多从读者的角度思考。因为**我们对外的文章第一目的还是要给读者去看的，读者不一定有和我们一样的知识背景**。试着想一想，如果你是一名没有相关知识背景的读者，想要获取相关的知识，你想要看到一篇什么样的文章呢？当然不是满屏的专业术语、或者杂乱无章的笔记、甚至是毫无任何的搬运。我相信呢，如果大家能做到这一点，写出的文章一定不会太差。\n\n以上就是我个人的一些经验之谈，仅供参考，本文完。','2022-07-25 05:39:00',0000000001,'阅读',20),(0000000044,'你真的敢落地Flutter桌面端吗？','如果你想用Flutter技术在桌面端落地，从技术上来讲，你必须解决这三大难题','> 如果你想用Flutter技术在桌面端落地，从技术上来讲，你必须解决这三大难题：**\n> 1\\. 应用窗口化，提供窗口操作的能力；\n> 2\\. 实现多窗口；\n> 3\\. 对外设的支持。**\n\n## 前言\n\n首先给个结论，Flutter在桌面端落地，`完全是可行的`；但生态远没有官方所说的那么完善，我甚至认为其`达不到stable的标准`。\n目前我们的桌面设备主要`有Windows、Android系统`，系统不同但UI一致，我们将在这两个平台上解决以上问题，并落地Flutter。\n\n## 一、窗口化和窗口操作存在的问题\n\n1.  实现应用窗口化：即应用是窗口化展示的，同时**可拖拽、可以点击应用外的地方**。\n    Flutter Windows本身是窗口化的；\n    而Android默认是全屏应用，需要**让普通应用支持窗口化**；若是小工具性质的应用，还需要支持可拖拽、可点击应用外的地方，这些在Flutter上都是需要我们在原生实现的。\n2.  实现应用窗口化后，一般开发过程中，肯定会需要以下对窗口的操作：\n    *   应用窗体圆形、阴影效果；\n    *   配置应用初始的显示位置；（很多小工具可能不是居中展示）\n    *   从窗口变为全屏、从全屏变为窗口；\n    *   ......\n\n## 二、支持多窗口\n\n目前Flutter是`明确不支持多窗口的`。官方好像对多窗口不太感兴趣，一直没有把优先级提上来，还是停留在p4级别，具体见[issue](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F30701 \"https://github.com/flutter/flutter/issues/30701\")。\n但是作为桌面应用，多窗口的需求是非常普遍的，因此这个技术壁垒是必须打破的。\n\n## 三、窗口化实现方案\n\n#### 1\\. Windows端\n\nWindows端Flutter默认支持窗口化，交互方式基本符合习惯，因此无需再做开发。\n\n#### 2\\. Android端\n\n*   Android普通应用实现窗口化，是把整个应用**展示成窗口的效果，但是点击外部窗口外的地方其实是不响应。** `同一时间只能显示一个应用进程，这是安卓的机制，也保证了其安全性。`要实现窗口化，需要把应用**Theme设置成Dialog的样式；同时设置窗口全屏，但是背景色为透明，设置点击外部Dialog不消失**，即可实现应用的窗口化展示。\n\n    1.  设置主题\n\n        ```\n        <style name=\"Theme.DialogApp\" parent=\"Theme.AppCompat.Light.Dialog\"> <item name=\"android:windowBackground\">@drawable/launch_application</item>\n            <item name=\"android:windowIsTranslucent\">true</item>\n            <item name=\"android:windowContentOverlay\">@null</item>\n            <!-- 不显示遮罩层 -->\n            <item name=\"android:backgroundDimEnabled\">false</item>\n            <item name=\"windowActionBar\">false</item>\n            <item name=\"windowNoTitle\">true</item> </style>\n        复制代码\n        ```\n        ```\n        <activity\n        android:name=\".MainActivity\"\n        android:exported=\"true\"\n        android:hardwareAccelerated=\"true\"\n        android:launchMode=\"singleTop\"\n        android:theme=\"@style/Theme.DialogApp\"\n        android:windowSoftInputMode=\"adjustResize\"> <meta-data\n        android:name=\"io.flutter.embedding.android.NormalTheme\"\n        android:resource=\"@style/Theme.DialogApp\" />\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n        复制代码\n        ```\n\n    2.  设置窗口全屏，但是背景色为透明，点击外部Dialog不消失\n\n        ```\n        class MainActivity : FlutterActivity() {\n            // 设置窗口背景透明\n            override fun getTransparencyMode(): TransparencyMode {\n                return TransparencyMode.transparent\n            }\n            override fun onResume() {\n                super.onResume()\n                // 点击外部，dialog不消失\n                setFinishOnTouchOutside(false)\n                // 设置窗口全屏\n                var lp = window.attributes\n                lp.width = -1\n                lp.height = -1\n                window.attributes = lp\n            }\n        }\n        复制代码\n        ```\n\n    3.  到这里`原生提供给Flutte一个全屏的透明窗体`，那么`Flutter的视图想长成啥样都可以`。\n\n*   若是小工具之类的，需要实现应用可拖拽，可点击应用区域外，这在android的实现相对复杂。我们利用`原生的窗口管理，弹出一个悬浮框，然后通过entry-point 找到Flutter层的UI`。这其实就是我们实现多窗口的思路，**这里就不单纯讲解，跟着后面一起讲了。**\n\n\n## 窗口化操作\n\n实现窗口化后，需要做很多相关的操作，我们分两个系统讲。\n\n#### 1\\. Windows端\n\n*   `应用窗体圆形、阴影效果`：通过window\\_manager插件，让应用背景色透明；然后我们在MaterialApp外面套一层Container可以设置圆角和阴影，再在外面加一次Container，加入padding以展示内层容器的阴影；\n*   `小工具配置初始位置`：通过window\\_manager插件的setPosition可以设置位置；\n*   `从窗口变为全屏、从全屏变为窗口`：通过window\\_manager插件可以实现全屏和退出全屏，在切换的过程中页面会闪烁，解决思路是：`把透明度设置为0 → 全屏 → 透明度恢复为1`。设置透明度的方法也由window\\_manager插件提供。\n\n#### 2\\. Android端\n\n对于普通应用，我们上面实现窗口化后，`原生就已经为Flutter提供了一个透明的全屏窗口，因此任何窗体的操作都是Flutter层去实现的，没啥技术难度。`\n\n*   `应用窗体圆形、阴影效果`：上面我们实现应用窗口后，其实整个应用窗体的背景色就是透明的了，因此我们比Windows少做了背景色透明这一步，然后后面的Container都是通用的，代码达到多平台复用；\n*   `小工具配置初始位置`：直接通过Stack和Positioned来配置就行了。但这种场景一般使用悬浮弹框做，设置定位见后面多窗口；\n*   `从窗口变为全屏、从全屏变为窗口`：Android依然很简单，只需要在全屏的时候把整个Flutter窗口的padding去除，恢复的时候加上就可以了。\n\n## 多窗口的实现\n\n首先明确一个观点，Flutter应用是基于Flutter engine，由原生提供的一个Surface画布，在这个画布上面用Skia 2绘制Flutter Widget。\n也就是说**本身这个应用就是一个窗口，它绝对没有能力为自己再创建一个窗口。** 所以多窗口的实现，需要依赖于原生的窗口管理。下面是Android端的实现原理图，这个原理适用于任何平台。 ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c366987fdb046458377dac306e90a00~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n*   `原生新建一个Flutter engine，通过dart执行器DartExecutor执行方法executeDartEntrypoint，根据传入的字符串找到对应的方法入口点Entrypoint，从而拿到Flutter widget；`\n*   `Flutter在方法上声明@pragma(\'vm:entry-point\') 后，此方法即便在Flutter项目没有被调用到，也能编译进去，因此原生新的engine就能找到这个切入点，拿到方法返回的widget；`\n\n这是非常典型的Flutter玩法，诸如混合开发都是如此。带来的影响是存在多引擎（engine），增加一些内存，**但是这个不可避免，除非你定制Flutter引擎.** 目前pub上支持多窗口的库也都是这个原理，但是库的质量其实不高，大家还是自己写吧。\n\n#### 实现步骤\n\n1.  Plugin与原生通信，由于操作都是异步的，所以务必使用`双向通信机制BasicMessageChannel`，而且需要两个通道：`主应用与子窗口通道`。\n2.  定义接口协议，一般`至少需提供以下能力`：\n\n```\n// 主应用打开子窗口\nvoid open(String entryPoint, Size size, GravityConfig? gravityConfig,\nbool draggable);\n\n// 主应用关闭子窗口\nvoid close();\n\n// 主应用设置大小\nvoid resize(int width, int height);\n\n// 主应用设置位置\nvoid setPosition(int x, int y);\n\n// 子窗口启动app，需要支持后台唤起以及命令行启动\nvoid launchApp();\n\n// 子窗口自行关闭\nvoid closeByWindows();\n\n// 子窗口设置大小\nvoid resizeByWindows(int width, int height);\n\n// 子窗口设置位置\nvoid setPositionByWindows(int x, int y);\n复制代码\n```\n\n3.  各端实现，下面贴下Android端的关键代码\n\n*   新建Flutter engine，找到Dart中的方法，此时engine就拿到了Flutter的widget实例；\n\n    ```\n    engine = FlutterEngine(application)\n    val entry = intent.getStringExtra(\"entryPoint\") ?: \"multiWindow\"\n    val entryPoint = DartExecutor.DartEntrypoint(findAppBundlePath(), entry)\n    engine.dartExecutor.executeDartEntrypoint(entryPoint)\n    复制代码\n    ```\n\n*   新建窗口管理类，通过FlutterViewe吸附engin，然后渲染到悬浮框的view上\n\n    ```\n    ///......\n    private var windowManager = service.getSystemService(Service.WINDOW_SERVICE) as WindowManager\n    ///......\n    windowManager.addView(rootView, layoutParams)\n    ///......///......\n    flutterView = FlutterView(inflater.context, FlutterSurfaceView(inflater.context, true))\n    flutterView.attachToFlutterEngine(engine)\n    ///......\n    engine.lifecycleChannel.appIsResumed()\n    ///......\n    rootView.findViewById<LinearLayout>(R.id.floating_window)\n    .addView(\n        flutterView,\n        ViewGroup.LayoutParams(\n        ViewGroup.LayoutParams.MATCH_PARENT,\n        ViewGroup.LayoutParams.MATCH_PARENT\n        )\n    )\n    复制代码\n    ```\n\n\n4.  **实现悬浮框后，Android平台上的桌面小工具，也就顺利成章的实现了，只是在小工具这个项目的MainAcitivy上，就不需要去加载FlutterActivity了，直接启动悬浮框即可。**\n\n## 外设支持\n\nusb设备在Flutter上，支持也是非常若的。具体可见我上一篇文章：[Flutter桌面端实践之识别外接媒体设备](https://juejin.cn/post/7115674087682375717 \"https://juejin.cn/post/7115674087682375717\")\n\n## 写在最后\n\n以上是我在桌面端预研Flutter的一些经验和思路分享，如果你想在桌面端落地Flutter，我想这边文章对你是很有帮助的。\n以上问题，我们遇到了，也解决了。但转念一想`这么多基础的操作Flutter都不支持，这真的可以称得上Stable版本了吗？`\nFlutter桌面端的生态，急需我们共同建设，文中多次提起的window\\_manager插件就是国内出色的组织：[LeanFlutter](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fleanflutter \"https://github.com/leanflutter\") 提供的，期待Flutter桌面端越来越好！','2022-07-16 12:23:00',0000000002,'Android',3),(0000000045,'我奇怪的安卓开发历程','本人进入安卓行业刚半年，虽然大学做过一个安卓APP的项目，但只是浑水摸鱼的，但这也是我进入这个行业的一个契机。刚进入公司时，其实基本上就是“从零开始的异世界生活”，真的什么都不会，但又需要快速去适应公司的开发速度。','![我奇怪的安卓开发历程（内含本人不太成熟的技术观）（一）](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d745db99f3e4ca7a2f47cba052fb141~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n**引子**\n\n本人进入安卓行业刚半年，虽然大学做过一个安卓APP的项目，但只是浑水摸鱼的，但这也是我进入这个行业的一个契机。刚进入公司时，其实基本上就是“从零开始的异世界生活”，真的什么都不会，但又需要快速去适应公司的开发速度。所以，我成长起来也十分迅速，只不过基础方面一直不扎实。下面我就从我行业历程来一步步讲述我的安卓开发历程。如有错误，希望各位大佬能指正。\n\n**起步**\n\n我进入公司的第一天，公司为我分配了一个工位，以及一台现在我都觉得不错的电脑（不想说的牌子），当时第一步就是简单按流程把电脑系统配置好，然后就安装安卓开发必备工具“Android Studio”，然后再根据公司新人指导文档去下载我早就了解但不熟悉的Git与它的小乌龟，以及SVN管理的小乌龟，生成公钥密钥，然后连接上公司的代码管理平台。\n\n接着去克隆公司的项目代码，由于我们是和摄像头设备打交道，所以要有NDK，SDK，sdk的接口我们不用去管理，服务器写好我们去调用即可，虽然这一点也是我开发很长时间后才逐渐清晰的，当时第一天就是去尝试正常的编译项目，是的，我都没有运行项目，但我也一本正经的看了一天的项目代码，虽然没啥收获，但也看到了许多从未了解的结构，当然是百度的，是的，因为代码的结构让我感到疑惑，所以去百度了，我一开始以为我们是MVP架构的，因为有presenter这个字眼，加上我们老大说“这是反射过来得到的，我们要写的功能代码都在这里面”（大概是这么说的，我说的不够专业，实际上我不知道啥是反射，现在知道了Java反射但对其为什么要这么做再看了几篇博客后还是不懂其目的），然后一搜就得出了MVP架构这一结论，从CSDN找了一个图片，就是这样的：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bf8a672a9de466fa0307f229813c03d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?) [Model](https://link.juejin.cn?target=https%3A%2F%2Fso.csdn.net%2Fso%2Fsearch%3Fq%3DModel%26spm%3D1001.2101.3001.7020 \"https://so.csdn.net/so/search?q=Model&spm=1001.2101.3001.7020\")\\-View-Presenter，Model提供数据，View负责显示，Controller/Presenter负责逻辑的处理。上面是这样解释的，但第二天我又神奇的发现我们项目里竟然还有vm(viewmodel),心想这不是昨天看MVP介绍的博客中说的MVVM架构吗？我从网上找了一个说明图片：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c79a56dd56004741a8c1be004f81f000~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?) [MVVM](https://link.juejin.cn?target=https%3A%2F%2Fso.csdn.net%2Fso%2Fsearch%3Fq%3DMVVM%26spm%3D1001.2101.3001.7020 \"https://so.csdn.net/so/search?q=MVVM&spm=1001.2101.3001.7020\")是Model-View-ViewModel的简写。\n\n所以我又被彻底绕晕了，其实很久都有点搞不明白vm是干什么的，以至于开发我都不敢写vm,虽然当时给我的开发任务也不需要写这些，只是改动一些老项目（没有这些构架的乱七八糟代码），但我真正了解它们要到工作的第三个月了。 **#**\n\n**渐入佳境**\n\n其实开发这种事情真的是只有实践才能出真知，如今我在开发中知晓了如何去打断点去debug，如何去利用sp管理，如何去写日志输出让自己知晓代码问题出在哪（一开始都用log.d，结果打发版包后，测试那边反馈的日志没有我的日志，哭死），知道怎么用thread写子线程以及为何用子线程，也逐渐知道怎么去用服务器提供的接口以及怎么去使用scheme跳转协议（最近还接触到APPlink，知道自己原来用的是deeplink）,还知道了handle的机制以及怎么给服务器api发送协议（说的好像有点毛病，但就是把参数给服务器，通过他们提供的api和url然后我们也会打开对应网页，支付之类的，可惜学的不精，仅仅会用，却说不出个道理），也明白了livedata的postvalue和observe监听，去刷新我们获取的信息以改变UI，等等等等。\n\n**总结**\n\n其实技术上我深入了解的并不多，基础当时也没有自己去重头学一遍，而是随着开发运用而变得熟练，然而这是有缺陷的，当时知道的四大组件，如今其实在开发中我接触多的也只是Activity，其他的如内容提供者（ContentProvider）（个人感觉就是自己建的model），以及服务（Service），广播（BroadCast）其实都不是很了解，但也就这么开发下去了，相信等到自己需要时也会快速理解运用的。','2022-07-28 14:55:00',0000000003,'Android',86),(0000000046,'Android Jetpack开庭','说别人不好时，要先给与肯定，所以先谈下它的优势','![Android Jetpack开庭](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f227c0376af34531842ca1b06032462f~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n## Jetpack 一定好么\n\n说别人不好时，要先给与肯定，所以先谈下它的优势\n\n*   谷歌爸爸推出并维护\n*   最佳实践\n*   向后兼容\n*   减少bug率\n*   轻松实现MVVM架构\n\n其实就第一条就足够打动很多人用了，但发展至今，对于国内的程序员而言，这些新的框架，既熟悉又陌生，就本人而言，我除了熟悉并使用过Lifecycle，AppCompat，Multidex之外，一概没用过，可能是因为我做业务少了的原因，即便我用的不多，但从组件的角度上讲，我还是有一些不满的，对于Jetpack不好的点，我总结如下：\n\n*   **框架复杂**\n*   **易用性也就那样**\n*   **库依赖树也很恐怖，每依赖一个库，就会带很多子库**\n*   **学习成本高，有大佬专门卖Jetpack课程，可见学习成本之高**\n\n其实我最想知道的是，如果每个应用都依赖这些库，打包到自己的apk中，那岂不是存在大量的重复的代码？你是不是觉得这些无所谓呢？那我们就算下它的大小，来看看他到底占了我们多少的空间\n\n## Jetpack 有多大\n\n所有的库都在这里：\n\n[developer.android.google.cn/jetpack/and…](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fjetpack%2Fandroidx%2Fexplorer%3Fhl%3Dzh-cn \"https://developer.android.google.cn/jetpack/androidx/explorer?hl=zh-cn\")\n\n我们只统计大家常用的库，来看看到底能有多大，两个纬度，一个是jar包大小，一个是apk大小，为什么这样区分呢？因为Android在打包过程中，会将jar包打包成Dex格式，而Dex对于jar包的合并是有一定的压缩的，jar和dex前后肯定是有区别的，所以分两个纬度来看，我们先来创建一个空项目，如下：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a644c113e0c1462b902ec9283490d0a7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n一行代码没有，什么都不引用，来看下项目大小\n\n### 如何统计项目依赖的Jar包呢？\n\n历经九九八十一难，我为你找到了合适的方法（兼容Gradle 7.0），如下：\n\n它可以将项目中依赖的jar包及aar统统给你找出来，并乖乖的放到项目的build/output/libs 下。\n\n```\ntask copyAllDependencies(type: Copy) {\n    configurations.implementation.setCanBeResolved(true)\n    configurations.api.setCanBeResolved(true)\n    from project.configurations.implementation\n    from project.configurations.api\n    into \"${buildDir}/output/libs\"\n}\n复制代码\n```\n\n### 空项目-Jar包统计\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f00dd6dcb2bc408aa236779c6a36d17c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n脚本运行完后，如上，jar包总量 1.8MB\n\n### 空项目-APK包统计\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/377e793cd08c45c0b82672e2d9c5f42a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n打完包1.2M，下面我们将Jetpack引入，且慢，突然想到，Apk只是用户下载时的感受，但其实它落盘后有多大呢？这才是占满你内存的元凶，安装后如下：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a20a13005acf48558da7f3cc5711e127~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n嘿，还变小了\n\n### Jetpack项目-Jar包统计\n\n我们将常用的引入，如下：\n\n```\n implementation \'androidx.core:core-ktx:1.3.2\'\n    implementation \'androidx.appcompat:appcompat:1.4.1\'\n    implementation \'com.google.android.material:material:1.3.0\'\n\n    def fragment_version = \"1.5.0\"\n\n    // Java language implementation\n    implementation \"androidx.fragment:fragment:$fragment_version\"\n    // Kotlin\n    implementation \"androidx.fragment:fragment-ktx:$fragment_version\"\n\n    def lifecycle_version = \"2.5.0-rc02\"\n    def arch_version = \"2.1.0\"\n\n    // ViewModel\n    implementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version\"\n    // ViewModel utilities for Compose\n    implementation \"androidx.lifecycle:lifecycle-viewmodel-compose:$lifecycle_version\"\n    // LiveData\n    implementation \"androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version\"\n\n    // Saved state module for ViewModel\n    implementation \"androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version\"\n\n    def nav_version = \"2.5.0\"\n\n    // Java language implementation\n    implementation \"androidx.navigation:navigation-fragment:$nav_version\"\n    implementation \"androidx.navigation:navigation-ui:$nav_version\"\n\n    // Kotlin\n    implementation \"androidx.navigation:navigation-fragment-ktx:$nav_version\"\n    implementation \"androidx.navigation:navigation-ui-ktx:$nav_version\"\n\n    def paging_version = \"3.1.1\"\n\n    implementation \"androidx.paging:paging-runtime:$paging_version\"\n\n    def room_version = \"2.4.2\"\n\n    implementation \"androidx.room:room-runtime:$room_version\"\n    annotationProcessor \"androidx.room:room-compiler:$room_version\"\n\n    implementation \"androidx.viewpager2:viewpager2:1.0.0\"\n    implementation \"androidx.swiperefreshlayout:swiperefreshlayout:1.1.0\"\n    implementation \"androidx.constraintlayout:constraintlayout:2.1.4\"\n    implementation \"androidx.gridlayout:gridlayout:1.0.0\"\n\n    implementation \"androidx.datastore:datastore-preferences:1.0.0\"\n    implementation \"androidx.startup:startup-runtime:1.1.1\"\n\n    def work_version = \"2.7.1\"\n\n    // (Java only)\n    implementation \"androidx.work:work-runtime:$work_version\"\n\n    // Kotlin + coroutines\n    implementation \"androidx.work:work-runtime-ktx:$work_version\"\n复制代码\n```\n\n加这些不过分吧，大小如何，来揭晓\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b64b86fe956499b84f6a00d092c4443~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n28 - 1.8 ，多了 26.2 MB，不恐怖么？\n\n### Jetpack项目-APK包统计\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae20ddd613254c889fda40cc3e258754~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n7.5 - 1.2 ，多了6.3MB，再看安装完如下：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b14f3ed122cf44d1b594a7f1fcd71b19~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n嘿，多了比之前20k左右\n\n### 小结一下\n\n| jetpack | jar包 | apk包安装前 | apk安装后 |\n| --- | --- | --- | --- |\n| 非Jetpack | 1.8 | 1.2 | 0.755 |\n| 引入Jetpack | 28 | 7.5 | 7.52 |\n| 差值 | 26.2 | 6.3 | 6.765 |\n\n通过如上统计，我们假设一种场景，你的应用安装100款这样的应用，再假如Android不转Dex，直接打包运行Jar包，则需要2620/1024≈2.56G，这也是Dex的优势，而转Dex后安装后，则需要676.5M，对于现在的手机而言，真的是小牛一毛，不值一提，所以我的担心是多余的，但如果再算上三方库呢？好吧，我不挣扎了，你们赢了。其实通过这件事我只想表明一个观点，那就是jetpack随着时间的推移越来越大，对我的感觉它就像 Framework的升级版，那为什么不在将来合并到Framework中呢，这样岂不是两全其美呢，一来每个应用的包可以在下载时就减少几M，安装时又可以少几M，这样不好么？有的人说了，如果合入Framework中，咋用新版本呢？岂不是又造成了另一种困扰呢？其实不用担心，因为你现在用的Framework，不就有很多基于Framework封装开源的库么，其实就是提供基于Framework版本的增量版本就行了，然后在不久的将来再合并到Framework中。但由于这样做的成本大于收益，所以谷歌爸爸选择不作为。\n\n## 宣判\n\n**法官**：\n\nJetpack由于对手机的伤害不足以构成犯罪，现无罪当场释放。\n\n**Jetpack**：\n\n这时的心情：又可以自由的玩耍了，继续猥琐发育。','2022-07-16 00:00:00',0000000004,'Android',4),(0000000047,'Android抓包从未如此简单','目前常见的抓包工具有Charles、Fiddler、Wireshark等，这些或多或少都需要一些配置，略显麻烦，只适合开发及测试人员玩，如果产品也想看数据怎么办纳，别急，本文的主角登场了，你可以在项目中集成','# 一、情景再现：\n\n> 有一天你正在王者团战里杀的热火朝天，忽然公司测试人员打你电话问为什么某个功能数据展示不出来了，昨天还好好的纳，是不是你又偷偷写bug了。。。WTF!，你会说：把你手机给我，我连上电脑看看打印的请求日志是不是接口有问题。然后吭哧吭哧搞半天看到接口数据返回的格式确实不对，然后去群里丢了几句服务端人员看一下这个接口，数据有问题。然后有回去打游戏，可惜游戏早已结束，以失败告终，自己还被无情的举报禁赛了。。。人生最痛苦的事莫过于此。假如你的项目已经集成了抓包助手，并且也给其他人员介绍过如何使用，那么像这类问题根本就不需要你再来处理了，遇到数据问题他们第一时间会自己看请求数据，而你就可以安心上王者了。\n\n# 二、Android抓包现状\n\n目前常见的抓包工具有Charles、Fiddler、Wireshark等，这些或多或少都需要一些配置，略显麻烦，只适合开发及测试人员玩，如果产品也想看数据怎么办纳，别急，本文的主角登场了，你可以在项目中集成[AndroidMonitor](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flygttpod%2FAndroidMonitor \"https://github.com/lygttpod/AndroidMonitor\")，只需两步简单配置即可实现抓包数据可视化功能，随时随地，人人都可以方便快捷的查看请求数据了。\n\n# 三、效果展示\n\n> 俗话说无图无真相\n\n![111.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/525375dd8b214d698c21cbdc01ddef53~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n![222.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0700c211379a4d26a7146a266bb5546d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n![333.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9383f3c801df4143b401a2b76335ae11~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n![抓包pc.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c01fa99b2154bd19bcb4c9a61dc33f9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n# 四、如何使用\n\n> 抓包工具有两个依赖需要添加：monito和monitor-plugin\n\n### [**Demo下载体验**](https://link.juejin.cn?target=https%3A%2F%2Fwww.pgyer.com%2FAndroidMonitor \"https://www.pgyer.com/AndroidMonitor\")\n\n### [源码地址](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flygttpod%2FAndroidMonitor \"https://github.com/lygttpod/AndroidMonitor\")\n\n### 1、monitor接入\n\n添加依赖\n\n```\n debugImplementation \'io.github.lygttpod:monitor:0.0.4\'\n复制代码\n```\n\n\\-备注： 使用debugImplementation是为了只在测试环境中引入\n\n### 2、monitor-plugin接入\n\n1.  根目录build.gradle下添加如下依赖\n\n```\n buildscript {\n        dependencies {\n            ......\n            //monitor-plugin需要\n            classpath \'io.github.lygttpod:monitor-plugin:0.0.1\'\n        }\n    }\n\n复制代码\n```\n\n2.添加插件\n\n```\n 在APP的build.gradle中添加：\n\n    //插件内部会自动判断debug模式下hook到okhttp\n    apply plugin: \'monitor-plugin\'\n\n复制代码\n```\n\n> ## 原则上完成以上两步你的APP就成功集成了抓包工具，很简单有没有，如需定制化服务请看下边的个性化配置\n\n### 3、 个性化配置\n\n```\n1、修改桌面抓包工具入口名字：在主项目string.xml中添加 monitor_app_name即可，例如：\n```\n   <string name=\"monitor_app_name\">XXX-抓包</string>\n```\n2、定制抓包入口logo图标：\n```\n   添加 monitor_logo.png 即可\n```\n3、单个项目使用的话，添加依赖后可直接使用，无需初始化，库里会通过ContentProvider方式自动初始化\n\n默认端口8080(端口号要唯一)\n\n4、多个项目都集成抓包工具，需要对不同项目设置不同的端口和数据库名字，用来做区分\n\n在主项目assets目录下新建 monitor.properties 文件，文件内如如下：对需要变更的参数修改即可\n```\n    # 抓包助手参数配置\n    # Default port = 8080\n    # Default dbName = monitor_db\n    # ContentTypes白名单，默认application/json,application/xml,text/html,text/plain,text/xml\n    # Default whiteContentTypes = application/json,application/xml,text/html,text/plain,text/xml\n    # Host白名单，默认全部是白名单\n    # Default whiteHosts =\n    # Host黑名单，默认没有黑名单\n    # Default blackHosts =\n    # 如何多个项目都集成抓包工具，可以设置不同的端口进行访问\n    monitor.port=8080\n    monitor.dbName=app_name_monitor_db\n```\n复制代码\n```\n\n### 4、 proguard（默认已经添加混淆，如遇到问题可以添加如下混淆代码）\n\n```\n```\n    # monitor\n    -keep class com.lygttpod.monitor.** { *; }\n```\n复制代码\n```\n\n### 5、 温馨提示\n\n```\n 虽然monitor-plugin只会在debug环境hook代码，\n    但是release版编译的时候还是会走一遍Transform操作（空操作），\n    为了保险起见建议生产包禁掉此插件。\n\n    在jenkins打包机器的《生产环境》的local.properties中添加monitor.enablePlugin=false，全面禁用monitor插件\n复制代码\n```\n\n### 6、如何使用\n\n*   集成之后编译运行项目即可在手机上自动生成一个抓包入口的图标，点击即可打开可视化页面查看网络请求数据，这样就可以随时随地的查看我们的请求数据了。\n*   虽然可以很方便的查看请求数据了但是手机屏幕太小，看起来不方便怎么办呐，那就去寻找在PC上展示的方法，首先想到的是能不能直接在浏览器里边直接看呐，这样不用安装任何程序在浏览输入一个地址就可以直接查看数据\n*   PC和手机在同一局域网的前提下：直接在任意浏览器输入 手机ip地址+抓包工具设置的端口号即可（地址可以在抓包app首页TitleBar上可以看到）\n\n# 五、原理介绍\n\n**①、 拦截APP的OKHTTP请求(添加拦截器处理抓包请求，使用ASM字节码插装技术实现)**\n\n*   写一个Interceptor拦截器，获取请求及响应的数据，转化为需要的数据结构\n\n```\noverride fun intercept(chain: Interceptor.Chain): Response {\n    val request = chain.request()\n    if (!MonitorHelper.isOpenMonitor) {\n        return chain.proceed(request)\n    }\n    val monitorData = MonitorData()\n    monitorData.method = request.method\n    val url = request.url.toString()\n    monitorData.url = url\n    if (url.isNotBlank()) {\n        val uri = Uri.parse(url)\n        monitorData.host = uri.host\n        monitorData.path = uri.path + if (uri.query != null) \"?\" + uri.query else \"\"\n        monitorData.scheme = uri.scheme\n    }\n    ......以上为部分代码展示\n}\n复制代码\n```\n\n*   有了拦截器就可以通过字节码插桩技术在编译期自动为OKHTTP添加拦截器了，避免了使用者自己添加拦截器的操作\n\n```\n mv?.let {\n            it.visitVarInsn(ALOAD, 0)\n            it.visitFieldInsn(GETFIELD, \"okhttp3/OkHttpClient\\$Builder\", \"interceptors\", \"Ljava/util/List;\")\n            it.visitFieldInsn(GETSTATIC, \"com/lygttpod/monitor/MonitorHelper\", \"INSTANCE\", \"Lcom/lygttpod/monitor/MonitorHelper;\")\n            it.visitMethodInsn(INVOKEVIRTUAL, \"com/lygttpod/monitor/MonitorHelper\", \"getHookInterceptors\", \"()Ljava/util/List;\", false)\n            it.visitMethodInsn(INVOKEINTERFACE, \"java/util/List\", \"addAll\", \"(Ljava/util/Collection;)Z\", true)\n            it.visitInsn(POP)\n        }\n复制代码\n```\n\n②、 数据保存到本地数据库（room）\n\n*   数据库选择官方推荐Room进行数据操作\n\n```\n@Dao\ninterface MonitorDao {\n    @Query(\"SELECT * FROM monitor WHERE id > :lastId ORDER BY id DESC\")\n    fun queryByLastIdForAndroid(lastId: Long): LiveData<MutableList<MonitorData>>\n\n    @Query(\"SELECT * FROM monitor ORDER BY id DESC LIMIT :limit OFFSET :offset\")\n    fun queryByOffsetForAndroid(limit: Int, offset: Int): LiveData<MutableList<MonitorData>>\n\n    @Query(\"SELECT * FROM monitor\")\n    fun queryAllForAndroid(): LiveData<MutableList<MonitorData>>\n\n    @Query(\"SELECT * FROM monitor WHERE id > :lastId ORDER BY id DESC\")\n    fun queryByLastId(lastId: Long): MutableList<MonitorData>\n\n    @Query(\"SELECT * FROM monitor ORDER BY id DESC LIMIT :limit OFFSET :offset\")\n    fun queryByOffset(limit: Int, offset: Int): MutableList<MonitorData>\n\n    @Query(\"SELECT * FROM monitor\")\n    fun queryAll(): MutableList<MonitorData>\n\n    @Insert\n    fun insert(data: MonitorData)\n\n    @Update\n    fun update(data: MonitorData)\n\n    @Query(\"DELETE FROM monitor\")\n    fun deleteAll()\n}\n复制代码\n```\n\n③、 APP本地开启一个socket服务[AndroidLocalService](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flygttpod%2Fandroid-local-service \"https://github.com/lygttpod/android-local-service\")\n\n*   AndroidLocalService基于NanoHttpd实现的一个本地微服务库，底层是通过socket实现，同时使用注解加上javapoet框架自动生成模版代码，这样就可以很方便的创建服务了，下边是创建服务并启动服务示例代码\n\n```\n //@Service标记这是一个服务，端口号是服务器的端口号，注意端口号唯一\n   @Service(port = 9527)\n   abstract class AndroidService {\n\n       //@Page标注页面类，打开指定h5页面\n       @Page(\"index\")\n       fun getIndexFileName() = \"test_page.html\"\n\n       //@Get注解在方法上边\n       @Get(\"query\")\n        fun query(aaa: Boolean, bbb: Double, ccc: Float, ddd: String, eee: Int,): List<String> {\n            return listOf(\"$aaa\", \"$bbb\", \"$ccc\", \"$ddd\", \"$eee\")\n        }\n\n       @Get(\"saveData\")\n       fun saveData(content: String) {\n           LiveDataHelper.saveDataLiveData.postValue(content + UUID.randomUUID());\n       }\n\n       @Get(\"queryAppInfo\")\n       fun getAppInfo(): HashMap<String, Any> {\n           return hashMapOf(\n               \"applicationId\" to BuildConfig.APPLICATION_ID,\n               \"versionName\" to BuildConfig.VERSION_NAME,\n               \"versionCode\" to BuildConfig.VERSION_CODE,\n               \"uuid\" to UUID.randomUUID(),\n           )\n       }\n   }\n\n   //初始化\n   ALSHelper.init(this)\n   //启动服务\n   ALSHelper.startService(ServiceConfig(AndroidService::class.java))\n\n\n   然后就可以通过 ip地址 + 端口号 访问了，例如：http://172.18.41.157:9527/index\n\n复制代码\n```\n\n> 使用[AndroidLocalService](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flygttpod%2Fandroid-local-service \"https://github.com/lygttpod/android-local-service\")之后创建和启动服务就是这么简单有没有，具体用法及细节请查看其说明文档\n\n④、 与本地socket服务通信\n\n*   剩下的就是与服务器的通信了，无论使用前端使用aJax还是客户端使用okhttp都可以正常请求数据了\n\n⑤、 UI展示数据(手机端和PC端)\n\n*   有了接口和数据具体展示就看可以随意定制了，如果你不喜欢默认的UI风格，那就拉源码自己定制UI哦','2022-07-11 12:02:00',0000000005,'Android',7),(0000000048,'JankMan-极致的卡顿分析系统','此系统拥有了端上采集两个维度数据的能力','# 卡顿分析系统\n\n## 1.系统介绍\n\n*   此系统拥有了端上采集两个维度数据的能力\n\n    *   方法运行数据：系统在编译期间基于ASM9+AGP7+自定义方法ID映射+自定义字节码指令集实现了方法运行数据的采集。\n    *   帧性能数据：系统在运行期间基于FrameMatrix+自定义数据结构体实现了端上帧数据的采集。\n*   当APP发生运行卡顿时，系统可自动分析堆栈，并且关联卡顿帧的方法调用链，并作出记录最终导出至文件。整体基于协程制作，性能损耗仅需1%。\n\n*   基于Compose KMP独创了多端可用的线下还原器，将采集到的数据做格式效验，并作出二次还原解析，进行了perfetto的二次开发，实现了可视化展示整体信息的能力。\n\n\n## 2.思路介绍\n\n### 2.1方法运行数据采集\n\n#### 2.1.1方法ID映射\n\n*   由于系统会在运行期间会采集大量数据，所以需要将庞大的方法名映射为指定ID的能力，如下\n\n    > ```\n    > //方法ID`方法具体全路径和行参\n    > 24`com.d.hookplus.HookApplication$onCreate$1.onActivitySaveInstanceState[android.app.Activity,android.os.Bundle,]\n    > 复制代码\n    > ```\n\n*   此处的方法名包含了全路径和行参，如果通过字符串记录是十分庞大的，所以在编译期间使用ASM技术将其对应成ID，降低空间复杂度\n\n\n#### 2.2.2函数记录能力\n\n0.  在ASM轮训期间，在方法开始和结束位置各插入对应的指令用于实现标记功能\n\n    ```\n    override fun onMethodEnter() {\n        //方法进入\n        methodVisitor?.perfettoVisitMethodDelegate(PerfettoCentre.const.METHOD_ENTER, methodId)\n        super.onMethodEnter()\n    }\n    ​\n    override fun onMethodExit(opcode: Int) {\n        //方法退出\n        methodVisitor?.perfettoVisitMethodDelegate(PerfettoCentre.const.METHOD_EXIT, methodId)\n        super.onMethodExit(opcode)\n    }\n    复制代码\n    ```\n\n    > 处理退出指令时，catch和return指令也有对应的记录\n\n1.  在对应的时机插入对应的代码\n\n    ```\n    this.let { methodVisitor ->\n            methodVisitor.visitFieldInsn(\n                GETSTATIC,\n                \"com/d/hookcore/perfetto/PerfettoCore\",\n                \"Companion\",\n                \"Lcom/d/hookcore/perfetto/PerfettoCore$Companion;\"\n            )\n            methodVisitor.visitIntInsn(BIPUSH, enterOrExit)\n            methodVisitor.visitIntInsn(SIPUSH, methodId)\n            methodVisitor.visitMethodInsn(\n                INVOKEVIRTUAL,\n                \"com/d/hookcore/perfetto/PerfettoCore$Companion\",\n                \"getTraceLine\",\n                \"(II)V\",\n                false\n            )\n        }\n    复制代码\n    ```\n\n    *   插入完代码的例子如下：\n\n    ```\n    例：\n    private fun initRecycler() {\n        //方法开始，第一个参数用于标记进入或者退出，第二个参数用于标记映射的方法ID\n        PerfettoCore.getTraceLine(0,12)\n        var recyclerView: RecyclerView = findViewById(R.id.rec)\n        recyclerView.adapter = NodeAdapter(messageList)\n        PerfettoCore.getTraceLine(1,12)\n    }\n    复制代码\n    ```\n\n\n#### 2.2.3.运行方法记录内容\n\n*   方法记录后的结果如下\n\n    如：main-1,942155.120954153,1,39,1\n\n\n| 说明 | 例 |\n| --- | --- |\n| 当前线程 | Main |\n| 当前线程ID | 1 |\n| 当前时间秒值 | 942155.120954153 |\n| 当前方法标记(进入或退出) | 1 |\n| 当前方法ID | 39 |\n| 当前帧位下标 | 1 |\n\n### 2.2帧数据采集\n\n#### 2.2.1于传统方式的区别\n\n*   区别于Choreographer Hook的方式，系统采用了FrameMatrix实现了帧数据采集\n\n    > Choreographer的Hook点是在Looper.loop之中的Printer.println下，\n    >\n    > ```\n    > final Printer logging = me.mLogging;\n    > if (logging != null) {\n    >  //Hook点\n    >  logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +msg.callback + \": \" + msg.what);\n    > }\n    > 复制代码\n    > ```\n    >\n    > 缺点如下：\n    >\n    > 0.  每次都需要字符串匹配，性能损耗严重\n    > 1.  在API31之中被封掉了\n\n\n#### 2.2.2FrameMatrix的能力\n\n*   FrameMatrix通过addOnFrameMetricsAvailableListener实现了帧数据获取的能力\n\n    ```\n    window.addOnFrameMetricsAvailableListener({ window, frameMetrics, dropCountSinceLastInvocation ->\n    //do something\n    }, frameMetricsHandler)\n    复制代码\n    ```\n\n    > 如果不对window进行addOnFrameMetricsAvailableListener，数据也会保留在平台层，所以没有性能损耗\n\n*   FrameMatrix是Android平台层提供的帧数据采集，包含如下信息\n\n\n| 类别 | 参数 | 说明 |\n| --- | --- | --- |\n| 获取每帧性能数据 | FIRST\\_DRAW\\_FRAME | 表示当前帧是否是当前 Window 布局中绘制的第一帧 |\n|  | INTENDED\\_VSYNC\\_TIMESTAMP | 当前帧的预期开始时间, 如果此值与 VSYNC\\_TIMESTAMP 不同，则表示 UI 线程上发生了阻塞，阻止了 UI 线程及时响应vsync信号 |\n|  | TOTAL\\_DURATION | 表示此帧渲染并发布给显示子系统所花费的总时间, 等于所有其他具有时间价值的指标的值之和 |\n|  | VSYNC\\_TIMESTAMP | 在所有 vsync 监听器和帧绘制中使用的时间值(Choreographer 的帧回调, 动画, View＃getDrawingTime等) |\n| cpuDuration | COMMAND\\_ISSUE\\_DURATION | 表示向 GPU 发出绘制命令的耗时 |\n|  | SWAP\\_BUFFERS\\_DURATION | 表示将此帧的帧缓冲区发送给显示子系统所花的时间 |\n| uiDuration | UNKNOWN\\_DELAY\\_DURATION | 表示等待 UI 线程响应并处理帧所经过的时间, 大多数情况下应为0 |\n|  | INPUT\\_HANDLING\\_DURATION | 表示处理输入事件回调的耗时 |\n|  | ANIMATION\\_DURATION | 表示执行动画回调的耗时 |\n|  | LAYOUT\\_MEASURE\\_DURATION | 表示对 View 树进行 measure 和 layout 所花的时间 |\n|  | DRAW\\_DURATION | 表示将 View 树转换为 DisplayList 的耗时 |\n|  | SYNC\\_DURATION | 表示将 DisplayList 与渲染线程同步所花的时间 |\n\n### 2.3.同步算法\n\n*   同步算法是将方法运行数据和帧性能数据自动分析，裁剪，合并出问题堆栈，并保存到指定位置的过程\n\n*   在开发者自定义连续卡顿多少帧后进行Dump\n\n    > 如果每卡顿一帧就Dump，信息量太密集，并且意义不大，建议开发者连续卡顿5帧起步\n\n\n#### 2.3.1.同步算法细节\n\n*   整个同步的过程是在单独的一个HandlerThread中进行的，所以面临了两个难题：\n\n    0.  由于HandlerThread接受帧数据的时机是不确定的，即可能方法数据已经收集到很多帧以后了，但是帧数据才刚刚到来。如何精准定位到卡顿范围内的全部函数\n    1.  如何尽可能减小性能损耗，降低时间复杂度和空间复杂度\n*   所以我们整个同步的过程是围绕着这两个问题进行设计的\n\n\n#### 2.3.2.算法合并过程\n\n0.  如果卡顿帧连续个数到达了开发者定义的个数，那么开始还原\n\n1.  将首个卡顿帧的开始时间和连续卡顿帧后的第一个不卡顿帧的开始时间作为时间范围，与函数运行数据的时间点进行校准。匹配到函数运行的范围区域，并通过两个指针进行标记\n\n    0.  具体匹配的过程是通过魔改版的二分查找实现\n2.  将标记出的函数运行范围进行导出\n\n    0.  导出的能力是基于NIO实现的\n3.  导出完毕后将函数指针位移到开始位置，重复利用空间\n\n    > 上述过程均在子线程进行，对主线程无影响，现阶段损耗为3%左右\n\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0659978621e14ccda7220f1ca03ee99c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n### 2.4.可视化展示\n\n*   将Dump出的数据进行二次改造，支持可视化展示\n\n#### 2.4.1.线下还原器\n\n*   基于perfetto的构造格式进行二次改造，用于支持可视化展示\n\n#### 2.4.2.支持多端的线下还原器\n\n*   基于Compose KMP实现了多端的可视化还原器，效果如下：\n\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d29f9ce4182c44d2973aeefe435b60e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n*   参数说明如下：\n\n    *   MappingFile：函数ID映射文件\n    *   SourceFile：后缀为.zy\\_trace的文件，是系统自动采集的格式\n    *   OutputPath：输出为perfetto识别格式的文件目录\n\n##### 2.4.2.1.还原格式细节\n\n*   如下：\n\n    *   改造前：\n\n    ```\n    com.d.hookplus|11116\n    main-1,942155.105176549,0,29,0\n    main-1,942155.105229674,1,29,0\n    main-1,942155.105313008,0,29,0\n    main-1,942155.105322383,1,29,0\n    main-1,942155.105492174,0,29,0\n    main-1,942155.105503112,1,29,0\n    main-1,942155.105524466,0,30,0\n    .......\n    复制代码\n    ```\n\n    *   改造后：\n\n    ```\n    # tracer: nop\n    #\n    # entries-in-buffer/entries-written: 30624/30624   #P:4\n    #\n    #                                  _-----=> irqs-off\n    #                                 / _----=> need-resched\n    #                                | / _---=> hardirq/softirq\n    #                                || / _--=> preempt-depth\n    #                                ||| /     delay\n    #       TASK-PID    TGID   CPU#  ||||    TIMESTAMP  FUNCTION\n    #          | |        |      |   ||||       |         |\n    com.d.hookplus-main-1 [000]... 942155.105177: tracing_mark_write: B|11116|0com.d.hookplus.NodeAdapter.getItemCount.[]\n    com.d.hookplus-main-1 [000]... 942155.105230: tracing_mark_write: E|11116|0com.d.hookplus.NodeAdapter.getItemCount.[]\n    com.d.hookplus-main-1 [000]... 942155.105313: tracing_mark_write: B|11116|0com.d.hookplus.NodeAdapter.getItemCount.[]\n    com.d.hookplus-main-1 [000]... 942155.105322: tracing_mark_write: E|11116|0com.d.hookplus.NodeAdapter.getItemCount.[]\n    com.d.hookplus-main-1 [000]... 942155.105492: tracing_mark_write: B|11116|0com.d.hookplus.NodeAdapter.getItemCount.[]\n    com.d.hookplus-main-1 [000]... 942155.105503: tracing_mark_write: E|11116|0com.d.hookplus.NodeAdapter.getItemCount.[]\n    com.d.hookplus-main-1 [000]... 942155.105524: tracing_mark_write:\n    .....\n    复制代码\n    ```\n\n\n#### 2.4.3.可视化展示\n\n*   最终将还原器输出的文件直接导入至perfetto系统中，效果如下\n\n![飞书20220729-182300.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee097b40c0f84ee098dd3f3b0e8f02f3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)','2022-07-29 10:33:00',0000000006,'Android',7),(0000000049,'【iOS开发】一个简单、易用、强大的 iOS APP 冷启动耗时分析工具','AMKLaunchTimeProfiler\n—— 简单、易用、强大的 iOS APP 冷启动耗时分析工具','![【iOS开发】一个简单、易用、强大的 iOS APP 冷启动耗时分析工具](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2a10525a80d48c6aaf050d549b8fda9~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n# AMKLaunchTimeProfiler\n—— 简单、易用、强大的 iOS APP 冷启动耗时分析工具\n\n[![CI Status](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca9c2c2bf60b441fb60b1f3ae6c7f835~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)](https://link.juejin.cn?target=https%3A%2F%2Ftravis-ci.org%2Fmengxinxin%2FAMKLaunchTimeProfiler \"https://travis-ci.org/mengxinxin/AMKLaunchTimeProfiler\") [![Version](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5b4af6c075040e4ac4527ff6f299003~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fcocoapods.org%2Fpods%2FAMKLaunchTimeProfiler \"https://cocoapods.org/pods/AMKLaunchTimeProfiler\") [![License](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad2e25808a3f4a579be226f82d25f652~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fcocoapods.org%2Fpods%2FAMKLaunchTimeProfiler \"https://cocoapods.org/pods/AMKLaunchTimeProfiler\") [![Platform](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ed1805f54d746388f7983fe30d78a60~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fcocoapods.org%2Fpods%2FAMKLaunchTimeProfiler \"https://cocoapods.org/pods/AMKLaunchTimeProfiler\")\n\n> 注：以下内容，可查阅 [GitHub 中 AMKLaunchTimeProfiler 的 Readme.md](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAndyM129%2FAMKLaunchTimeProfiler \"https://github.com/AndyM129/AMKLaunchTimeProfiler\") 以获取及时更新，和更好的阅读体验~~\n\n## 1、Features\n\n*   **零成本使用：** 通过 CocoaPods 一行代码接入，即可实现 APP 冷启动耗时统计，包括 `pre-main`、`main`、`首屏渲染`三个阶段的耗时，及总耗时\n*   **可视化查看：** 内置日志查看页面，并自动高亮高耗时方法，各种信息一目了然\n*   **源数据导出：** 可以方便的通过邮件、AirDrop 等方式 导出全部数据，具体包括\n    *   日志列表的文本数据，方便在电脑上查看\n    *   日志的JSON数据，方便基于日志的执行时间、调用方法、执行耗时 等信息 做自定义分析\n    *   多次有效数据的平均数 数据\n\n| ![31287f21b40610de7ca62a16bbcbe05f](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/305db80b73cf41449b2fe21d84a54b91~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) | ![14448cdb434da423818f6b819ec96591](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91b7b45684b342a79a58cc3849406db4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) | ![ea4fb8a570ac2cf9769654c1ad51da1e](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31d0b0cebad74383bea859de460af9d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) | ![4f6414aa477ba5588ffe200f3cec6e7e](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba06f8cb74864e44ae37458ca12cb247~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) | ![fd7727cbed7e363acd8dffdd01f2e860](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57d6cf54ee83438a8eeb03a560da3e9f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) |\n| --- | --- | --- | --- | --- |\n| 可视化查看 | 操作选项 | 源数据导出 | 通过邮件导出 | 通过其他方式导出 |\n\n## 2、Installation\n\n[`AMKLaunchTimeProfiler`](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAndyM129%2FAMKLaunchTimeProfiler \"https://github.com/AndyM129/AMKLaunchTimeProfiler\") 可通过[CocoaPods](https://link.juejin.cn?target=https%3A%2F%2Fcocoapods.org \"https://cocoapods.org\")完成引入，仅需现在工程的`Podfile`文件中 添加如下代码\n\n```\npod \'AMKLaunchTimeProfiler\'\n复制代码\n```\n\n然后在终端在`Podfile`文件所在路径下执行 `pod install`命令即可完成源码下载与引入。\n\n> 详见：[github.com/AndyM129/AM…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAndyM129%2FAMKLaunchTimeProfiler \"https://github.com/AndyM129/AMKLaunchTimeProfiler\")\n\n## 3、Usage\n\n### 3.1、查看相关日志\n\n内置日志查看页面，并自动高亮高耗时方法，各种信息一目了然，具体可通过如下方式打开：\n\n#### 3.1.1、使用手势\n\n通过 `AMKLaunchTimeProfiler.debugEnable = YES;` 启用调试模式（默认不启用），即可在 任意界面，通过「双指从右向左轻扫」的手势打开\n\n#### 3.1.2、使用编码\n\n通过 `[AMKLaunchTimeProfilerLogsViewController.new presentingWithAnimated:YES completion:nil];` 使用代码打开\n\n每一次启动，都会新创建 并保存一个 `AMKLaunchTimeProfiler` 实例，相关日志也都会存在该实例中，并实时持久化到本地，举例如下：\n\n```\n======================================================================\nAMKLaunchTimeProfiler id: 5c39904610203e20d26a22969df37bf9\nAMKLaunchTimeProfiler version: 1.0.0\nBundle id: io.github.andym129.amk-launch-time-profiler\nBundle short Version: 1.0\nBundle version: 1.0\nClient Version: (null)\nDevice Version: iPhone 11 Pro Max with iOS 15.5\nDevice Name: Andy\'s iPhone 11 Pro Max\n\n----------------------------------------------------------------------\n            process-start time: 2022-06-22 16:13:00\n          total time consuming: 2.121 s\n       pre-main time consuming: 1.716 s (80.88%)\n           main time consuming: 0.345 s (16.24%)\n   first screen time consuming: 0.061 s (2.87%)\n\n----------------------------------------------------------------------\n⏱ +1.716 s ~Δ 1716 ms >> __INTERNAL__: process-start time: 2022-06-22 16:13:00\n⏱ +1.716 s ~Δ    0 ms >> __INTERNAL__: main time: 2022-06-22 16:13:02\n⏱ +2.023 s ~Δ  308 ms >> -[AMKAppDelegate application:didFinishLaunchingWithOptions:]_block_invoke Line 18: 开始...\n⏱ +2.026 s ~Δ    2 ms >> -[AMKRootViewController viewDidLoad]_block_invoke Line 40: 开始...\n⏱ +2.044 s ~Δ   18 ms >> -[AMKRootViewController viewDidLoad]_block_invoke_2 Line 45: 结束\n⏱ +2.060 s ~Δ   16 ms >> -[AMKAppDelegate application:didFinishLaunchingWithOptions:] Line 25: hello\n⏱ +2.060 s ~Δ    0 ms >> -[AMKAppDelegate application:didFinishLaunchingWithOptions:] Line 26: world\n⏱ +2.060 s ~Δ    0 ms >> -[AMKAppDelegate application:didFinishLaunchingWithOptions:]_block_invoke_4 Line 36: 结束\n⏱ +2.061 s ~Δ    1 ms >> __INTERNAL__: did finish launching time: 2022-06-22 16:13:02\n⏱ +2.063 s ~Δ    3 ms >> -[AMKHomeViewController viewDidLoad]_block_invoke Line 38: 开始...\n⏱ +2.064 s ~Δ    1 ms >> -[AMKHomeViewController viewDidLoad]_block_invoke_2 Line 42: 结束\n⏱ +2.121 s ~Δ   57 ms >> -[AMKHomeViewController viewDidAppear:]_block_invoke Line 51: 开始...\n⏱ +2.121 s ~Δ    0 ms >> -[AMKHomeViewController viewDidAppear:]_block_invoke_2 Line 52: 结束\n⏱ +2.121 s ~Δ    0 ms >> -[AMKRootViewController viewDidAppear:]_block_invoke Line 54: 开始...\n⏱ +2.121 s ~Δ    0 ms >> -[AMKRootViewController viewDidAppear:]_block_invoke_2 Line 55: 结束\n⏱ +2.121 s ~Δ    0 ms >> __INTERNAL__: first screen time: 2022-06-22 16:13:02\n⏱ +2.121 s ~Δ    0 ms >> __INTERNAL__: ----------------------------------------------------------------------\n⏱ +2.121 s ~Δ    0 ms >> __INTERNAL__: total time consuming: 2.121 s\n⏱ +2.121 s ~Δ    0 ms >> __INTERNAL__: pre-main time consuming: 1.716 s (80.88%)\n⏱ +2.121 s ~Δ    0 ms >> __INTERNAL__: main time consuming: 0.345 s (16.24%)\n⏱ +2.121 s ~Δ    0 ms >> __INTERNAL__: first screen time consuming: 0.061 s (2.87%)\n⏱ +2.121 s ~Δ    0 ms >> __INTERNAL__: ----------------------------------------------------------------------\n⏱ +11.081 s ~Δ 8960 ms >> -[AMKViewController viewDidLoad]_block_invoke Line 38: 开始...\n⏱ +11.082 s ~Δ    0 ms >> -[AMKViewController viewDidLoad]_block_invoke_2 Line 41: 结束\n⏱ +11.099 s ~Δ   17 ms >> -[AMKViewController viewDidAppear:]_block_invoke Line 50: 开始...\n⏱ +11.099 s ~Δ    0 ms >> -[AMKViewController viewDidAppear:]_block_invoke_2 Line 51: 结束\n复制代码\n```\n\n### 3.2、导出日志\n\n在日志查看页面，点击右上角的“···”，点击发送，即可选择“邮件”或“其他”方式导出，具体包括：\n\n#### 3.2.1、log 文件\n\n```\n======================================================================\nAMKLaunchTimeProfiler id: 77949e4c840246c4ddedce31d8b9b54e\nAMKLaunchTimeProfiler version: 1.0.0\nBundle id: io.github.andym129.amk-launch-time-profiler\nBundle short Version: 1.0\nBundle version: 1.0\nClient Version: (null)\nDevice Version: iPhone 11 Pro Max with iOS 15.5\nDevice Name: Andy\'s iPhone 11 Pro Max\n\n----------------------------------------------------------------------\n            process-start time: 2022-06-22 16:04:53\n          total time consuming: 3.081 s\n       pre-main time consuming: 2.575 s (83.59%)\n           main time consuming: 0.000 s (0.00%)\n   first screen time consuming: 0.000 s (0.00%)\n\n----------------------------------------------------------------------\n⏱ +2.575 s ~Δ 2575 ms >> __INTERNAL__: process-start time: 2022-06-22 16:04:53\n⏱ +2.576 s ~Δ    0 ms >> __INTERNAL__: main time: 2022-06-22 16:04:56\n⏱ +3.081 s ~Δ  506 ms >> __INTERNAL__: first screen time: 2022-06-22 16:04:56\n⏱ +3.081 s ~Δ    0 ms >> __INTERNAL__: ----------------------------------------------------------------------\n⏱ +3.081 s ~Δ    0 ms >> __INTERNAL__: total time consuming: 3.081 s\n⏱ +3.081 s ~Δ    0 ms >> __INTERNAL__: pre-main time consuming: 2.575 s (83.59%)\n⏱ +3.081 s ~Δ    0 ms >> __INTERNAL__: main time consuming: 0.000 s (0.00%)\n⏱ +3.081 s ~Δ    0 ms >> __INTERNAL__: first screen time consuming: 0.000 s (0.00%)\n⏱ +3.081 s ~Δ    0 ms >> __INTERNAL__: ----------------------------------------------------------------------\n\n======================================================================\nAMKLaunchTimeProfiler id: 5c39904610203e20d26a22969df37bf9\nAMKLaunchTimeProfiler version: 1.0.0\nBundle id: io.github.andym129.amk-launch-time-profiler\nBundle short Version: 1.0\nBundle version: 1.0\nClient Version: (null)\nDevice Version: iPhone 11 Pro Max with iOS 15.5\nDevice Name: Andy\'s iPhone 11 Pro Max\n\n----------------------------------------------------------------------\n            process-start time: 2022-06-22 16:13:00\n          total time consuming: 2.121 s\n       pre-main time consuming: 1.716 s (80.88%)\n           main time consuming: 0.345 s (16.24%)\n   first screen time consuming: 0.061 s (2.87%)\n\n----------------------------------------------------------------------\n⏱ +1.716 s ~Δ 1716 ms >> __INTERNAL__: process-start time: 2022-06-22 16:13:00\n⏱ +1.716 s ~Δ    0 ms >> __INTERNAL__: main time: 2022-06-22 16:13:02\n⏱ +2.023 s ~Δ  308 ms >> -[AMKAppDelegate application:didFinishLaunchingWithOptions:]_block_invoke Line 18: 开始...\n⏱ +2.026 s ~Δ    2 ms >> -[AMKRootViewController viewDidLoad]_block_invoke Line 40: 开始...\n⏱ +2.044 s ~Δ   18 ms >> -[AMKRootViewController viewDidLoad]_block_invoke_2 Line 45: 结束\n⏱ +2.060 s ~Δ   16 ms >> -[AMKAppDelegate application:didFinishLaunchingWithOptions:] Line 25: hello\n⏱ +2.060 s ~Δ    0 ms >> -[AMKAppDelegate application:didFinishLaunchingWithOptions:] Line 26: world\n⏱ +2.060 s ~Δ    0 ms >> -[AMKAppDelegate application:didFinishLaunchingWithOptions:]_block_invoke_4 Line 36: 结束\n⏱ +2.061 s ~Δ    1 ms >> __INTERNAL__: did finish launching time: 2022-06-22 16:13:02\n⏱ +2.063 s ~Δ    3 ms >> -[AMKHomeViewController viewDidLoad]_block_invoke Line 38: 开始...\n⏱ +2.064 s ~Δ    1 ms >> -[AMKHomeViewController viewDidLoad]_block_invoke_2 Line 42: 结束\n⏱ +2.121 s ~Δ   57 ms >> -[AMKHomeViewController viewDidAppear:]_block_invoke Line 51: 开始...\n⏱ +2.121 s ~Δ    0 ms >> -[AMKHomeViewController viewDidAppear:]_block_invoke_2 Line 52: 结束\n⏱ +2.121 s ~Δ    0 ms >> -[AMKRootViewController viewDidAppear:]_block_invoke Line 54: 开始...\n⏱ +2.121 s ~Δ    0 ms >> -[AMKRootViewController viewDidAppear:]_block_invoke_2 Line 55: 结束\n⏱ +2.121 s ~Δ    0 ms >> __INTERNAL__: first screen time: 2022-06-22 16:13:02\n⏱ +2.121 s ~Δ    0 ms >> __INTERNAL__: ----------------------------------------------------------------------\n⏱ +2.121 s ~Δ    0 ms >> __INTERNAL__: total time consuming: 2.121 s\n⏱ +2.121 s ~Δ    0 ms >> __INTERNAL__: pre-main time consuming: 1.716 s (80.88%)\n⏱ +2.121 s ~Δ    0 ms >> __INTERNAL__: main time consuming: 0.345 s (16.24%)\n⏱ +2.121 s ~Δ    0 ms >> __INTERNAL__: first screen time consuming: 0.061 s (2.87%)\n⏱ +2.121 s ~Δ    0 ms >> __INTERNAL__: ----------------------------------------------------------------------\n⏱ +11.081 s ~Δ 8960 ms >> -[AMKViewController viewDidLoad]_block_invoke Line 38: 开始...\n⏱ +11.082 s ~Δ    0 ms >> -[AMKViewController viewDidLoad]_block_invoke_2 Line 41: 结束\n⏱ +11.099 s ~Δ   17 ms >> -[AMKViewController viewDidAppear:]_block_invoke Line 50: 开始...\n⏱ +11.099 s ~Δ    0 ms >> -[AMKViewController viewDidAppear:]_block_invoke_2 Line 51: 结束\n\n======================================================================\nAMKLaunchTimeProfiler id: 554b38e7f43a36526d5b74484930d2ad\nAMKLaunchTimeProfiler version: 1.0.0\nBundle id: io.github.andym129.amk-launch-time-profiler\nBundle short Version: 1.0\nBundle version: 1.0\nClient Version: (null)\nDevice Version: iPhone 11 Pro Max with iOS 15.5\nDevice Name: Andy\'s iPhone 11 Pro Max\n\n----------------------------------------------------------------------\n            process-start time: 2022-06-22 16:26:05\n          total time consuming: 2.896 s\n       pre-main time consuming: 2.263 s (78.14%)\n           main time consuming: 0.563 s (19.43%)\n   first screen time consuming: 0.070 s (2.43%)\n\n----------------------------------------------------------------------\n⏱ +2.263 s ~Δ 2263 ms >> __INTERNAL__: process-start time: 2022-06-22 16:26:05\n⏱ +2.263 s ~Δ    0 ms >> __INTERNAL__: main time: 2022-06-22 16:26:07\n⏱ +2.791 s ~Δ  529 ms >> -[AMKAppDelegate application:didFinishLaunchingWithOptions:]_block_invoke Line 18: 开始...\n⏱ +2.795 s ~Δ    4 ms >> -[AMKRootViewController viewDidLoad]_block_invoke Line 40: 开始...\n⏱ +2.812 s ~Δ   17 ms >> -[AMKRootViewController viewDidLoad]_block_invoke_2 Line 45: 结束\n⏱ +2.825 s ~Δ   13 ms >> -[AMKAppDelegate application:didFinishLaunchingWithOptions:] Line 25: hello\n⏱ +2.825 s ~Δ    0 ms >> -[AMKAppDelegate application:didFinishLaunchingWithOptions:] Line 26: world\n⏱ +2.825 s ~Δ    0 ms >> -[AMKAppDelegate application:didFinishLaunchingWithOptions:]_block_invoke_4 Line 43: 结束\n⏱ +2.825 s ~Δ    1 ms >> __INTERNAL__: did finish launching time: 2022-06-22 16:26:08\n⏱ +2.829 s ~Δ    3 ms >> -[AMKHomeViewController viewDidLoad]_block_invoke Line 37: 开始...\n⏱ +2.829 s ~Δ    1 ms >> -[AMKHomeViewController viewDidLoad]_block_invoke_2 Line 41: 结束\n⏱ +2.896 s ~Δ   66 ms >> -[AMKHomeViewController viewDidAppear:]_block_invoke Line 50: 开始...\n⏱ +2.896 s ~Δ    0 ms >> -[AMKHomeViewController viewDidAppear:]_block_invoke_2 Line 51: 结束\n⏱ +2.896 s ~Δ    0 ms >> -[AMKRootViewController viewDidAppear:]_block_invoke Line 54: 开始...\n⏱ +2.896 s ~Δ    0 ms >> -[AMKRootViewController viewDidAppear:]_block_invoke_2 Line 55: 结束\n⏱ +2.896 s ~Δ    0 ms >> __INTERNAL__: first screen time: 2022-06-22 16:26:08\n⏱ +2.896 s ~Δ    0 ms >> __INTERNAL__: ----------------------------------------------------------------------\n⏱ +2.896 s ~Δ    0 ms >> __INTERNAL__: total time consuming: 2.896 s\n⏱ +2.896 s ~Δ    0 ms >> __INTERNAL__: pre-main time consuming: 2.263 s (78.14%)\n⏱ +2.896 s ~Δ    0 ms >> __INTERNAL__: main time consuming: 0.563 s (19.43%)\n⏱ +2.896 s ~Δ    0 ms >> __INTERNAL__: first screen time consuming: 0.070 s (2.43%)\n⏱ +2.896 s ~Δ    0 ms >> __INTERNAL__: ----------------------------------------------------------------------\n复制代码\n```\n\n#### 3.2.2、txt文件\n\n```\n2 次有效数据的平均数：\n--------------------------------------------------\n          total time consuming: 2.508 s\n       pre-main time consuming: 1.989 s (79.30%)\n           main time consuming: 0.454 s (18.08%)\n   first screen time consuming: 0.066 s (2.61%)\n复制代码\n```\n\n#### 3.2.3、json文件\n\n```\n// 如下内容，已做精简\n[\n  {\n    \"mainTimeConsuming\" : 0,\n    \"bundleId\" : \"io.github.andym129.amk-launch-time-profiler\",\n    \"didFinishLaunchingTime\" : 0,\n    \"identifier\" : \"77949e4c840246c4ddedce31d8b9b54e\",\n    \"mainTime\" : 1655885096.369308,\n    \"preMainTimeConsuming\" : 2.5754809379577637,\n    \"deviceVersion\" : \"iPhone 11 Pro Max with iOS 15.5\",\n    \"processStartTime\" : 1655885093.7938271,\n    \"totalTimeConsuming\" : 3.0812058448791504,\n    \"deviceName\" : \"Andy\'s iPhone 11 Pro Max\",\n    \"logs\" : [\n      {\n        \"timeDelta\" : 2.5753798484802246,\n        \"function\" : \"__INTERNAL__\",\n        \"line\" : 0,\n        \"timeInterval\" : 2.5753798484802246,\n        \"string\" : \"process-start time: 2022-06-22 16:04:53\"\n      },\n      ...\n    ],\n    \"bundleName\" : \"AMKLaunchTimeProfiler_Example\",\n    \"version\" : \"1.0.0\",\n    \"firstScreenTimeConsuming\" : 0,\n    \"bundleVersion\" : \"1.0\",\n    \"firstScreenTime\" : 1655885096.8750329,\n    \"bundleShortVersion\" : \"1.0\"\n  },\n  {\n    \"mainTimeConsuming\" : 0.3446040153503418,\n    \"bundleId\" : \"io.github.andym129.amk-launch-time-profiler\",\n    \"didFinishLaunchingTime\" : 1655885582.4769759,\n    \"identifier\" : \"5c39904610203e20d26a22969df37bf9\",\n    \"mainTime\" : 1655885582.1323719,\n    \"preMainTimeConsuming\" : 1.7158448696136475,\n    \"deviceVersion\" : \"iPhone 11 Pro Max with iOS 15.5\",\n    \"processStartTime\" : 1655885580.416527,\n    \"totalTimeConsuming\" : 2.1213448047637939,\n    \"deviceName\" : \"Andy\'s iPhone 11 Pro Max\",\n    \"logs\" : [\n      {\n        \"timeDelta\" : 1.7157728672027588,\n        \"function\" : \"__INTERNAL__\",\n        \"line\" : 0,\n        \"timeInterval\" : 1.7157728672027588,\n        \"string\" : \"process-start time: 2022-06-22 16:13:00\"\n      },\n      ...\n    ],\n    \"bundleName\" : \"AMKLaunchTimeProfiler_Example\",\n    \"version\" : \"1.0.0\",\n    \"firstScreenTimeConsuming\" : 0.060895919799804688,\n    \"bundleVersion\" : \"1.0\",\n    \"firstScreenTime\" : 1655885582.5378718,\n    \"bundleShortVersion\" : \"1.0\"\n  },\n  {\n    \"mainTimeConsuming\" : 0.56263923645019531,\n    \"bundleId\" : \"io.github.andym129.amk-launch-time-profiler\",\n    \"didFinishLaunchingTime\" : 1655886368.1614871,\n    \"identifier\" : \"554b38e7f43a36526d5b74484930d2ad\",\n    \"mainTime\" : 1655886367.5988479,\n    \"preMainTimeConsuming\" : 2.2627308368682861,\n    \"deviceVersion\" : \"iPhone 11 Pro Max with iOS 15.5\",\n    \"processStartTime\" : 1655886365.336117,\n    \"totalTimeConsuming\" : 2.8956289291381836,\n    \"deviceName\" : \"Andy\'s iPhone 11 Pro Max\",\n    \"logs\" : [\n      {\n        \"timeDelta\" : 2.2626559734344482,\n        \"function\" : \"__INTERNAL__\",\n        \"line\" : 0,\n        \"timeInterval\" : 2.2626559734344482,\n        \"string\" : \"process-start time: 2022-06-22 16:26:05\"\n      },\n      ...\n    ],\n    \"bundleName\" : \"AMKLaunchTimeProfiler_Example\",\n    \"version\" : \"1.0.0\",\n    \"firstScreenTimeConsuming\" : 0.070258855819702148,\n    \"bundleVersion\" : \"1.0\",\n    \"firstScreenTime\" : 1655886368.231746,\n    \"bundleShortVersion\" : \"1.0\"\n  }\n]\n复制代码\n```\n\n### 3.3、自定义日志\n\n对于耗时较高的方法，可以通过补充自定义日志的方式，辅助找出具体的耗时的操作，进而通过优化 实现提速冷启动，相关方法如下：\n\n```\n/// 打印日志\n#define AMKLaunchTimeProfilerLog(FORMAT, ...);\n\n/// 打印日志 - @\"开始...\"\n#define AMKLaunchTimeProfilerLogBegin(FORMAT, ...);\n\n/// 打印日志 - @\"结束\"\n#define AMKLaunchTimeProfilerLogEnd(FORMAT, ...);\n\n/// 打印日志 - 内部日志\n#define AMKLaunchTimeProfilerInternalLog(FORMAT, ...);\n\n/// 打印日志 - 相同位置 只打一次\n#define AMKLaunchTimeProfilerOnceLog(FORMAT, ...);\n\n/// 打印日志 - 相同位置 只打一次 - @\"开始...\"\n#define AMKLaunchTimeProfilerOnceLogBegin(FORMAT, ...);\n\n/// 打印日志 - 相同位置 只打一次 - @\"结束\"\n#define AMKLaunchTimeProfilerOnceLogEnd(FORMAT, ...);\n\n/// 完全自定义的日志\n- (void)logWithFunction:(const char *_Nullable)function line:(NSInteger)line string:(NSString *_Nullable)format, ...;\n\n复制代码\n```\n\n## 4、Author\n\n*   邮箱：[andy\\_m129@163.com](https://link.juejin.cn?target=mailto%3Aandy_m129%40163.com \"mailto:andy_m129@163.com\")\n*   掘金：[juejin.cn/user/287597…](https://juejin.cn/user/2875978147966855 \"https://juejin.cn/user/2875978147966855\")\n\n## 5、License\n\nAMKLaunchTimeProfiler is available under the MIT license. See the LICENSE file for more info.','2022-06-22 10:04:00',0000000007,'iOS',2),(0000000050,'让人惊艳的高级配色，让你的色彩灵感爆棚！','在本章中，你将学会使用SwiftUI搭建一个纯色背景App。','![让人惊艳的高级配色，让你的色彩灵感爆棚！](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4695571d5b624ef9af6d85ecff039536~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n携手创作，共同成长！这是我参与「掘金日新计划 · 8 月更文挑战」的第5天，[点击查看活动详情](https://juejin.cn/post/7123120819437322247 \"https://juejin.cn/post/7123120819437322247\")。\n\n在本章中，你将学会使用`SwiftUI`搭建一个**纯色背景App**。\n\n## 项目背景\n\n无意中在刷**B站**的时候，看到一些很温馨的**颜色搭配**，让人充满**灵感**。\n\n以前就很喜欢使用纯色背景，经常会用纯色背景图片作为壁纸。\n\n那么本章中，我们就尝试使用`SwiftUI`搭建一个**纯色背景App**。\n\n## 项目搭建\n\n首先，创建一个新的`SwiftUI`项目，命名为`SolidColor`。\n\n![1.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4db5a590a6f2498c82c6515c7aaa4134~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n## 模型搭建\n\n首先，我们先创建一个数据模型，我们命名为`Model`。\n\n```\nstruct Model:Identifiable {\n    var id:UUID\n    var color:Color\n    var colorName:String\n    var colorRGBName:String\n}\n复制代码\n```\n\n![2.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1151f3ab34ee4ab68a22035d1db6d338~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n上述代码中，我们创建了一个`Model`结构体，遵循`Identifiable`协议。\n\n`Identifiable`协议可以帮助我们定位到数据源的`id`，当我们的示例数据存在2条或者多条一模一样的数据时，会展示多条而不是合并为一条。\n\n然后我们声明了几个变量：`id`作为**唯一标识符**，`color`为**背景颜色**，`colorName`为**颜色名称**，`colorRGBName`为对应颜色的**RGB颜色值**名称。\n\n完成后，我们来创建一些示例数据，示例：\n\n```\nvar models = [\n    Model(colorName: \"草莓红\", color: Color(red: 228/255, green: 45/255, blue: 68/255), colorRGBName: \"#E42D44\"),\n    Model(colorName: \"奶油白\", color: Color(red: 250/255, green: 239/255, blue: 222/255), colorRGBName: \"#FAEFDE\"),\n    Model(colorName: \"泥猴桃绿\", color: Color(red: 123/255, green: 173/255, blue: 95/255), colorRGBName: \"#7BAD5F\"),\n    Model(colorName: \"小麦黄\", color: Color(red: 229/255, green: 215/255, blue: 173/255), colorRGBName: \"#E5D7AD\"),\n    Model(colorName: \"板栗灰\", color: Color(red: 97/255, green: 79/255, blue: 77/255), colorRGBName: \"#614F4D\"),\n    Model(colorName: \"柠檬黄\", color: Color(red: 255/255, green: 216/255, blue: 0/255), colorRGBName: \"#FFD800\"),\n    Model(colorName: \"葡萄紫\", color: Color(red: 91/255, green: 52/255, blue: 99/255), colorRGBName: \"#5B3663\"),\n    Model(colorName: \"青豆绿\", color: Color(red: 188/255, green: 207/255, blue: 144/255), colorRGBName: \"#BCCF90\"),\n    Model(colorName: \"水蜜桃粉\", color: Color(red: 246/255, green: 160/255, blue: 154/255), colorRGBName: \"#F6A09A\")\n]\n复制代码\n```\n\n![3.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d724812a5a4b408a80357f843700ca55~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n就此，数据部分我们就准备好了。\n\n## 页面样式\n\n我们再来分析下交互逻辑，首先我们要实现左右拖动切换页面，这个我们可以使用到`TabView`组件作为我们的核心视图，示例：\n\n```\nTabView { \n    //代码块\n}\n.tabViewStyle(PageTabViewStyle())\n.edgesIgnoringSafeArea(.all)\n复制代码\n```\n\n由于要实现滚动，那么在`TabView`视图的基础上，还需要使用`tabViewStyle`修饰符进行修饰，我们使用`PageTabViewStyle`样式。\n\n另外为了实现整个屏幕都是纯色背景效果，我们使用`edgesIgnoringSafeArea`修饰符，将`iPhone`**安全区域**去掉。\n\n内容结构部分，我们可以使用`ForEach`循环遍历我们的示例数据数组`models`的数据，示例：\n\n```\nTabView { \n    ForEach(models) { item in    \n    //代码块\n    }    \n}\n.tabViewStyle(PageTabViewStyle())\n.edgesIgnoringSafeArea(.all)\n复制代码\n```\n\n内容显示部分，我们的**背景颜色**和**颜色名称**、**颜色RGB值**的排布方式是文字**浮在**背景上，因此这里我们可以使用`ZStack`视图，示例：\n\n```\nTabView { \n    ForEach(models) { item in    \n         ZStack {\n            item.color.edgesIgnoringSafeArea(.all)\n            //文字部分\n        }\n    }    \n}\n.tabViewStyle(PageTabViewStyle())\n.edgesIgnoringSafeArea(.all)\n复制代码\n```\n\n上述代码中，我们填充了一个背景颜色，我们看看效果。\n\n![4.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/661b40d389314ee5b99cc013c7392ef3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n最后是文字部分，我们使用`VStack`纵向布局的方式排布**颜色名称**和**RGB颜色值**。示例：\n\n```\nTabView {\n    ForEach(models) { item in\n        ZStack {\n            item.color.edgesIgnoringSafeArea(.all)\n\n            VStack(alignment: .center, spacing: 20) {\n                Text(item.colorName)\n                    .font(.system(size: 24))\n                    .fontWeight(.bold)\n                    .foregroundColor(.white)\n                Text(item.colorRGBName)\n                    .font(.system(size: 17))\n                    .fontWeight(.bold)\n                    .foregroundColor(.white)\n            }\n        }\n    }\n}\n.tabViewStyle(PageTabViewStyle())\n.edgesIgnoringSafeArea(.all)\n复制代码\n```\n\n## 项目展示\n\n![5.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd75284a385546a586716489e52fec2b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n## 本章代码\n\n```\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n        TabView {\n            ForEach(models) { item in\n                ZStack {\n                    item.color.edgesIgnoringSafeArea(.all)\n\n                    VStack(alignment: .center, spacing: 20) {\n                        Text(item.colorName)\n                            .font(.system(size: 28))\n                            .fontWeight(.bold)\n                            .foregroundColor(.white)\n\n                        Text(item.colorRGBName)\n                            .font(.system(size: 17))\n                            .fontWeight(.bold)\n                            .foregroundColor(.white)\n                    }\n                }\n            }\n        }\n        .tabViewStyle(PageTabViewStyle())\n        .edgesIgnoringSafeArea(.all)\n    }\n}\n\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        ContentView()\n    }\n}\n\nstruct Model: Identifiable {\n    var id = UUID()\n    var colorName: String\n    var color: Color\n    var colorRGBName: String\n}\n\nvar models = [\n    Model(colorName: \"草莓红\", color: Color(red: 228 / 255, green: 45 / 255, blue: 68 / 255), colorRGBName: \"#E42D44\"),\n    Model(colorName: \"奶油白\", color: Color(red: 250 / 255, green: 239 / 255, blue: 222 / 255), colorRGBName: \"#FAEFDE\"),\n    Model(colorName: \"泥猴桃绿\", color: Color(red: 123 / 255, green: 173 / 255, blue: 95 / 255), colorRGBName: \"#7BAD5F\"),\n    Model(colorName: \"小麦黄\", color: Color(red: 229 / 255, green: 215 / 255, blue: 173 / 255), colorRGBName: \"#E5D7AD\"),\n    Model(colorName: \"板栗灰\", color: Color(red: 97 / 255, green: 79 / 255, blue: 77 / 255), colorRGBName: \"#614F4D\"),\n    Model(colorName: \"柠檬黄\", color: Color(red: 255 / 255, green: 216 / 255, blue: 0 / 255), colorRGBName: \"#FFD800\"),\n    Model(colorName: \"葡萄紫\", color: Color(red: 91 / 255, green: 52 / 255, blue: 99 / 255), colorRGBName: \"#5B3663\"),\n    Model(colorName: \"青豆绿\", color: Color(red: 188 / 255, green: 207 / 255, blue: 144 / 255), colorRGBName: \"#BCCF90\"),\n    Model(colorName: \"水蜜桃粉\", color: Color(red: 246 / 255, green: 160 / 255, blue: 154 / 255), colorRGBName: \"#F6A09A\"),\n]\n复制代码\n```\n\n恭喜你，完成了整个项目的全部内容！\n\n快来动手试试吧。\n\n**如果本专栏对你有帮助，不妨点赞、评论、关注～**','2022-07-31 09:04:00',0000000008,'iOS',5),(0000000051,'一个框架&一个工具','距离上一次发技术文已经挺长的一段时间了，这段时间各种各样的事情挺忙的，所以也没有专门抽时间来写文章了。','## 前言\n\nHi Coder，我是 CoderStar！\n\n距离上一次发技术文已经挺长的一段时间了，这段时间各种各样的事情挺忙的，所以也没有专门抽时间来写文章了。（其实还有一部分原因是心态的变化）\n\n稍微介绍两个这段时间的技术产出吧。\n\n## APIService\n\n如果是我微信好友的小伙伴，估计已经在我朋友圈看到我分享过，在这里就简单介绍下吧，具体细节可以去`repo`看文档以及代码。\n\n`APIService` 是一个轻量的 Swift 网络抽象层框架，将请求、解析等流程工作分成几大角色去承担，完全面向协议实现，利于扩展。\n\ngithub链接：[APIService](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FCoder-Star%2FAPIService \"https://github.com/Coder-Star/APIService\")\n\n如果有兴趣的小伙伴可以了解下。\n\n## iOSToolKit\n\n因为新的网络框架默认使用官方的`Codable`作为`JSON`序列化工具，之前使用的`JSON`转`Model`工具对此支持的不是特别好，所以我自己简单撸了一个，`GUI`使用的是`SwiftUI`。（顺便说下，`SwiftUI`是真快，坑也是真多）\n\n工具大概长这样：\n\n![主页面](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/980a66ced13a48cfaa7551721fa156d4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n| 通用设置 | Swift设置 |\n| --- | --- |\n| ![通用设置](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daa7d0bf299c44f2acbadffd971f075e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) | ![Swift设置](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d28f9d8f396e470792be1423009a61af~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) |\n\n工具目前仅支持`Swift`语言的几种框架。（其中对`OC`的支持也写的差不多了，后续支持完毕也会提示大家升级，工具设计的时候考虑了要扩展到其他语言，所以对于语言的扩展支持非常容易，后续大家有对其他语言的需要也可以联系我）\n\n*   `Codable`：因为`Codable`一般都需要配合`propertyWrapper`使用，所以工具提供了为每一种类型自动加上自定义`propertyWrapper`的设置；\n*   `SwiftyJSON`\n*   `HandyJSON`\n\ndmg链接：[iOSToolKit.dmg](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FCoder-Star%2FJSONConfig%2Fblob%2Fmain%2FiOSToolKit.dmg%3Fraw%3Dtrue \"https://github.com/Coder-Star/JSONConfig/blob/main/iOSToolKit.dmg?raw=true\")\n\n> 如果对工具有一些建议，欢迎与我联系。\n\n## 最后\n\n其实这两个产出之间是关联的，都是为了让网络请求这件事情变的简单，其实中间还用过`Sourcery`来解决`Codable`重命名字段名的时候需要将所有不需要重命名的字段放到`CodingKeys`的问题，但是最近更新的`Xcode 14`里面解决了这个问题。（被官方卷没了,唉...)\n\n要更加努力呀！\n\nLet\'s be CoderStar!','2022-07-29 11:06:00',0000000009,'iOS',2),(0000000052,'只是巧合？苹果iOS16的神秘技术竟然与中国企业5年前产品一致！','最近，苹果又来“整顿”手机厂商了','![只是巧合？苹果iOS16的神秘技术竟然与中国企业5年前产品一致！](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c4bb37b6c3c41569d8dcbf0a241e8dc~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n最近，苹果又来“整顿”手机厂商了。\n\n有传言称，新版 iOS 16 将加入一个名为「自动验证」的新功能，可跳过网页和 App 中的人机验证流程，升级了 iOS 16 测试版的用户，可以进入「设置」—「Apple ID」—「密码与安全性」，在页面最下方找到这个功能。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cdaa43e0b354971aebac0ba1293964b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n什么意思呢?\n\n以前，当你打开苹果的某个 App 时，系统首先要证明你是“人”而不是“机器”，需要识别验证码来证明你是你，通过了就证明你是可以被信任的。现在，苹果为用户直接略过了验证码这一环节，也就是说，苹果抢先一步通过算法证明了你是你。\n\n对于这一更新，不少果粉直呼：“真的太人性了”。\n\n无感验证将是未来新趋势\n\n那么，苹果是如何实现绕过“验证码”的呢？\n\n答案就是苹果运用了一种全新、开放的验证机制 —— 私密证明令牌 (Private Access Tokens，缩写为 PAT)。\n\nPAT 并不指代某一种技术或某一种服务，而是一个验证用户的协议。它需要 Client、Mediator、Issuer 和 Origin 参与，才能完成整个验证，如下图：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be18c5ac8834485aac57df859610fdee~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n这次自动验证是苹果与云服务商Cloudflare合作完成的，实现过程如下（以用户使用浏览器访问某个网站的场景为例）：\n\n整个流程包含四个部分，即浏览器（Client）、苹果手机系统（Mediator）、云服务商Cloudflare(Issuer)，网站（Origin），其中网站后台需部署在Cloudflare上。\n\n首先，用户使用浏览器访问网站，因网站后台部署在Cloudflare上，Cloudflare会要求浏览器必须携带token。\n\n紧接着，浏览器会调用苹果系统服务进行检测，系统服务会检测当前设备的合法性，是否是可信设备，检查通过后会调用Cloudflare（作为Issuer角色）API，Cloudflare生成token给到浏览器。\n\n最后，浏览器携带token访问网站（Origin），在这里，云服务商Cloudflare做网关代理，作为Origin角色来验证token的有效性，放行访问网站。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae565eeb7b2149818a47d57b74d6a7be~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83f6ee28d1f54d44b32a8a09eabc87a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n看起来好像很复杂，但整个流程的重点有两个：\n\n一是整个验证流程没有任何需要人工介入的验证过程 (输入字符或点击图片等)，整个校验过程基本无需客户端和服务端做改造，由苹果设备和云服务供应商完成，设备是否可信的判断由苹果系统完成，相比三方 SDK，苹果系统有能力获取到更多的信息，做更全面的判断。另外，该技术可以明显提升脱离浏览器使用脚本直接爬取数据的爬虫成本;\n\n二是证明「我是人」的方式也从答题、隐私让渡，变成更合理的检查设备是否被破解等信息，使用支持 PAT 协议的设备和网站，会减少验证码的弹出，用户体验会更好。\n\n而这种验证方式，也与顶象无感验证的初衷不谋而合。\n\n顶象无感验证主打无感，结合了设备指纹、行为特征、访问频率、地理位置等多项技术，有效的拦截恶意登录、批量注册，阻断机器操作，拦截非正常用户，较传统验证码相比，用户无需再经过思考或输入操作，只需轻轻一滑即可进行验证。经过智能鉴别为正常的用户，在一定时间内无需再进行滑动操作，既为企业提供了安全保障也让用户无感知通过，极大提升了用户体验。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00b760024561454f8230a9541bf0f967~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n苹果作为手机厂商一哥率先提出了「自动验证」的功能，有理由相信，未来，无感验证将是大势所趋。\n\n是不是可以和人机验证说再见了?\n\n那么，人机验证是不是即将退出舞台了呢?\n\n“还有很长的路要走”，顶象业务安全专家如是说。\n\n首先，PAT 主要靠苹果系统来检测设备合法性，目前不清楚具体做了哪些检测，从公开的信息看会检测设备是否可信，是否改了设备参数等。这种完全静默的检测在一定程度上能阻断一些人机风险，比如脚本爬虫，因为无法获取 token 而会被 block 掉。但在互联网领域，机器人的风险表现是多样的，除了脚本还有其他方式，比如页面自动化驱动工具，通过群控控制等，该技术对这些风险的覆盖情况目前还不得而知。\n\n此外，目前支持该方案的云服务厂商较少，网站 / App 自己支持的话有一定成本，在该方案大规模推广应用之前人机验证依然会是主流。\n\n同时，站在手机厂商的角度，该方案的侧重点是如何提升用户体验，但考虑到安全性，覆盖度等问题，仍有较多的细节需要完善改进。\n\n一方面，要实现这项功能需要企业网站改造来支持 PAT 协议，或者企业网站托管到云服务供应商上，目前已知支持 PAT 协议的云服务厂商仅有国外两家 Cloudflare 和 Fastly。\n\n此外，该方案只能在使用国外网站和 App 时，体验会好一些。如果是国内，除了企业的网站、iOS 应用要去改造，还要考虑如何兼容 Android、鸿蒙、微信小程、支付宝小程序等。\n\n另一方面，在安全性方面，国内很多黑产会使用设备牧场或者云手机，该项技术对于使用设备牧场或者云手机的攻击者来说可能无效，设备牧场和云手机的设备基本都是正常设备，如果开启 Automatic Verification 设置，该技术可能会让攻击者更加便利的获取利益。\n\n并且，国内黑产的专业程度非常高，对抗也非常激烈，相信用不了多长时间，针对 PAT 的绕过或者破解方案就会出来。而对国内广大需要人机防护的厂商来说，在营销推广，线上活动等场景不仅需要足够安全的防护，还需要快速的应急和更新能力。如果 PAT 这个方案被破解，恐怕只能等 iOS 下个版本的更新了。\n\n但不得不说，苹果为其他手机厂商也提供了“范本”。\n\n从用户体验角度来看，PAT 是一个不错的创新点。但对于广大互联网企业来说，安全和体验是需要同时考虑的。提高用户体验的同时，需要准备充足的安全应急能力。比如后台要具备动态的风险决策判断能力，能够实时调整线上的安全策略; 要有多种验证码作为储备，并且能够实时切换。因此，企业在接入 PAT 的同时，不能完全依托 PAT，PAT 是一个优化用户体验的方案，但替换不了整个业务安全。\n\n无感 + 风险对抗 + 策略的全链路防护方案将是重点\n\n综上，不难看出，对于企业而言，他们的需求不仅仅是提升用户体验，更重要的是能够有风险对抗防护的能力以及出现风险问题之后如何解决的能力。\n\n顶象防御云基于多年实战经验和技术产品，拥有丰富的技术工具、数万个安全策略及数百个业务场景解决方案，具有情报、感知、分析、策略、防护、处置的能力，提供模块化配置和弹性扩容，助企业快速、高效、低成本构建自主可控的业务安全体系。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/780ce8a46f8843bc88077c56ac43c43f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n其主要包含业务感知防御平台、验证码、设备指纹和端加固等产品。具备设备真伪识别、行为验证、风险感知、高性能实时计算、高效的策略执行和攻击还原等六大能力能力。能够融合全网风险态势，为行业企业提供全网的安全攻防对抗情报; 基于攻防实战中打磨的技术和实战经验，形成行业通用策略和针对需求定制的专属策略，并通过云端实时迭代和联动; 提供风险识别、防御处置、攻击还原、人工审查、关联分析、数据沉淀等一体化闭环风险处置; 此外，还具有实现黑样本数据、风险行为特征的沉淀，并通过云端下发各业务安全体系，进一步提升整体风险防控等。\n\n基于顶象防御云，顶象也于近期推出了第五代验证码。结合安全可信链路、快速风险对抗、丰富的验证方式，可有效拦截撞库扫号、批量注册等机器风险行为。\n\n该产品集成了云端感知能力，升级了无感策略，结合了更多风险识别维度，具备更强的攻防对抗和用户体验，可覆盖 iOS、安卓、PC 浏览器、小程序等。应用在对于账号体系或者希望在人机验证环节做重点机器流量防控的各类企业。该产品具备业内最丰富的验证方式，通过验证魔方可实现快速攻防对抗 (10s 内完成配，60s 即可生效)，有效拦截机器操作等风险行为。\n\n具体来看，有以下几方面优势：\n\n一、智能无感，极致用户体验\n\n顶象智能风控大脑根据用户可疑程度，多级区分用户等级，为安全用户提供极致体验，安全用户无感知通过，高风险用户需二次验证。较上一代无感模式，强化了设备风险识别能力，增强了人机识别模型、行为特征等模型，为可信任的安全用户提供更好的体验。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cd1baf39f5a431188708bd1b406aa32~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n二、云端赋能，即时感知迭代\n\n顶象防御云通过线上的全链路风险防控产品对互联网、金融等行业的作弊手段进行监控、黑产特征分析、业务风险识别形成风险情报，通过同行业、跨行业的风险情报信息共享，打通上下游防控链路，链接各行业的“信息孤岛 \"，从而赋予了新一代验证码根据风险动态实现自我升级迭代的能力。更重要的是通过云端情报赋能企业业务人员，第一时间获取风险动态，提供防控思路，帮助企业提升风险防控能力，形成从风险感知到风控产品升级、风控能力提升的闭环流程。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e506fede0ff42e48fc1ba05b320cef9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n三、多维判断，快速攻防对抗\n\n随着黑产手段的多样化，多维度的信息更加有力于风险判断，实时流计算及场景策略结合机器学习训练的人机模型、历史数据的关联分析，面对风险变化时可实现全面、即时、快速的风险分析对抗。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a25a9a67ea640129564c2c53165f97f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n在用户体验层面，智能风控识别与验证相结合，通过风控引擎多级区分用户请求，可实现安全用户无感知通过，提升用户使用体验，截止目前已经广泛应用于各个互联网和金融机构。','2022-07-01 09:38:00',0000000010,'iOS',5),(0000000053,'iOS16适配指南之UINavigationItem','增加了类型为 UINavigationItem.ItemStyle 的属性style用于描述 UINavigationItem 在 UINavigationBar 上的布局，共有 3 种样式：navigator（默认样式），browser（浏览器样式）与editor（编辑器样式）。','1.  增加了类型为 UINavigationItem.ItemStyle 的属性`style`用于描述 UINavigationItem 在 UINavigationBar 上的布局，共有 3 种样式：`navigator`（默认样式），`browser`（浏览器样式）与`editor`（编辑器样式）。\n\n```\n//  Created by YungFan\nimport UIKit\n\nclass ViewController: UIViewController {\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        view.backgroundColor = .red\n        // 左侧\n        navigationItem.leftBarButtonItems = [\n            UIBarButtonItem(barButtonSystemItem: .add, target: self, action: #selector(gotoNextViewController)),\n            UIBarButtonItem(barButtonSystemItem: .bookmarks, target: nil, action: nil)]\n        // 标题\n        navigationItem.title = \"导航栏\"\n        // navigationItem.titleView = UISwitch()\n        // 中间\n        let fixedGroup = UIBarButtonItemGroup.fixedGroup(items: [\n            UIBarButtonItem(title: \"撤销\", image: UIImage(systemName: \"arrow.uturn.backward\"),\n                            primaryAction: UIAction { _ in\n                            }),\n            UIBarButtonItem(title: \"反撤销\", image: UIImage(systemName: \"arrow.uturn.forward\"),\n                            primaryAction: UIAction { _ in\n                            })])\n        let movableGroup = UIBarButtonItem(title: \"裁剪\", image: UIImage(systemName: \"crop\"),\n                                           primaryAction: UIAction { _ in\n                                           }).creatingMovableGroup(customizationIdentifier: \"Cropping\")\n        navigationItem.centerItemGroups = [fixedGroup, movableGroup]\n        // 右侧\n        navigationItem.rightBarButtonItems = [\n            UIBarButtonItem(barButtonSystemItem: .camera, target: nil, action: nil),\n            UIBarButtonItem(barButtonSystemItem: .done, target: nil, action: nil)]\n        // 设置style\n        navigationItem.style = .editor\n    }\n\n    // MARK: 导航跳转\n    @objc func gotoNextViewController(_ sender: UIBarButtonItem) {\n        let nextViewController = UIViewController()\n        nextViewController.view.backgroundColor = .red\n        nextViewController.navigationItem.title = \"下一页\"\n\n        navigationController?.pushViewController(nextViewController, animated: true)\n    }\n}\n复制代码\n```\n\n2.  增加了闭包类型的属性`titleMenuProvider`用于给当前导航栏的标题增加操作菜单。\n\n```\n//  Created by YungFan\nimport UIKit\n\nclass ViewController: UIViewController {\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        navigationItem.title = \"标题\"\n        // 设置titleMenuProvider\n        navigationItem.titleMenuProvider = { _ in\n            let favorite = UIAction(title: \"Favorite\", image: UIImage(systemName: \"heart.fill\")) { _ in\n                print(\"favorite\")\n            }\n            let share = UIAction(title: \"Share\", image: UIImage(systemName: \"square.and.arrow.up.fill\")) { _ in\n                print(\"share\")\n            }\n            let delete = UIAction(title: \"Delete\",\n                                  image: UIImage(systemName: \"trash.fill\"),\n                                  attributes: [.destructive]) { _ in\n                print(\"delete\")\n            }\n            return UIMenu(children: [favorite, share, delete])\n        }\n    }\n}\n复制代码\n```\n\n3.  增加了类型为 UIAction 的属性`backAction`用于实现返回按钮事件。\n\n```\n//  Created by YungFan\nimport UIKit\n\nclass ViewController: UIViewController {\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        // 设置backAction\n        navigationItem.backAction = UIAction(handler: { _ in\n            print(\"返回按钮点击实践\")\n        })\n    }\n}\n复制代码\n```','2022-08-02 01:43:00',0000000011,'iOS',4);
/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `people`
--

DROP TABLE IF EXISTS `people`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `people` (
  `id` int(10) unsigned zerofill NOT NULL AUTO_INCREMENT,
  `nickname` varchar(45) DEFAULT NULL,
  `password` varchar(80) DEFAULT NULL,
  `avatar` varchar(255) DEFAULT NULL,
  `sid` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `people`
--

LOCK TABLES `people` WRITE;
/*!40000 ALTER TABLE `people` DISABLE KEYS */;
INSERT INTO `people` VALUES (0000000001,'Yuzi','8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92','https://s1.ax1x.com/2022/08/18/vrut1I.jpg','7afc172bccf5d71b5373d6f4a467ecd2fb329f17ab7e99170c9114d9c03a3ab0'),(0000000002,'Lionaom','8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92','https://s1.ax1x.com/2022/08/16/v0iGp4.png',NULL),(0000000003,'Xiao','8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92','https://s1.ax1x.com/2022/08/16/v0i3hF.png','eb535aec11598a810ea6d4f1aaea3b495c65349d1c1880bdff645fc138ecac4d'),(0000000004,'LiZiping','4ad269b5afbb4c981fb7ffccefa90f367d00c35915133efde6257ff97f3c455a','https://s1.ax1x.com/2022/08/16/v0iJ1J.png','448e983e2b58c6c0a72791a21ac2be2aaec8d5ebee7dd372d46c274917e622e7'),(0000000005,'Cai Molly','8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92','https://s1.ax1x.com/2022/08/16/v0i1tU.png',NULL),(0000000006,'SunChenglong','8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92','https://s1.ax1x.com/2022/08/16/v0ia0x.png',NULL),(0000000007,'PanJinhua','8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92','https://s1.ax1x.com/2022/08/16/v0itXR.png',NULL),(0000000008,'Kazuha','8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92','https://s1.ax1x.com/2022/08/16/v0id76.png',NULL),(0000000009,'Heizou','8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92','https://s1.ax1x.com/2022/08/16/v0iUn1.png',NULL),(0000000010,'Albedo','8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92','https://s1.ax1x.com/2022/08/16/v0i0AK.png',NULL),(0000000011,'Paimon','8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92','https://s1.ax1x.com/2022/08/16/v0FCv9.png',NULL),(0000000012,'err','a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3',NULL,'2d8482f2de9ff5cd7c0b249ece2284f5a0cbabb88d6f4513ff714239b1449f8a'),(0000000013,'Lion','8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92',NULL,'e7554c9999d3751d602c06c832fa36ceddf553546c4376ba4f6ce0ec296b5097');
/*!40000 ALTER TABLE `people` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2022-08-21 14:04:55
