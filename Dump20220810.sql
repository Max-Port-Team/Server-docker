-- MySQL dump 10.13  Distrib 8.0.29, for Linux (x86_64)
--
-- Host: 43.156.106.129    Database: MaxPort
-- ------------------------------------------------------
-- Server version	8.0.29

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `article`
--

DROP TABLE IF EXISTS `article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `article` (
  `id` int(10) unsigned zerofill NOT NULL AUTO_INCREMENT,
  `title` varchar(100) NOT NULL,
  `intro` varchar(200) DEFAULT NULL,
  `body` mediumtext,
  `time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `author` int(10) unsigned zerofill NOT NULL,
  `tag` varchar(45) DEFAULT NULL,
  `visit` int DEFAULT '0',
  PRIMARY KEY (`id`),
  KEY `fk_article_1_idx` (`author`),
  CONSTRAINT `fk_article_1` FOREIGN KEY (`author`) REFERENCES `people` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article`
--

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article` VALUES (0000000001,'近 20 人爆肝数周，写给初中级前端的万字高级进阶指南','笔者在学会 JS 以及框架的应用后，有一段时间不知道该如何深入下去，活能干，就是不知道该学啥。相信这个问题也会有很多读者朋友遇到。\n\n当然笔者目前已经突破了这个瓶颈，也成为了知名公司基础架构组的成员。因此想通过自己成长的经历及积累的资料整理出一系列的学习路线及资料推荐，帮助各位读者朋友解决这个问题。','? 这是什么？\n\n笔者在学会 JS 以及框架的应用后，有一段时间不知道该如何深入下去，活能干，就是不知道该学啥。相信这个问题也会有很多读者朋友遇到。\n\n当然笔者目前已经突破了这个瓶颈，也成为了知名公司基础架构组的成员。因此想通过自己成长的经历及积累的资料整理出**一系列的学习路线及资料推荐**，帮助各位读者朋友解决这个问题。\n\n> 仓库内容笔者为主要贡献者，另外还拉了将近 20 位资深前端开发做内容共建及审核，多数人员任职一线大厂 P6、P7，第一版耗时数周，大家国庆假期也没停歇，内容绝对让各位看官满意。\n\n**此资料适用于小白入门、初中级进阶、高级查漏补缺。**\n\n**内容每天都在更新，大家可以持续关注。**\n\n这里是 [Github 链接](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FKieSun%2Ffucking-frontend \"https://github.com/KieSun/fucking-frontend\")，最新内容都会首先更新在 Github，如果你觉得内容对你有帮助，可以点个 Star。\n\n## ? 如何使用\n\n如果你是初中级工程师来说，笔者也推荐先行学习「前端核心学习路径」，主要是巩固基础，之后再挑选感兴趣的主题。\n\n如果你是高级工程化，笔者推荐跳过「前端核心学习路径」，直接挑选感兴趣的主题学习即可。\n\n以下所有知识点笔者都会帮助读者朋友们将知识连贯起来，从而建立自己的知识体系而不是单独记忆松散的知识点。\n\n## 如何获取本文资料\n\n**笔者已经将仓库内容里的重要资料整理好了， 另外还附赠了前端 10 万字的面试攻略，已经帮助上千人拿到 offer。大家可以关注【[公众号](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FKieSun%2Fall-of-frontend%23%25E5%25A6%2582%25E4%25BD%2595%25E8%258E%25B7%25E5%258F%2596%25E6%259C%25AC%25E4%25BB%2593%25E5%25BA%2593%25E8%25B5%2584%25E6%2596%2599 \"https://github.com/KieSun/all-of-frontend#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%9C%AC%E4%BB%93%E5%BA%93%E8%B5%84%E6%96%99\")】发送「资料」获取。**\n\n## ? 目录\n\n因为掘金的 `header` 标签并不支持跳转，因此大家只能受累自己划文章到感兴趣的地方了，或者读者朋友也可以前往 [Github](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FKieSun%2Ffucking-frontend \"https://github.com/KieSun/fucking-frontend\") 浏览目录。\n\n## 如何高效自学\n\n![Z0qdJz](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7823cf5008814505ac7cd700ebfb9174~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n自学是每个工程师都需要掌握的一项技能。这个学习方法笔者百试百灵，学习任何技术都会用上这个思路。另外我们还能通过这个思路拓宽自己的技术栈，将各个知识联系起来建立自己的知识体系，并且通过这种学习方式学到的知识也不容易遗忘。\n\n## 书籍推荐\n\n以下书籍主要还是推荐了 JS 方面的，其它比如说框架、TS 等等技术会在各自章节为大家介绍。\n\n### 初级\n\n- [JavaScript 高级程序设计（第 4 版）](https://link.juejin.cn?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F35175321%2F \"https://book.douban.com/subject/35175321/\")\n\n### 进阶\n\n- [JavaScript 忍者秘籍（第 2 版）](https://link.juejin.cn?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F30143702%2F \"https://book.douban.com/subject/30143702/\")\n- [你不知道的 JS 三卷](https://link.juejin.cn?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F26351021%2F \"https://book.douban.com/subject/26351021/\")，该书英文版是开源的，并且作者已经在写第二版，有能力阅读英文的读者推荐直接看 [原著](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgetify%2FYou-Dont-Know-JS \"https://github.com/getify/You-Dont-Know-JS\")\n\n### 高级\n\n- [JavaScript 悟道](https://link.juejin.cn?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F35469273%2F \"https://book.douban.com/subject/35469273/\")\n- [JavaScript 语言精髓与编程实践（第 3 版）](https://link.juejin.cn?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F35085910%2F \"https://book.douban.com/subject/35085910/\")\n\n**上述书籍大家可以关注【[公众号](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FKieSun%2Ffucking-frontend%23%25E4%25BD%259C%25E8%2580%2585%25E4%25BF%25A1%25E6%2581%25AF \"https://github.com/KieSun/fucking-frontend#%E4%BD%9C%E8%80%85%E4%BF%A1%E6%81%AF\")】发送「资料」获取， 另外还附赠了前端 10 万字的面试攻略，已经帮助上千人拿到 offer。**\n\n## 前端核心学习路径\n\n前端知识点很多这是公认的事情，但是我们确实没必要把所有知识都去学习，那样只会贪多嚼不烂。我们能把核心知识点、热门技术以及工作中需要用到的知识学好就已经能打败大部分前端工程师了，剩下的大家可以自行根据兴趣选择学习内容。\n\n**但是在学习其他内容之前，笔者强烈推荐各位务必一定一定先把基础打扎实了，基础不好真的不可能把自己技术往上拔高的。**\n\n> 为了保证大家学到的知识是正确的，下文中的文档资料笔者都使用了英文版本。因为在审核资料的过程中笔者发现不少中文文档都存在翻译错误或者过时的情况。\n\n如果你还是一位初学者，推荐先自行完整阅读一至二本书后再按照该计划学习，因为以下计划并没有囊括 JS 的所有知识，而是列出了所有核心知识点。\n\n关于书籍笔者推荐以下两本：\n\n- [JavaScript 高级程序设计（第 4 版）](https://link.juejin.cn?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F35175321%2F \"https://book.douban.com/subject/35175321/\")\n- [JavaScript 忍者秘籍（第 2 版）](https://link.juejin.cn?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F30143702%2F \"https://book.douban.com/subject/30143702/\")\n\n### JS 核心知识点\n\n#### 数据类型\n\nJS 数据类型分为两大类及八种数据类型，注意别漏了 ES6 新增的 `bigint`。\n\n- 文档：\n  - [JavaScript 数据类型和数据结构](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FData_structures \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures\")\n\n#### 类型判断\n\n类型判断有好几种方式，分别为：\n\n- `typeof`\n  \n- `instanceof`\n  \n- `Object.prototype.toString`\n  \n- `isXXX`，比如 `isArray`\n  \n- 文档\n  \n  - [typeof](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Ftypeof \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\")\n  - [instanceof](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Finstanceof \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\")\n  - [Object.prototype.toString](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FObject%2FtoString%23using_tostring_to_detect_object_class \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#using_tostring_to_detect_object_class\")\n- 推荐文章，Issue 也挺重要\n  \n  - [JavaScript 专题之类型判断(上)](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F28 \"https://github.com/mqyqingfeng/Blog/issues/28\")\n  - [JavaScript 专题之类型判断(下)](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F30 \"https://github.com/mqyqingfeng/Blog/issues/30\")\n\n#### 类型转换\n\n类型转换算是 JS 中情况繁杂且容易出错，但是开发中还经常会遇到的知识点。强行全部记忆容易遗忘，推荐记忆及练习开发中的常见情况。\n\n- 文档\n  - [ES 标准](https://link.juejin.cn?target=https%3A%2F%2Ftc39.es%2Fecma262%2F%23sec-abstract-operations \"https://tc39.es/ecma262/#sec-abstract-operations\")\n    - 标准并不好读，如果读者英文水平欠佳，可以只阅读该小节内的表格内容。\n  - [双等判断](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FEquality \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality\")\n- 推荐文章\n  - [You Don\'t Know JS 书中关于类型转换的一章节](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fweiqinl%2FYou-Dont-Know-JS-CN%2Fblob%2Fmaster%2Ftypes%2520%2526%2520grammar%2Fch4.md \"https://github.com/weiqinl/You-Dont-Know-JS-CN/blob/master/types%20%26%20grammar/ch4.md\")\n  - [几种基本类型简单的类型转换](https://link.juejin.cn?target=https%3A%2F%2Fzh.javascript.info%2Ftype-conversions \"https://zh.javascript.info/type-conversions\")\n  - [JavaScript 深入之头疼的类型转换(上)](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F159 \"https://github.com/mqyqingfeng/Blog/issues/159\")\n  - [JavaScript 深入之头疼的类型转换(下)](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F164 \"https://github.com/mqyqingfeng/Blog/issues/164\")\n\n#### this\n\n`this` 算是不少初学者容易搞混的一个知识点，但是它很重要，务必掌握。\n\n- 文档\n  - [this](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fthis \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\")\n- 推荐文章\n  - [You Don\'t Know JS 书中关于 this 的第一章节](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgetify%2FYou-Dont-Know-JS%2Fblob%2F1st-ed%2Fthis%2520%2526%2520object%2520prototypes%2Fch1.md \"https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/this%20%26%20object%20prototypes/ch1.md\")\n  - [You Don\'t Know JS 书中关于 this 的第二章节](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgetify%2FYou-Dont-Know-JS%2Fblob%2F1st-ed%2Fthis%2520%2526%2520object%2520prototypes%2Fch2.md \"https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/this%20%26%20object%20prototypes/ch2.md\")\n  - [深入理解 js this 绑定 ( 无需死记硬背，尾部有总结和面试题解析 )](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000011194676 \"https://segmentfault.com/a/1190000011194676\")\n\n#### 闭包\n\n闭包特别常用，但是其实挺多工程师对于闭包的理解是错误的。\n\n- 文档\n  - [闭包](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FClosures \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\")\n- 推荐文章\n  - [You Don\'t Know JS 第二版中对于闭包的解释](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgetify%2FYou-Dont-Know-JS%2Fblob%2F2nd-ed%2Fscope-closures%2Fch7.md \"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch7.md\")，该版本暂无中文翻译，读者可用 [DeepL](https://link.juejin.cn?target=https%3A%2F%2Fwww.deepl.com%2Ftranslator \"https://www.deepl.com/translator\") 进行翻译。\n  - [JavaScript 的静态作用域链与“动态”闭包链](https://juejin.cn/post/6957913856488243237 \"https://juejin.cn/post/6957913856488243237\")\n  - [知乎中关于闭包的讨论](https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F34210214 \"https://www.zhihu.com/question/34210214\")\n\n#### 作用域\n\n作用域是指程序中定义变量的区域，该位置决定了变量的生命周期，也就是变量和函数的可访问范围。\n\n- 文档\n  - [作用域](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FGlossary%2FScope \"https://developer.mozilla.org/en-US/docs/Glossary/Scope\")\n  - [块作用域](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FGlossary%2FBlock%2FScripting \"https://developer.mozilla.org/en-US/docs/Glossary/Block/Scripting\")\n- 推荐文章\n  - [JavaScript 深入之词法作用域和动态作用域](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F3 \"https://github.com/mqyqingfeng/Blog/issues/3\")\n  - [JavaScript 深入之作用域链](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F6 \"https://github.com/mqyqingfeng/Blog/issues/6\")\n  - [Variable scope, closure](https://link.juejin.cn?target=https%3A%2F%2Fjavascript.info%2Fclosure \"https://javascript.info/closure\")，另有 [中文翻译版](https://link.juejin.cn?target=https%3A%2F%2Fzh.javascript.info%2Fclosure \"https://zh.javascript.info/closure\")\n  - [You Don\'t Know JS Yet: Scope & Closures](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgetify%2FYou-Dont-Know-JS%2Ftree%2F2nd-ed%2Fscope-closures \"https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed/scope-closures\")\n  - [The battle between function scope and block scope](https://link.juejin.cn?target=https%3A%2F%2Fwww.deadcoderising.com%2F2017-04-11-es6-var-let-and-const-the-battle-between-function-scope-and-block-scope%2F \"https://www.deadcoderising.com/2017-04-11-es6-var-let-and-const-the-battle-between-function-scope-and-block-scope/\")\n\n#### 变量提升\n\n变量提升（Hoisting）可以将变量和函数在编译阶段放入内存，从而在执行阶段时在声明前使用。\n\n- 文档\n  - [JS 变量提升](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FGlossary%2FHoisting \"https://developer.mozilla.org/en-US/docs/Glossary/Hoisting\")，变量提升的概念\n- 推荐文章\n  - [JavsScript 变量提升和函数提升](https://link.juejin.cn?target=https%3A%2F%2Ftowind.fun%2F2021%2F05%2F10%2Fjs-hoisting%2F \"https://towind.fun/2021/05/10/js-hoisting/\")，深度解析变量提升和函数提升，举例说明各种情况下的变量提升\n  - [我用了两个月的时间才理解 let](https://link.juejin.cn?target=https%3A%2F%2Ffangyinghang.com%2Flet-in-js%2F \"https://fangyinghang.com/let-in-js/\")，深度理解解析 let 和 val 的区别，和 let 的暂时死区\n  - [JavaScript Scoping and Hoisting](https://link.juejin.cn?target=http%3A%2F%2Fwww.adequatelygood.com%2FJavaScript-Scoping-and-Hoisting.html \"http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html\")，JavaScript 中的作用域和函数声明和变量声明的提升\n\n#### new\n\n`new` 操作符可以帮助我们构建出一个实例，并且绑定上 `this`。\n\n- 文档\n  - [new](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fnew \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new\")\n- 推荐文章\n  - [JS 的 new 到底是干什么的？](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F23987456 \"https://zhuanlan.zhihu.com/p/23987456\")\n  - [JavaScript 深入之 new 的模拟实现](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F13 \"https://github.com/mqyqingfeng/Blog/issues/13\")\n\n#### call、apply、bind\n\n- 文档\n  - [call](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fcall \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call\")，call 的概念\n  - [apply](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fapply \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\")，apply 的概念\n  - [bind](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fbind \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\")，bind 的概念\n- 推荐文章\n  - [JS 中的 call、apply、bind 方法详解](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000018270750 \"https://segmentfault.com/a/1190000018270750\")，对这三个方法的使用、面试题及具体实现做了详解\n  - [call 和 apply 的模拟实现](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F11 \"https://github.com/mqyqingfeng/Blog/issues/11\")，模拟实现 call 和 apply，帮助更好理解\n  - [bind 的模拟实现](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F12 \"https://github.com/mqyqingfeng/Blog/issues/12\")，模拟实现 bind，帮助更好理解\n\n#### 原型\n\n通过原型这种机制，JavaScript 中的对象从其他对象继承功能特性。\n\n- 文档\n  - [原型](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FLearn%2FJavaScript%2FObjects%2FObject_prototypes \"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes\")\n- 推荐文章\n  - [You Don\'t Know JS: this & Object Prototypes](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgetify%2FYou-Dont-Know-JS%2Fblob%2F1st-ed%2Fthis%2520%2526%2520object%2520prototypes%2Fch5.md \"https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/this%20%26%20object%20prototypes/ch5.md\")\n  - [深入理解 JavaScript 原型](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F1UDILezroK5wrcK-Z5bHOg \"https://mp.weixin.qq.com/s/1UDILezroK5wrcK-Z5bHOg\")\n  - [深度解析原型中的各个难点](https://juejin.cn/post/6844903575974313992 \"https://juejin.cn/post/6844903575974313992\")\n  - [Prototypes in JavaScript](https://link.juejin.cn?target=https%3A%2F%2Fbetterprogramming.pub%2Fprototypes-in-javascript-5bba2990e04b \"https://betterprogramming.pub/prototypes-in-javascript-5bba2990e04b\") 需自备梯子\n\n#### Class\n\n`class` 只是原型链的语法糖，与其它语言中的类不是同一样东西。\n\n- 文档\n  - [Class](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FGlossary%2FClass \"https://developer.mozilla.org/en-US/docs/Glossary/Class\")\n- 推荐文章\n  - [理解 JavaScript 的类](https://link.juejin.cn?target=https%3A%2F%2Fwww.digitalocean.com%2Fcommunity%2Ftutorials%2Funderstanding-classes-in-javascript \"https://www.digitalocean.com/community/tutorials/understanding-classes-in-javascript\")\n  - [Babel 是如何编译 Class 上](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F105 \"https://github.com/mqyqingfeng/Blog/issues/105\")\n  - [Babel 是如何编译 Class 下](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F106 \"https://github.com/mqyqingfeng/Blog/issues/106\")\n  - [给 ES6 class 说句公道话](https://juejin.cn/post/6924108426125508616 \"https://juejin.cn/post/6924108426125508616\")\n  - [应该在 JavaScript 中使用 Class 吗？](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F158956514 \"https://zhuanlan.zhihu.com/p/158956514\")\n\n#### 继承\n\n继承是面向对象语言（Object-Oriented Language）三大特征之一，在 JS 中也占有非常重要的地位。而想要实现继承有多种方式，它们都有各自的优缺点。\n\n- 文档\n  - [继承](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FLearn%2FJavaScript%2FObjects%2FInheritance \"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance\")\n- 推荐文章\n  - [JavaScript 深入之继承的多种方式和优缺点](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F16 \"https://github.com/mqyqingfeng/Blog/issues/16\")\n  - [JavaScript 中的继承](https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2F%40happymishra66%2Finheritance-in-javascript-21d2b82ffa6f \"https://medium.com/@happymishra66/inheritance-in-javascript-21d2b82ffa6f\")，需自备梯子\n  - [JS 类继承](https://link.juejin.cn?target=https%3A%2F%2Fjavascript.info%2Fclass-inheritance \"https://javascript.info/class-inheritance\")，另有 [中文翻译版](https://link.juejin.cn?target=https%3A%2F%2Fzh.javascript.info%2Fclass-inheritance \"https://zh.javascript.info/class-inheritance\")\n\n#### 模块化\n\n这块知识必会，最好了解下模块化的前世今生以及对 ES6 的原生模块化有个深入的理解。\n\n- 文档\n  - [Modules](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FModules \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules\")\n- 推荐文章\n  - [【深度全面】前端 JavaScript 模块化规范进化论](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000023711059 \"https://segmentfault.com/a/1190000023711059\")，记录了 JS 模块化的进化之路\n  - [JavaScript modules](https://link.juejin.cn?target=https%3A%2F%2Fv8.dev%2Ffeatures%2Fmodules \"https://v8.dev/features/modules\")，由浅入深解释 JS 模块化\n  - [ES modules: A cartoon deep-dive](https://link.juejin.cn?target=https%3A%2F%2Fhacks.mozilla.org%2F2018%2F03%2Fes-modules-a-cartoon-deep-dive%2F \"https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/\")，一篇对 JS 模块化深入解释的文章，另有 [中文版](https://juejin.cn/post/6844903591979778061 \"https://juejin.cn/post/6844903591979778061\")\n\n#### Promise\n\n- 文档\n  - [Promise](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FPromise \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\")\n  - [Promises/A+ 规范](https://link.juejin.cn?target=https%3A%2F%2Fpromisesaplus.com%2F \"https://promisesaplus.com/\")\n- 推荐文章\n- [Callbacks Vs Promises and basics of JS](https://link.juejin.cn?target=https%3A%2F%2Ftheflyingmantis.medium.com%2Fcallbacks-vs-promises-and-basics-of-js-80d3d1515e81 \"https://theflyingmantis.medium.com/callbacks-vs-promises-and-basics-of-js-80d3d1515e81\")，需自备梯子\n- [最简实现 Promise，支持异步链式调用（20 行）](https://juejin.cn/post/6844904094079926286 \"https://juejin.cn/post/6844904094079926286\")\n- [100 行代码实现 Promises/A+ 规范](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FqdJ0Xd8zTgtetFdlJL3P1g \"https://mp.weixin.qq.com/s/qdJ0Xd8zTgtetFdlJL3P1g\")\n- Github\n- [promise-fun](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsindresorhus%2Fpromise-fun \"https://github.com/sindresorhus/promise-fun\")\n\n#### 迭代器与生成器\n\n- 文档\n  - [迭代器与生成器](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FIterators_and_Generators \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators\")\n- 推荐文章\n  - [\\[译\\] 什么是 JavaScript 生成器？如何使用生成器？](https://juejin.cn/post/6844903616357072910 \"https://juejin.cn/post/6844903616357072910\")\n  - [Understanding Generators in ES6 JavaScript with Examples](https://link.juejin.cn?target=https%3A%2F%2Fcodeburst.io%2Funderstanding-generators-in-es6-javascript-with-examples-6728834016d5 \"https://codeburst.io/understanding-generators-in-es6-javascript-with-examples-6728834016d5\")，需自备梯子\n  - [A Simple Guide to ES6 Iterators in JavaScript with Examples](https://link.juejin.cn?target=https%3A%2F%2Fcodeburst.io%2Fa-simple-guide-to-es6-iterators-in-javascript-with-examples-189d052c3d8e \"https://codeburst.io/a-simple-guide-to-es6-iterators-in-javascript-with-examples-189d052c3d8e\")，需自备梯子\n\n#### async await\n\n- 文档\n  - [async](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Fasync_function \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\")\n  - [await](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fawait \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await\")\n- 推荐文章\n  - [手写 async await 的最简实现（20 行）](https://juejin.cn/post/6844904102053281806 \"https://juejin.cn/post/6844904102053281806\")\n  - [Babel 将 Generator 编译成了什么样子](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F102 \"https://github.com/mqyqingfeng/Blog/issues/102\")\n\n#### 事件循环\n\n大家都知道 JS 是一门单线程的非阻塞的脚本语言。这也就意味着，代码在执行的任何时候只有一个主线程来处理所有的任务。所以弄懂事件循环机制对我们学习 JS 至关重要。\n\n- 文档\n  - [事件循环](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FEventLoop \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\")\n- 推荐文章\n  - [这一次，彻底弄懂 JavaScript 执行机制](https://juejin.cn/post/6844903512845860872 \"https://juejin.cn/post/6844903512845860872\")\n  - [一次弄懂 Event Loop](https://juejin.cn/post/6844903764202094606 \"https://juejin.cn/post/6844903764202094606\")\n  - [JavaScript 的工作原理](https://link.juejin.cn?target=https%3A%2F%2Fblog.sessionstack.com%2Fhow-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5 \"https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5\")，需自备梯子，另有 [中文翻译版](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FTroland%2Fhow-javascript-works%2Fblob%2Fmaster%2Fevent-loop.md \"https://github.com/Troland/how-javascript-works/blob/master/event-loop.md\")。\n- 事件循环可视化\n  - [Loupe](https://link.juejin.cn?target=http%3A%2F%2Flatentflip.com%2Floupe%2F%3Fcode%3DJC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%253D \"http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D\")\n\n#### 节流与防抖\n\n节流指连续触发事件的情况下，在某个时间段内，函数只会执行一次。 防抖指在事件被触发一定时间后再执行回调函数，如果在一定时间内该事件又被重复触发，则重启计时。\n\n- 推荐文章\n  - [函数防抖与函数节流](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F38313717 \"https://zhuanlan.zhihu.com/p/38313717\")\n  - [浅谈 JS 防抖和节流](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000018428170 \"https://segmentfault.com/a/1190000018428170\")\n  - [Debounce – How to Delay a Function in JavaScript](https://link.juejin.cn?target=https%3A%2F%2Fwww.freecodecamp.org%2Fnews%2Fjavascript-debounce-example \"https://www.freecodecamp.org/news/javascript-debounce-example\")\n  - [Debouncing and Throttling in JavaScript](https://link.juejin.cn?target=https%3A%2F%2Fwww.telerik.com%2Fblogs%2Fdebouncing-and-throttling-in-javascript \"https://www.telerik.com/blogs/debouncing-and-throttling-in-javascript\")\n\n#### 柯里化\n\n柯里化就是将接收多个参数的函数转换成接收一个参数的函数。\n\n- 推荐文章\n  - [柯里化（Currying）](https://link.juejin.cn?target=https%3A%2F%2Fzh.javascript.info%2Fcurrying-partials \"https://zh.javascript.info/currying-partials\")\n  - [JavaScript 专题之函数柯里化](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F42 \"https://github.com/mqyqingfeng/Blog/issues/42\")\n  - [Understanding Currying in JavaScript](https://link.juejin.cn?target=https%3A%2F%2Fblog.bitsrc.io%2Funderstanding-currying-in-javascript-ceb2188c339 \"https://blog.bitsrc.io/understanding-currying-in-javascript-ceb2188c339\")，需自备梯子，另有 [中文翻译版](https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2FGeniusLyzh%2Fp%2F9937829.html \"https://www.cnblogs.com/GeniusLyzh/p/9937829.html\")\n\n#### 垃圾回收\n\nJavaScrip 在变量被创建时分配内存，并在对象不再使用时自动释放内存，这个过程被称为垃圾回收。另外我们主要学习 V8 引擎下的垃圾回收机制。\n\n- 文档\n  - [内存管理 & 垃圾回收](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FMemory_Management \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management\")\n- 推荐文章\n  - [深入理解 Chrome V8 垃圾回收机制](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyacan8%2Fblog%2Fissues%2F33 \"https://github.com/yacan8/blog/issues/33\")，该文章的参考文献也可阅读下\n  - [GC in v8](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flrlna%2Fsketchin%2Fblob%2Fmaster%2Fguides%2Fgarbage-collection-in-v8.md \"https://github.com/lrlna/sketchin/blob/master/guides/garbage-collection-in-v8.md\")\n  - [JavaScript 工作原理：内存管理 + 处理常见的 4 种内存泄漏](https://link.juejin.cn?target=https%3A%2F%2Fblog.sessionstack.com%2Fhow-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec \"https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec\")，另有[中文版](https://juejin.cn/post/6844903519078580238 \"https://juejin.cn/post/6844903519078580238\")\n\n#### 其他零散但重要的知识点\n\n- [0.1 + 0.2 !== 0.3](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F225490777 \"https://zhuanlan.zhihu.com/p/225490777\")，JS 浮点数会造成的问题\n\n**如果你觉得以上内容对你有帮助，可以前往 [Github](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FKieSun%2Ffucking-frontend \"https://github.com/KieSun/fucking-frontend\") 点个 Star 支持一下。**\n\n### HTML\n\n#### 语义化\n\nhtml 语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析。在没有引入样式 CCS 样式的时候也能以一种可以分辨出来大致表示内容的文档格式显示，并且是容易阅读的。 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。\n\n- 文档\n  - [HTML 中的语义](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FGlossary%2FSemantics%23semantics_in_html \"https://developer.mozilla.org/en-US/docs/Glossary/Semantics#semantics_in_html\")，什么是 HTML 语义化，HTML 语义化有什么好处\n- 推荐文章\n  - [IFE-NOTE：页面结构语义化](https://link.juejin.cn?target=https%3A%2F%2Frainylog.com%2Fpost%2Fife-note-1%2F \"https://rainylog.com/post/ife-note-1/\")，HTML5 语义化中的页面结构语义化的一些经验和理解\n  - [关于 HTML 语义和前端架构](https://link.juejin.cn?target=http%3A%2F%2Fnicolasgallagher.com%2Fabout-html-semantics-front-end-architecture%2F \"http://nicolasgallagher.com/about-html-semantics-front-end-architecture/\")，HTML 语义化在开发中配合 CSS 结构化类名的使用构建可重用和可组合的组件\n\n### CSS\n\n- 推荐文章\n  - [一文梳理 CSS 必会知识点](https://juejin.cn/post/6854573212337078285 \"https://juejin.cn/post/6854573212337078285\")\n\n#### 盒子模型\n\n在 CSS 中，所有的元素都被一个个的“盒子（box）”包围着，我们广泛地使用两种“盒子” —— 块级盒子 (block box) 和 内联盒子 (inline box)，理解这些“盒子”的基本原理，是我们使用 CSS 实现准确布局、处理元素排列的关键。\n\n- 文档\n  - [CSS 盒子模型](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FLearn%2FCSS%2FBuilding_blocks%2FThe_box_model \"https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model\")，官方文档深入了解 CSS 盒子模型\n- 推荐文章\n  - [CSS 盒模型之内边距、边框、外边距 十九问](https://juejin.cn/post/6880111680153059341 \"https://juejin.cn/post/6880111680153059341\")，通过举例说明盒子模型各种常见形态和问题\n  - [CSS Box Model](https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FTR%2Fcss-box-3%2F \"https://www.w3.org/TR/css-box-3/\")，盒子模型的一些规范介绍\n  - [CSS 盒模型详解（图文教程）](https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fqianguyihao%2Fp%2F7256371.html \"https://www.cnblogs.com/qianguyihao/p/7256371.html\")，通过图片和例子说明盒子模型的各个部分和在页面上的表现形式\n\n#### 选择器\n\nCSS 中，选择器用来指定网页上我们想要样式化的 HTML 元素。CSS 选择器提供了很多种方法，所以在选择要样式化的元素时，我们可以做到很精细的地步。\n\nCSS 选择器是 CSS 规则的第一部分。它是元素和其他部分组合起来告诉浏览器哪个 HTML 元素应当是被选为应用规则中的 CSS 属性值的方式。选择器所选择的元素，叫做“选择器的对象”。\n\n- 文档\n  - [CSS 选择器](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FLearn%2FCSS%2FBuilding_blocks%2FSelectors \"https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors\")，官方文档详细地讲授选择器的不同使用方式，并了解它们的工作原理。\n- 推荐文章\n  - [30 个你必须熟记的 CSS 选择器](https://link.juejin.cn?target=https%3A%2F%2Fcode.tutsplus.com%2Fzh-hans%2Ftutorials%2Fthe-30-css-selectors-you-must-memorize--net-16048 \"https://code.tutsplus.com/zh-hans/tutorials/the-30-css-selectors-you-must-memorize--net-16048\")，开发中常用的 CSS 选择器，熟练掌握以后可以很大程度提高 CSS 的编码体验\n  - [深入解析 CSS 样式优先级](https://link.juejin.cn?target=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2Farticle%2F1545341 \"https://cloud.tencent.com/developer/article/1545341\")，详细介绍了 CSS 样式的权重优先级，避免写重复样式和样式被覆盖不生效的问题\n\n#### Flex\n\n- 文档\n  - [flexbox](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FCSS%2FCSS_Flexible_Box_Layout%2FBasic_Concepts_of_Flexbox \"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox\")\n- 推荐文章\n  - [A Complete Guide to Flexbox](https://link.juejin.cn?target=https%3A%2F%2Fcss-tricks.com%2Fsnippets%2Fcss%2Fa-guide-to-flexbox%2F \"https://css-tricks.com/snippets/css/a-guide-to-flexbox/\")\n  - [Flexbox 布局中不为人知的细节](https://juejin.cn/post/6938292463605907492 \"https://juejin.cn/post/6938292463605907492\")\n- 实战\n  - [FLEXBOX FROGGY](https://link.juejin.cn?target=https%3A%2F%2Fflexboxfroggy.com%2F \"https://flexboxfroggy.com/\") 一个趣味性小游戏学习 Flex 的网站\n\n#### grid\n\n- 文档\n  - [grid](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FCSS%2FCSS_Grid_Layout%2FBasic_Concepts_of_Grid_Layout \"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout\")\n- 推荐文档\n  - [A Complete Guide to Grid](https://link.juejin.cn?target=https%3A%2F%2Fcss-tricks.com%2Fsnippets%2Fcss%2Fcomplete-guide-grid%2F \"https://css-tricks.com/snippets/css/complete-guide-grid/\")\n  - [最强大的 CSS 布局 —— Grid 布局](https://juejin.cn/post/6854573220306255880 \"https://juejin.cn/post/6854573220306255880\")\n\n#### 其他\n\n- 推荐文档\n  - [详谈层合成（composite)](https://link.juejin.cn?target=http%3A%2F%2Fjartto.wang%2F2017%2F09%2F29%2Fexpand-on-performance-composite%2F \"http://jartto.wang/2017/09/29/expand-on-performance-composite/\")\n  - [移动设备如何实现真正 1px 的线？](https://link.juejin.cn?target=https%3A%2F%2Fjinlong.github.io%2F2015%2F05%2F24%2Fcss-retina-hairlines%2F \"https://jinlong.github.io/2015/05/24/css-retina-hairlines/\")\n\n## 框架\n\n框架一般选其一深入学习即可。\n\n### 虚拟 DOM\n\nVirtual DOM 也就是虚拟节点。通过 JS 的 Object 对象模拟 DOM 中的真实节点对象，再通过特定的 render 方法将其渲染成真实的 DOM 节点。\n\n- 文档\n  - [React 官网介绍](https://link.juejin.cn?target=https%3A%2F%2Freactjs.org%2Fdocs%2Ffaq-internals.html \"https://reactjs.org/docs/faq-internals.html\")\n- 推荐文章\n  - [Virtual Dom 和 Diff 算法在 React 中是如何工作的？](https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2F%40gethylgeorge%2Fhow-virtual-dom-and-diffing-works-in-react-6fc805f9f84e \"https://medium.com/@gethylgeorge/how-virtual-dom-and-diffing-works-in-react-6fc805f9f84e\")，需自备梯子\n  - [React 核心知识点 -- Virtual Dom 与 Diff](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fpfan123%2FArticles%2Fissues%2F62 \"https://github.com/pfan123/Articles/issues/62\")\n\n### 路由\n\n路由在 SPA 架构中都有被用到，实际原理就是运用 `hash` 及 `history` 相关的 API 实现。\n\n- 文档\n  - [hashchange](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FWindow%2Fhashchange_event \"https://developer.mozilla.org/en-US/docs/Web/API/Window/hashchange_event\")\n  - [history](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FHistory \"https://developer.mozilla.org/en-US/docs/Web/API/History\")\n- 推荐文章\n  - [前端路由简介以及 vue-router 实现原理](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F37730038 \"https://zhuanlan.zhihu.com/p/37730038\")，对前端路由及 Vue-Route 库原理做了解释，**几个框架的路由库原理都一致**\n\n## React\n\n学习框架务必从[文档](https://link.juejin.cn?target=https%3A%2F%2Freactjs.org%2F \"https://reactjs.org/\")出发，起码熟读一遍及自己写过一些初步的 Demo 之后再考虑学习别的资料。\n\n### React 推荐学习路径\n\n![reactStudypng](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec39552dd0c84985bedb861ba7cb09f5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n大家可以跟着以上学习路径学习，其中除了概念相关的内容是必须学习之外，生态相关的内容大家可以在使用时再学习。\n\n### React 推荐学习资料\n\n- [React 学习之道](https://link.juejin.cn?target=https%3A%2F%2Fleanpub.com%2Fthe-road-to-learn-react-chinese%2F \"https://leanpub.com/the-road-to-learn-react-chinese/\")，可以 0 元购买\n- [React 生命周期](https://link.juejin.cn?target=https%3A%2F%2Fprojects.wojtekmaj.pl%2Freact-lifecycle-methods-diagram%2F \"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\")\n\n### 如何编写一个组件\n\n- 文档\n  - [React 官方文档](https://link.juejin.cn?target=https%3A%2F%2Freactjs.org%2Fdocs%2Fcomponents-and-props.html \"https://reactjs.org/docs/components-and-props.html\")\n- 推荐文章\n  - [\\[译\\]React 函数组件和类组件的差异](https://link.juejin.cn?target=https%3A%2F%2Fjishuin.proginn.com%2Fp%2F763bfbd4cad4 \"https://jishuin.proginn.com/p/763bfbd4cad4\")\n  - [寫 React Components 該注意的 6 個地方與技巧](https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2F%40chihsuan%2F%25E5%25AF%25AB-react-components-%25E8%25A9%25B2%25E6%25B3%25A8%25E6%2584%258F%25E7%259A%25846%25E5%2580%258B%25E5%259C%25B0%25E6%2596%25B9%25E8%2588%2587%25E6%258A%2580%25E5%25B7%25A7-faa2bb87a18e \"https://medium.com/@chihsuan/%E5%AF%AB-react-components-%E8%A9%B2%E6%B3%A8%E6%84%8F%E7%9A%846%E5%80%8B%E5%9C%B0%E6%96%B9%E8%88%87%E6%8A%80%E5%B7%A7-faa2bb87a18e\")\n  - [编写高效且可读组件的 5 个最佳实践](https://link.juejin.cn?target=https%3A%2F%2Fwww.infoq.cn%2Farticle%2Fry4icky5crb1pokvi0ql \"https://www.infoq.cn/article/ry4icky5crb1pokvi0ql\")\n  - [designing-react-components-best-practices](https://link.juejin.cn?target=https%3A%2F%2Fwww.thisdot.co%2Fblog%2Fdesigning-react-components-best-practices \"https://www.thisdot.co/blog/designing-react-components-best-practices\")\n  - [React 复合组件](https://link.juejin.cn?target=https%3A%2F%2Fwww.smashingmagazine.com%2F2021%2F08%2Fcompound-components-react%2F \"https://www.smashingmagazine.com/2021/08/compound-components-react/\")\n\n### 受控组件和非受控组件\n\n- 受控组件：在 HTML 中，表单元素（如 input、 textarea 和 select ）通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState() 或者 props 来更新\n  \n- 非受控组件：是一个存储其自己的内部状态，并且您使用查询 DOM ref，当你需要它来找到它的当前值，这有点像传统的 HTML\n  \n- 文档\n  \n  - [React 官方文档](https://link.juejin.cn?target=https%3A%2F%2Freactjs.org%2Fdocs%2Funcontrolled-components.html \"https://reactjs.org/docs/uncontrolled-components.html\")\n- 推荐文章\n  \n  - [受控和非受控组件真的那么难理解吗](https://juejin.cn/post/6858276396968951822 \"https://juejin.cn/post/6858276396968951822\")\n  - [\\[译\\]受控组件 & 非受控组件](https://link.juejin.cn?target=https%3A%2F%2Fwww.baobangdong.cn%2Fcontrolled-components-and-uncontrolled-components%2F \"https://www.baobangdong.cn/controlled-components-and-uncontrolled-components/\")\n\n### 高阶组件（HOC）\n\n高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。\n\n具体而言，高阶组件是参数为组件，返回值为新组件的函数。\n\n- 文档\n  - [React 官方文档](https://link.juejin.cn?target=https%3A%2F%2Freactjs.org%2Fdocs%2Fhigher-order-components.html \"https://reactjs.org/docs/higher-order-components.html\")\n- 推荐文章\n  - [React 高阶组件(HOC)入门指南](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FMrErHu%2Fblog%2Fissues%2F4 \"https://github.com/MrErHu/blog/issues/4\")\n  - [hoc 库 recompose](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Facdlite%2Frecompose \"https://github.com/acdlite/recompose\")\n  - [精读 React 高阶组件](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F27434557 \"https://zhuanlan.zhihu.com/p/27434557\")\n\n### Hooks\n\nHook 是 React 16.8 的新增特性。它可以让你在不编写类组件的情况下使用 React 的特性。\n\n- 文档\n  - [React Hooks 官方文档](https://link.juejin.cn?target=https%3A%2F%2Fzh-hans.reactjs.org%2Fdocs%2Fhooks-intro.html \"https://zh-hans.reactjs.org/docs/hooks-intro.html\")\n- 推荐文章\n  - [彻底理解 React hook useCallback 和 useMemo 的区别](https://juejin.cn/post/6844904032113278990 \"https://juejin.cn/post/6844904032113278990\")\n  - [React hooks 最佳实践](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F0sykIHDM_Ih3W3md-DwFkw \"https://mp.weixin.qq.com/s/0sykIHDM_Ih3W3md-DwFkw\")\n\n### 合成事件\n\n合成事件（SyntheticEvent）是 React 模拟原生 DOM 事件所有能力的一个事件对象，即浏览器原生事件的跨浏览器包装器。React 根据 [W3C 规范](https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FTR%2FDOM-Level-3-Events%2F \"https://www.w3.org/TR/DOM-Level-3-Events/\") 定义了合成事件。需要注意的是 v16 和 17 版本中的合成事件有差异。\n\n- 文档\n  - [React 官方文档](https://link.juejin.cn?target=https%3A%2F%2Freactjs.org%2Fdocs%2Fevents.html \"https://reactjs.org/docs/events.html\")\n- 推荐文章\n  - [探索 React 合成事件](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000038251163 \"https://segmentfault.com/a/1190000038251163\")\n  - [大佬，怎么办？升级 React17，Toast 组件不能用了](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F380941094 \"https://zhuanlan.zhihu.com/p/380941094\")\n  - [What’s the Difference Between Synthetic React Events and JavaScript Events?](https://link.juejin.cn?target=https%3A%2F%2Fbetterprogramming.pub%2Fwhats-the-difference-between-synthetic-react-events-and-javascript-events-ba7dbc742294 \"https://betterprogramming.pub/whats-the-difference-between-synthetic-react-events-and-javascript-events-ba7dbc742294\")，需自备梯子\n  - [React 17 removes event pooling in the modern browsers](https://link.juejin.cn?target=https%3A%2F%2Fblog.saeloun.com%2F2021%2F04%2F06%2Freact-17-removes-event-pooling-in-modern-system.html \"https://blog.saeloun.com/2021/04/06/react-17-removes-event-pooling-in-modern-system.html\")\n\n### React 路由\n\n- [react-router](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fremix-run%2Freact-router \"https://github.com/remix-run/react-router\")，React 声明式路由\n- [reach router](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Freach%2Frouter \"https://github.com/reach/router\")，下一代的 React 路由\n\n### React 状态管理\n\nReact 状态管理可谓百花齐放百家争鸣，远远不止笔者列的这些库。但是实际上很多项目完全是不需要用到状态管理的，反而是增加编码复杂度，其实利用 React Context 或者 [react-query](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftannerlinsley%2Freact-query \"https://github.com/tannerlinsley/react-query\") 这类接口请求库就能很好地满足需求了。\n\n- [redux](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Freduxjs%2Fredux \"https://github.com/reduxjs/redux\")，JS 应用的状态容器，提供可预测的状态管理\n- [mobx](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmobxjs%2Fmobx \"https://github.com/mobxjs/mobx\")，简单，可扩展的状态管理库\n- [recoil](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebookexperimental%2FRecoil \"https://github.com/facebookexperimental/Recoil\")，React 状态管理库\n- [xstate](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fstatelyai%2Fxstate \"https://github.com/statelyai/xstate\")，有限状态机\n- [zustand](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fpmndrs%2Fzustand \"https://github.com/pmndrs/zustand\")，简单、快速和可扩展的骨状态管理解决方案\n\n### React 接口请求\n\n- [axios](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faxios%2Faxios \"https://github.com/axios/axios\")，传统接口请求库\n- [react-query](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftannerlinsley%2Freact-query \"https://github.com/tannerlinsley/react-query\")，用于获取、缓存和更新 React 中异步数据的 Hooks 接口请求库\n- [swr](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvercel%2Fswr \"https://github.com/vercel/swr\")，用于数据请求的 React Hooks 库\n\n### React SSR\n\n- [nest.js](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fnestjs%2Fnest \"https://github.com/nestjs/nest\")，一个渐进式的 Node.js 框架，用于构建高效、可靠和可扩展的服务端应用。\n\n### React 单测\n\n- [jest](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Fjest \"https://github.com/facebook/jest\")，优雅、简洁的 JavaScript 测试框架，单测必选项\n- [react-testing-library](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftesting-library%2Freact-testing-library \"https://github.com/testing-library/react-testing-library\")，简单且完整的 React DOM 测试工具\n\n### React CSS 方案\n\n- [styled-components](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fstyled-components%2Fstyled-components \"https://github.com/styled-components/styled-components\")，CSS in JS 方案\n- [tailwindcss](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftailwindlabs%2Ftailwindcss \"https://github.com/tailwindlabs/tailwindcss\")，Atom CSS 方案\n\n### React 原理\n\n- [react-source-code-debug](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fneroneroffy%2Freact-source-code-debug \"https://github.com/neroneroffy/react-source-code-debug\")，学习如何调试源码\n- [react-illustration-series](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2F7kms%2Freact-illustration-series \"https://github.com/7kms/react-illustration-series\")，图解 react 源码，用大量配图的方式，致力于将 react 原理表述清楚\n- [just-react](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FBetaSu%2Fjust-react \"https://github.com/BetaSu/just-react\")，「React 技术揭秘」，一本自顶向下的 React 源码分析书\n- [tiny-react](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FPiNengShaoNian%2Ftiny-react \"https://github.com/PiNengShaoNian/tiny-react\")，基于 React17 精简而来的最小版实现\n\n### Blog 推荐\n\n- [Dan Abramov](https://link.juejin.cn?target=https%3A%2F%2Foverreacted.io%2F \"https://overreacted.io/\")，React 核心开发者的 Blog\n\n## Vue\n\n学习框架务必从[文档](https://link.juejin.cn?target=https%3A%2F%2Fvuejs.org%2F \"https://vuejs.org/\")出发，起码熟读一遍及自己写过一些初步的 Demo 之后再考虑学习别的资料。\n\n对于 Vue 来说，官方文档内容相当齐全，并且全家桶也都是官方出的，因此无需头疼技术栈选型。\n\n### Vue 推荐学习路径\n\n目前 3.0 生态并不完善，在公司内部基本需要先熟悉 2.0 的写法，因此推荐新手先学习 2.0 的内容。\n\n- [新手向：Vue 2.0 的建议学习顺序](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F23134551 \"https://zhuanlan.zhihu.com/p/23134551\")，尤雨溪自己写的学习路径，时至今日也不过时\n\n### Vue 推荐学习资料\n\n- [awesome-vue](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fawesome-vue \"https://github.com/vuejs/awesome-vue\")\n- [vue-patterns](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flearn-vuejs%2Fvue-patterns \"https://github.com/learn-vuejs/vue-patterns\")，有用的 Vue 模式、技巧、提示以及有帮助的精选链接\n\n### Vue 原理\n\n- [vue-analysis](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fustbhuangyi%2Fvue-analysis \"https://github.com/ustbhuangyi/vue-analysis\")，黄老师出品\n- [vue-design](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FHcySunYang%2Fvue-design \"https://github.com/HcySunYang/vue-design\")，官方人员出品，域名已过期，需要大家自行在仓库内浏览内容。虽然麻烦了点，但是质量绝对过关\n\n## 浏览器\n\n一般说到浏览器，常指的都是 Chrome。浏览器作为前端不可或缺的载体，我们势必需要好好学习及掌握其相关的知识。\n\n**另外浏览器中涉及到的知识面很多，与 JS 执行机制、网络、性能优化、安全等领域都有关联，因此大家在学习这部分的内容时需要多与之前学习的知识联系起来。**\n\n### 架构\n\n- [Inside look at modern web browser](https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2018%2F09%2Finside-browser-part1 \"https://developers.google.com/web/updates/2018/09/inside-browser-part1\")，这是一个 Google 出的系列专栏，共有四篇文章，内容上到浏览器的整体架构，下至页面的渲染规则都说了一遍，另有 [中文翻译](https://link.juejin.cn?target=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2Farticle%2F1806716 \"https://cloud.tencent.com/developer/article/1806716\")\n\n### 整体流程\n\n- [浏览器的工作原理：新式网络浏览器幕后揭秘](https://link.juejin.cn?target=https%3A%2F%2Fwww.html5rocks.com%2Fzh%2Ftutorials%2Finternals%2Fhowbrowserswork%2F \"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/\")，这虽然是一篇 11 年的文章，但是内容在如今也不过时，文章广为流传\n- [当···时发生了什么？](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fskyline75489%2Fwhat-happens-when-zh_CN \"https://github.com/skyline75489/what-happens-when-zh_CN\")，经典面试题，文中对于这个流程里的相关内容力求尽可能具体，不遗漏任何细节\n- [从输入 URL 到页面加载完成的过程中都发生了什么事情？](https://link.juejin.cn?target=https%3A%2F%2Ffex.baidu.com%2Fblog%2F2014%2F05%2Fwhat-happen%2F \"https://fex.baidu.com/blog/2014/05/what-happen/\")，这篇文章涉及了大量网络及硬件知识\n\n### 渲染相关\n\n- [浏览器的渲染原理简介](https://link.juejin.cn?target=https%3A%2F%2Fcoolshell.cn%2Farticles%2F9666.html \"https://coolshell.cn/articles/9666.html\")，左耳朵耗子出品，如果上文「浏览器的工作原理：新式网络浏览器幕后揭秘」觉得太长不看或者看完觉得没看懂什么，那么可以来阅读下本文，起码能从中学会一些能用在工作上的东西\n- [浏览器的回流与重绘 (Reflow & Repaint)](https://juejin.cn/post/6844903569087266823 \"https://juejin.cn/post/6844903569087266823\")\n\n### JS 执行机制\n\n- [从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000012925872 \"https://segmentfault.com/a/1190000012925872\")，超长文，这篇文章能让你对进程线程，浏览器多进程、浏览器内核多线程、JS 单线程、JS 运行机制有个不错的理解\n\n### 缓存\n\n- [文档](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCaching \"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching\")\n- [彻底理解浏览器的缓存机制](https://juejin.cn/post/6844903593275817998 \"https://juejin.cn/post/6844903593275817998\")，浏览器缓存机制与性能优化息息相关\n\n### Devtools\n\n- [Chrome DevTools](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.chrome.com%2Fdocs%2Fdevtools%2F \"https://developer.chrome.com/docs/devtools/\")，Google 出的 DevTools 的使用说明书，对于每个功能的使用都有详细的介绍，看啥文章都不如看这个\n- [Chrome\\_Devtools\\_Tricks](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdendoink%2FFrontendWingman%2Ftree%2Fmaster%2FChrome_Devtools_Tricks \"https://github.com/dendoink/FrontendWingman/tree/master/Chrome_Devtools_Tricks\")，介绍了 Chrome DevTools 的使用技巧，从不同的情景来说明应该如何搭配使用 Chrome DevTools 中的小技巧，适合英文不怎么好的读者阅读\n\n### 浏览器安全\n\n- [文档](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FSecurity \"https://developer.mozilla.org/en-US/docs/Web/Security\")\n- [一文读懂 Web 安全](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000023396707 \"https://segmentfault.com/a/1190000023396707\")，简单介绍了一些前端需要注意的安全知识\n- [the-book-of-secret-knowledge](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftrimstray%2Fthe-book-of-secret-knowledge \"https://github.com/trimstray/the-book-of-secret-knowledge\")，如果你对安全领域有兴趣，可以阅读下这个仓库的内容\n\n## 性能优化\n\n性能优化是一个系统性工程，涉及到的方面很多，不仅仅只是大家常说的静态文件和代码优化那么简单。\n\n大家学习这部分内容的时候可以先从推荐的文章中了解具体有哪些性能优化手段及具体方法，然后根据这些内容去实验。\n\n### 推荐书籍\n\n其实性能优化相关的书籍市面上出的不多，优秀的也都是好几年前的老书了，看不看也无所谓了。\n\n- [Web 性能权威指南](https://link.juejin.cn?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F25856314%2F \"https://book.douban.com/subject/25856314/\")，豆瓣 8.9 分，老书\n- [高性能网站建设进阶指南](https://link.juejin.cn?target=https%3A%2F%2Fbook.douban.com%2Fsubject%2F4719162%2F \"https://book.douban.com/subject/4719162/\")，豆瓣 8.9 分，老书\n\n### 推荐网站\n\n- [web.dev](https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2F \"https://web.dev/\")，Google 自家的 blog，你能在这上面学到很多性能优化及如何做好用户体验的知识，其实很多市面上的文章内容都有这个网站的影子\n\n### 整体优化建议\n\n- [前端性能优化 24 条建议（2020）](https://juejin.cn/post/6892994632968306702 \"https://juejin.cn/post/6892994632968306702\")，类似现代版雅虎军规\n- [前端性能优化之旅](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Falienzhou%2Ffe-performance-journey \"https://github.com/alienzhou/fe-performance-journey\")，系统性介绍性能优化的手段，参考资料也值得学习\n- [Front-End Performance Checklist 2021](https://link.juejin.cn?target=https%3A%2F%2Fwww.smashingmagazine.com%2F2021%2F01%2Ffront-end-performance-2021-free-pdf-checklist%2F \"https://www.smashingmagazine.com/2021/01/front-end-performance-2021-free-pdf-checklist/\")，一本很火的免费 PDF，包含了很多性能优化相关的 Checklist\n- [React 性能优化 | 包括原理、技巧、Demo、工具使用](https://juejin.cn/post/6935584878071119885 \"https://juejin.cn/post/6935584878071119885\")\n\n### 性能指标\n\n- [文档](https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Flearn-web-vitals%2F \"https://web.dev/learn-web-vitals/\")\n- [还在看那些老掉牙的性能优化文章么？这些最新性能指标了解下](https://juejin.cn/post/6850037270729359367 \"https://juejin.cn/post/6850037270729359367\")，文章会介绍谷歌提倡的七个用户体验指标（也可以认为是性能指标）\n- [做性能优化时，我们关注哪些指标？](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FSlS0J9eSb20PCLW062sQVg \"https://mp.weixin.qq.com/s/SlS0J9eSb20PCLW062sQVg\")\n\n### 性能监控\n\n- [前端搞工程化：从零打造性能检测库「源码 + 视频」](https://juejin.cn/post/6919295789630455815 \"https://juejin.cn/post/6919295789630455815\")，光会性能优化的手段还是不够的，如何体现优化的价值也是至关重要的\n\n## TypeScript\n\nTypeScript 是为开发大型应用而设计的，并且 TypeScript 可转译成 JavaScript。由于 TypeScript 是 JavaScript 的严格超集，任何现有的 JavaScript 程序都是合法的 TypeScript 程序。\n\n文档\n\n- [TypeScript 官方文档](https://link.juejin.cn?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2F \"https://www.typescriptlang.org/docs/\")\n\n推荐文章\n\n- [TypeScript 入门教程](https://link.juejin.cn?target=https%3A%2F%2Fts.xcatliu.com%2F \"https://ts.xcatliu.com/\")\n- [TypeScript 的另一面：类型编程](https://juejin.cn/post/6989796543880495135 \"https://juejin.cn/post/6989796543880495135\")\n- [TypeScript Deep Dive](https://link.juejin.cn?target=https%3A%2F%2Fbasarat.gitbook.io%2Ftypescript%2F \"https://basarat.gitbook.io/typescript/\") 另有[中文版](https://link.juejin.cn?target=https%3A%2F%2Fjkchao.github.io%2Ftypescript-book-chinese%2F \"https://jkchao.github.io/typescript-book-chinese/\")\n\n推荐开源项目\n\n- [TypeScript-for-Beginner-Programmers](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fchibicode%2FTypeScript-for-Beginner-Programmers \"https://github.com/chibicode/TypeScript-for-Beginner-Programmers\") 需自备梯子\n- [type-challenges](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftype-challenges%2Ftype-challenges \"https://github.com/type-challenges/type-challenges\")\n- [TypeScript exercises](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftypescript-exercises%2Ftypescript-exercises \"https://github.com/typescript-exercises/typescript-exercises\")\n\n## Electron\n\nElectron 是一个可以使用 Web 技术如 JavaScript、HTML 和 CSS 来创建跨平台原生桌面应用的框架。借助 Electron，我们可以使用纯 JavaScript 来调用丰富的原生 APIs。\n\n文档\n\n- [Electron 官网](https://link.juejin.cn?target=https%3A%2F%2Fwww.electronjs.org%2F \"https://www.electronjs.org/\")\n- [Electron 中文教程](https://link.juejin.cn?target=https%3A%2F%2Fweishuai.gitbooks.io%2Felectron-%2Fcontent%2F \"https://weishuai.gitbooks.io/electron-/content/\")\n\n推荐文章\n\n- [分享这半年的 Electron 应用开发和优化经验](https://juejin.cn/post/6844904029231775758 \"https://juejin.cn/post/6844904029231775758\")\n- [用 JS 开发跨平台桌面应用，从原理到实践](https://juejin.cn/post/6844903862302670862 \"https://juejin.cn/post/6844903862302670862\")\n- [Building a desktop application with Electron](https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fdevelopers-writing%2Fbuilding-a-desktop-application-with-electron-204203eeb658 \"https://medium.com/developers-writing/building-a-desktop-application-with-electron-204203eeb658\") 需翻墙访问\n\n推荐开源项目\n\n- [Electron 资源](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsindresorhus%2Fawesome-electron \"https://github.com/sindresorhus/awesome-electron\")\n- [Electron Playground](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftal-tech%2Felectron-playground \"https://github.com/tal-tech/electron-playground\")\n- [electron-vue-cloud-music](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxiaozhu188%2Felectron-vue-cloud-music \"https://github.com/xiaozhu188/electron-vue-cloud-music\")\n- [electron-builder](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Felectron-userland%2Felectron-builder \"https://github.com/electron-userland/electron-builder\")\n\n## 组件库\n\n组件库顾名思义指的就是将多个公共模块或者可复用的组件提取整合生成的一个仓库\n\n知名度较广的组件库：\n\n- [antd](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fant-design%2Fant-design.git \"https://github.com/ant-design/ant-design.git\")\n- [elementUI](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FElemeFE%2Felement.git \"https://github.com/ElemeFE/element.git\")\n\n相关文档：\n\n- [lerna](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flerna%2Flerna \"https://github.com/lerna/lerna\")\n- [angular commit 规范](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fangular%2Fangular%2Fblob%2Fmaster%2FCONTRIBUTING.md%23commit \"https://github.com/angular/angular/blob/master/CONTRIBUTING.md#commit\")\n- [yarn](https://link.juejin.cn?target=https%3A%2F%2Fyarnpkg.com%2F \"https://yarnpkg.com/\")\n- [css variables](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FCSS%2FUsing_CSS_custom_properties \"https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties\")\n\n推荐文章：\n\n- [从 0 到 1，搭建一个体系完善的前端 React 组件库](https://link.juejin.cn?target=https%3A%2F%2Fwww.infoq.cn%2Farticle%2Fi4q9ybdmxzmu8eex8qvh \"https://www.infoq.cn/article/i4q9ybdmxzmu8eex8qvh\")\n- [如何规范你的 Git commit？](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F182553920 \"https://zhuanlan.zhihu.com/p/182553920\")\n- [基于 lerna 和 yarn workspace 的 monorepo 工作流](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F71385053 \"https://zhuanlan.zhihu.com/p/71385053\")\n- [FusionNext 可配置能力从 Sass 体系升级为支持 Css Variable](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F257159028 \"https://zhuanlan.zhihu.com/p/257159028\")\n\n## 微前端\n\n是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将单页面前端应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。\n\n优势：\n\n- 代码库更小，更内聚、可维护性更高\n- 松耦合、自治的团队可扩展性更好\n- 渐进地升级、更新甚至重写部分前端功能成为了可能\n- 独立开发部署，缩小变更范围，进而降低相关风险\n\n框架：\n\n- [single-spa](https://link.juejin.cn?target=https%3A%2F%2Fsingle-spa.js.org%2F \"https://single-spa.js.org/\")\n- [蚂蚁-乾坤](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fumijs%2Fqiankun \"https://github.com/umijs/qiankun\")\n- [淘系-icestark](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fice-lab%2Ficestark \"https://github.com/ice-lab/icestark\")\n- [字节-Garfish](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmodern-js-dev%2Fgarfish \"https://github.com/modern-js-dev/garfish\")\n- [京东-micro-app](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmicro-zoe%2Fmicro-app \"https://github.com/micro-zoe/micro-app\")\n- [Bit](https://link.juejin.cn?target=https%3A%2F%2Fbit.dev \"https://bit.dev\")\n- [EMP - Micro Frontends solution](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FefoxTeam%2Femp \"https://github.com/efoxTeam/emp\") 基于 webpack 5 & module federation\n\n推荐文章：\n\n- [从零到一实现企业级微前端框架，保姆级教学](https://juejin.cn/post/7004661323124441102 \"https://juejin.cn/post/7004661323124441102\")\n- [字节跳动是如何落地微前端的](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FL9wbfNG5fTXF5bx7dcgj4Q \"https://mp.weixin.qq.com/s/L9wbfNG5fTXF5bx7dcgj4Q\")\n- [What Are Micro Frontends?](https://link.juejin.cn?target=https%3A%2F%2Flivebook.manning.com%2Fbook%2Fmicro-frontends-in-action%2Fchapter-1%2Fv-4%2F \"https://livebook.manning.com/book/micro-frontends-in-action/chapter-1/v-4/\")\n- [Bifrost 微前端框架及其在美团闪购中的实践](https://link.juejin.cn?target=https%3A%2F%2Ftech.meituan.com%2F2019%2F12%2F26%2Fmeituan-bifrost.html \"https://tech.meituan.com/2019/12/26/meituan-bifrost.html\")\n- [每日优鲜供应链前端团队微前端改造](https://juejin.cn/post/6844903943873675271 \"https://juejin.cn/post/6844903943873675271\")\n- [微前端在美团外卖的实践](https://link.juejin.cn?target=https%3A%2F%2Ftech.meituan.com%2F2020%2F02%2F27%2Fmeituan-waimai-micro-frontends-practice.html \"https://tech.meituan.com/2020/02/27/meituan-waimai-micro-frontends-practice.html\")\n- [How We Build Micro Frontends](https://link.juejin.cn?target=https%3A%2F%2Fblog.bitsrc.io%2Fhow-we-build-micro-front-ends-d3eeeac0acfc \"https://blog.bitsrc.io/how-we-build-micro-front-ends-d3eeeac0acfc\")\n- [Revolutionizing Micro Frontends with Webpack 5, Module Federation and Bit](https://link.juejin.cn?target=https%3A%2F%2Fblog.bitsrc.io%2Frevolutionizing-micro-frontends-with-webpack-5-module-federation-and-bit-99ff81ceb0 \"https://blog.bitsrc.io/revolutionizing-micro-frontends-with-webpack-5-module-federation-and-bit-99ff81ceb0\")\n\n### 推荐学习资料\n\n- [microfrontend-resources](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbillyjov%2Fmicrofrontend-resources \"https://github.com/billyjov/microfrontend-resources\") ，? 关于微前端的各类资料推荐\n\n## 跨端框架\n\n跨端的最主要的含义就是一套代码多端运行，减少重复劳动\n\n目前看来，国内比较流行的是小程序, H5, App 三端跨的框架， [uniapp](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdcloudio%2Funi-app \"https://github.com/dcloudio/uni-app\") 及 [taro](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FNervJS%2Ftaro \"https://github.com/NervJS/taro\") 是其中做的比较出彩的两个框架。当然在 taro3.0 之前（以下主要是说小程序），taro 跟 uniapp 都是使用编译时做更多的事情，编译成小程序能够运行的代码。\n\n而在 taro3.0 之后变成了与 [remax](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fremaxjs%2Fremax \"https://github.com/remaxjs/remax\") 相同的思想，在运行时做更多的事情，保证了原框架代码能够完全使用，而不需要为了转换成其他小程序时做兼容。\n\n- [awesome-remax](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fremaxjs%2Fawesome-remax \"https://github.com/remaxjs/awesome-remax\")\n- [美团自研 react 跨端](https://link.juejin.cn?target=https%3A%2F%2Ftech.meituan.com%2F2021%2F06%2F10%2Freact-native-hybrid-practice-dsl-in-meituan.html \"https://tech.meituan.com/2021/06/10/react-native-hybrid-practice-dsl-in-meituan.html\")\n- [京东 taro](https://juejin.cn/post/6844904036743774216 \"https://juejin.cn/post/6844904036743774216\")\n\n## 监控\n\n当业务进入稳定，最需要做的肯定是对于业务线上的各种性能、异常及常规业务进行监控，避免在上线之后成为瞎子。\n\n目前市场比较出名的监控系统：\n\n- [sentry](https://link.juejin.cn?target=https%3A%2F%2Fsentry.io%2Fwelcome%2F \"https://sentry.io/welcome/\")\n- [ali node](https://link.juejin.cn?target=https%3A%2F%2Fwww.aliyun.com%2Fproduct%2Fnodejs \"https://www.aliyun.com/product/nodejs\")\n- [bugly](https://link.juejin.cn?target=https%3A%2F%2Fbugly.qq.com%2Fv2%2F \"https://bugly.qq.com/v2/\")\n- [mixpanel](https://link.juejin.cn?target=https%3A%2F%2Fmixpanel.com%2F \"https://mixpanel.com/\")\n- [听云](https://link.juejin.cn?target=https%3A%2F%2Fwww.tingyun.com%2F \"https://www.tingyun.com/\")\n\n推荐开源库：\n\n- [rrweb](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Frrweb-io%2Frrweb \"https://github.com/rrweb-io/rrweb\")，提供像素级的录制与回放，帮助正确定位问题是如何发生的\n- [monitor](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FclouDr-f2e%2Fmonitor \"https://github.com/clouDr-f2e/monitor\")，? 一款轻量级的收集页面的用户点击行为、路由跳转、接口报错、代码报错、并上报服务端的 SDK\n- [mitojs](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmitojs%2Fmitojs \"https://github.com/mitojs/mitojs\") 上面 `monitor` 作者新维护的库。全新插拔式的监控 SDK，代码架构更清晰，配置项更丰富，高度可定制化\n\n推荐文章：\n\n- [美团可视化埋点方案](https://link.juejin.cn?target=https%3A%2F%2Ftech.meituan.com%2F2019%2F08%2F15%2Fmtflexbox-automation-buried-point-exploration.html \"https://tech.meituan.com/2019/08/15/mtflexbox-automation-buried-point-exploration.html\")\n- [如何进行 web 性能监控？](https://link.juejin.cn?target=http%3A%2F%2Fwww.alloyteam.com%2F2020%2F01%2F14184%2F%23prettyPhoto \"http://www.alloyteam.com/2020/01/14184/#prettyPhoto\")\n- [蚂蚁金服如何把前端性能监控做到极致?](https://link.juejin.cn?target=https%3A%2F%2Fwww.infoq.cn%2Farticle%2Fdxa8am44oz*lukk5ufhy \"https://www.infoq.cn/article/dxa8am44oz*lukk5ufhy\")\n- [如何做前端异常监控？](https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F29953354 \"https://www.zhihu.com/question/29953354\")\n- [前端监控平台系列：JS SDK（已开源）](https://juejin.cn/post/6862559324632252430#heading-17 \"https://juejin.cn/post/6862559324632252430#heading-17\")\n\n## 日常充电\n\n- [Best-websites-a-programmer-should-visit](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsdmg15%2FBest-websites-a-programmer-should-visit \"https://github.com/sdmg15/Best-websites-a-programmer-should-visit\")，优秀的工程师都应该阅读的网站\n\n### CSS 日常充电\n\n- [You-need-to-know-css](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fl-hammer%2FYou-need-to-know-css \"https://github.com/l-hammer/You-need-to-know-css\")\n- [CSS Inspiration](https://link.juejin.cn?target=https%3A%2F%2Fcsscoco.com%2Finspiration%2F%23%2F \"https://csscoco.com/inspiration/#/\")\n- [CSS Tricks](https://link.juejin.cn?target=https%3A%2F%2Fqishaoxuan.github.io%2Fcss_tricks%2F \"https://qishaoxuan.github.io/css_tricks/\")\n- [spinkit](https://link.juejin.cn?target=https%3A%2F%2Ftobiasahlin.com%2Fspinkit%2F \"https://tobiasahlin.com/spinkit/\") 需自备梯子\n- [animista](https://link.juejin.cn?target=https%3A%2F%2Fanimista.net%2F \"https://animista.net/\")\n\n## Github 优秀学习资料\n\n### JS 优秀学习资料\n\n- [33-js-concepts](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fleonardomso%2F33-js-concepts \"https://github.com/leonardomso/33-js-concepts\")\n- [JavaScript 安全指南](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FTencent%2Fsecguide%2Fblob%2Fmain%2FJavaScript%25E5%25AE%2589%25E5%2585%25A8%25E6%258C%2587%25E5%258D%2597.md%231.1 \"https://github.com/Tencent/secguide/blob/main/JavaScript%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97.md#1.1\")\n- [What the f\\*ck JavaScript?](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdenysdovhan%2Fwtfjs \"https://github.com/denysdovhan/wtfjs\")，有趣的 JavaScript 示例列表，附有解释\n- [clean-code-javascript](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fryanmcdermott%2Fclean-code-javascript \"https://github.com/ryanmcdermott/clean-code-javascript\")，适应于 JavaScript 的优雅代码建议\n\n### React 优秀学习资料\n\n- [react-philosophies](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmithi%2Freact-philosophies \"https://github.com/mithi/react-philosophies\")，React 哲学，内容为写 React 代码时思考的事情\n\n### 代码样式及安全\n\n- [secguide](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FTencent%2Fsecguide \"https://github.com/Tencent/secguide\")，面向开发人员梳理的代码安全指南\n\n## 生产力工具\n\n### 流程图\n\n- [whimsical](https://link.juejin.cn?target=https%3A%2F%2Fwhimsical.com%2F \"https://whimsical.com/\")\n\n## 最后\n\n内容其实目前只能算作是第一版，并不完善，欢迎大家参与投稿内容。','2021-10-11 03:30:00',0000000002,'前端',0),(0000000003,'浅谈前端常用设计模式之一：策略模式','2022年，前端技术依旧日新月异，各种新兴技术或业务解决方案层出不穷。但我始终认为，在变与不变之间，唯有经典永恒，设计模式就是经典之一。','前言\n\n2022年，前端技术依旧日新月异，各种新兴技术或业务解决方案层出不穷。但我始终认为，在变与不变之间，唯有经典永恒，设计模式就是经典之一。在笔者从业期间，见过很多不同人写的代码，层次有高有低，将设计模式运用地行云流水的大佬，写出的代码总是令人觉着舒适优雅，有时恨不得顿足品读一番，相传小米创始人雷军写的代码就如同诗一般优雅；相反，不懂设计模式的开发者写出的代码总是一言难尽，甚至没有看下去的欲望，恨不得当场重构。。。\n\n1995 年，GoF四人组开创性地提出 23 种设计模式，设计模式是前辈们对代码开发经验的总结，是解决特定问题的一系列套路，是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。站在巨人的肩膀上，能少走很多弯路，看到更多别样的风景。\n\n本系列文章，笔者将会介绍在前端开发过程中，十分实用的一些设计模式，欢迎各位大佬补充讨论，本篇文章将介绍笔者最青睐的策略模式。\n\n## 策略模式（if-else的救世主)\n\n策略模式（Strategy Pattern）指的是定义一系列的算法，把它们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。\n\n这里所指的算法，类似于一个策略，**策略模式的核心思想**就是在一个计算方法中把容易变化的算法抽出来作为“策略”参数传进去，从而使得新增策略不必修改原有逻辑。\n\n本质上来看就是我们老生常谈的解耦。如果一个复杂的系统，如果所有策略都耦合在业务逻辑里，日复一日随着需求的改变和增加，代码越来越庞杂，可维护性越来越低，但如果将策略与业务解耦，我们就可以独立维护这些策略，为业务带来更灵活的变化。\n\n### 实际操作\n\n举一个比较常见的例子，我们会遇到枚举值转换的问题，比如下面我们需要维护一个优惠券的类型，简单粗暴的想我们会直接用if-else直接梭哈。\n\n```\nconst getCouponText = (type) => {\n    if (type === 1) {\n        return \'免费券\'\n    } else if (type === 2) {\n        return \'立减券\'\n    } else if (type === 3) {\n        return \'折扣券\'\n    }\n    ...\n}\n复制代码\n```\n\n但如果我们想要我们的代码可维护性更高的话，首先我们需要对这个枚举值做一个统一的维护管理（枚举值统一管理是笔者推荐的，可以使得代码更语义化，不属于策略模式的内容），提升代码的可读性，然后使用**对象映射**来将逻辑分离出来，解放了if-else，特别是逻辑非常重的时候，用这个方法逻辑更为清晰明了。\n\n```\nconst COUPON_TYPE = {\n    FREE: 1, // 免费\n    DISCOUNT: 2, // 折扣\n    REDUCE: 3, // 立减\n};\nconst COUPON_TYPES = {\n    [COUPON_TYPE.FREE]: \'免费券\',\n    [COUPON_TYPE.DISCOUNT]: \'折扣券\',\n    [COUPON_TYPE.REDUCE]: \'立减券\'\n}\nconst getCouponText = (type) => {\n    return COUPON_TYPES[type]||\'\'\n}\n复制代码\n```\n\n在具体的业务中，我们也会使用到这些枚举值，来对不同的枚举进行不同的操作判断，这时候我们往往又会写一些if-else判断逻辑，随着业务类型的增加，我们只能不停地往里面堆代码\n\n```\nconst handleType = (type) => {\n    if (type === 1) {\n        do sth\n        do sth\n    } else if (type === 2) {\n        do sth\n        do sth\n    } else if (type === 3) {\n        do sth\n        do sth\n    }\n    ...\n}\n复制代码\n```\n\n同样地，我们使用策略模式也可以将这段代码变得更为优雅，使用一个对象专门用来维护这些对应的方法事件，每个类型对应一个方法，遵循了单一原则。\n\n```\nconst couponFunctions = {\n    [COUPON_TYPE.FREE]: () => { do sth},\n    [COUPON_TYPE.DISCOUNT]: () => { do sth },\n    [COUPON_TYPE.REDUCE]: () => { do sth }\n}\nconst handleType = (type) => {\n    couponFunctions[type] && couponFunctions[type]()\n}\n复制代码\n```\n\n笔者认为策略模式是非常好用的，特别是对于一些比较\"重\"的逻辑，各种if-else乱象，使用策略模式能够让代码更通俗易懂，每次改动代码的时候，只需要修改对应的内容就行，不至于在庞杂的逻辑下慌乱了阵脚。\n\n## 感谢观看\n\n本篇文章只介绍了策略模式，但其实另外很多设计模式也比较实用，比如观察者模式、原型模式、代理模式、装饰器模式、单例模式等，都能给我们书写代码带来新的思路和方案，有兴趣的话大家可以继续了解下，我抽时间也会把相关内容补上来和大家一起学习探讨。\n\n最后，感谢观看。我是阿李贝斯，如果你觉得本篇文章对你有帮助的话，欢迎收藏点赞，我会更有动力进行知识输出，希望和掘金的各位大佬一起共同进步，用知识对抗未知！','2022-07-27 09:05:00',0000000001,'前端',0),(0000000004,'如何写出不可维护的Vue代码','不止一次接手过复杂业务功能模块，开端总是深陷其中难以自拔，无数个深夜抚摸着头皮在内心暗暗咒骂。','### 前言\n\n不止一次接手过复杂业务功能模块，开端总是深陷其中难以自拔，无数个深夜抚摸着头皮在内心暗暗咒骂。\n\n相信你也有过类似的经历，面对复杂的业务逻辑，**看代码俩小时，写代码五分钟，没有点胆识和谋略都不敢下手**。\n\n最近总结复盘了一下，以备后用，如果有喜欢的同事想坑他一把，可以按照此方法实践(不保证100%成功)，个人拙见，如有不当望指正。\n\n### 目录\n\n1.  data属性数量过多\n2.  组件入参数量过多\n3.  mixins和业务代码耦合\n4.  不要封装纯函数\n5.  数据结构尽量复杂\n6.  不写注释或写无法理解的注释\n7.  将前端逻辑变重\n8.  不封装mixins与组件\n\n## 正文\n\n### 1、data属性数量过多\n\n要多用data属性，放置一些用不到的key，让属性看起来更丰富，增加理解成本。\n\n最好一打开页面前100行都是data属性，让维护或者参与该组件开发的人员望而生畏，瞬间对组件肃然起敬。\n\n这符合代码的坏味道所描述的：\n\n> 良药与毒药的区别在于剂量。有少量的全局数据或许无妨，**但数量越多，处理的难度就会指数上升。**\n\n如图所示，效果更佳：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c77c98cac0da4e23977cc74d68fc0876~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 2、组件入参数量过多\n\ndata属性的问题是在一个组件内，看多了加上注释可能就理解，而组件增加过多的props入参恰好能避免这个问题，**过多的入参可以让理解变得更困难，要先理解父组件内绑定的值是什么，再理解子组件内的入参用做什么**。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41dfb06081b94ae9a66a6d1476a420cc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n当然了，还有高阶一点的用法，就是让父组件的值和子组件的props名称不一致，这样做就更有趣了，难度陡增。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41c5f208a96149c1822396c194b3ef0d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 3、mixins与业务代码耦合\n\n**合理封装mixins能让代码变得更容易复用和理解，这不是我们想要的**，让mixins与业务组件的代码耦合在一起，可以达到事倍功半的效果。\n\n常规的做法是业务组件调用mixins的方法和变量，我们反其道而行之，让mixins调用组件中的方法和变量，然后让mixins多出引用，**虽然看起来像mixins，但是并没有mixins的功能**，让后期有心想抽离封装的人也无从下手。\n\n小Tips：常见的mixins方法会加上特殊前缀与组件方法区分，我们可以不使用这个规范，让mixins方法更难被发现。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28f46dadf52242ce95eac22c1742d6e2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 4、不要封装纯函数\n\n如果有一个很重要的业务组件可读性很差，势必要小步快跑的迭代重构，这种情况也不用怕，我们**一个微小的习惯就可以让这件事情变得困难重重，那就是不要封装纯函数方法**。\n\n**纯函数的好处是不引用其他变量，可以轻易的挪动和替换；** 让每个方法尽量引用data属性，当他人想迁移或替换你的方法时，就要先理解引用的属性和全局变量，再进一步，可以在方法里再引入mixnins里的变量和方法，这个小习惯就会让他们望而却步。\n\n### 5、数据结构尽量复杂\n\n让数据结构变复杂绝对是一个必杀技，**数据结构随随便便循环嵌套几层**，自己都能绕晕。\n\n再加上一些骚操作，递归遍历加一些判断和删减，**写上让人难以琢磨的注释**，哪怕是高级工程师或是资深工程师都需要狠狠的磕上一段时间才能摸清真正的业务逻辑是什么。\n\n这种方式还有另外一个优点，就是自己可能也会被绕晕，一起陷入有趣的逻辑梳理游戏。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc98d20ade67401db90a54b92cad0eb5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 6、不写注释或写无法理解的注释\n\n如果其他方式都复杂且耗时，那这种方法简直是高效的存在，**只需要胡乱的写一些让别人看不懂或容易误解的注释**，就可轻松把接手代码的同事KO掉。\n\n这个技能也看个人发挥的水平了，你也可以在注释中恐吓、劝阻参与开发人员改动功能代码，煽动开发人员放弃修改，让其内心崩溃。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7398c6390f3c4740b7a3e36de9db7102~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 7、让前端逻辑变重\n\n良好的分层设计能够让系统变得简洁和健壮；为了凸显前端的重要性，**应该将逻辑一股脑的承接到前端，让前端逻辑变重**，尤其是写一些特殊的编码配置和奇葩规则。\n\n不要和产品、后端讲述这件事情的不合理性，统统塞到前端，当需求被重新讨论时，他们会把特殊逻辑忘的一干二净，而你可以根据代码翻出一大堆，这样你就显得尤为重要了。\n\n### 8、不封装mixins与组件\n\n如果要让功能变得复杂，就不要拆分UI组件和业务组件，更不要按照业务抽离可复用的mixins方法，让组件尽量大，轻则一两千行，重则五六千行，不设上限，统统塞到一个组件里。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9084c89503264daeb00c93ef61757149~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 结尾\n\n结合自己的踩坑经历写了这边偏笔记，调侃之处，纯属娱乐。 你有没有遇上过类似的场景，你的感受如何？又是如何解决的呢？敢不敢点个赞，一起评论区讨论。','2022-07-13 03:25:00',0000000003,'前端',0),(0000000005,'使用CSS实现“文段尾行渐变消失”','文章来源于最近解决的一个需求，让一段文案的尾行渐变消失，解决的时候了解到了很多新的知识点，所以记录下来。','导语 文章来源于最近解决的一个需求，让一段文案的尾行渐变消失，解决的时候了解到了很多新的知识点，所以记录下来。\n\n## **问题描述**\n\n最近在做H5的页面的时候，遇到了这样的一个需求：\n\n在一个展示信息的页面，为了提升用户体验，希望在展示一个文段信息的时，只展示指定行数，将超出行数隐藏，并且如果有超出的行数，则展示文段的尾行渐变消失，并加上一个扩展按钮，提醒用户有未展示完整的信息。\n\n说起来比较绕，大概就是这样一个效果\n\n![图片.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8018b81ee8ac453aad3590119a6b66dd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n## 使用遮罩\n\n第一眼看起来还是比较好处理，因为文段消失的感觉，就有点像一个遮罩蒙层，所以我第一反应也是，使用一个遮罩层来处理。\n\n具体处理方式就是，在右下角放一个div，设置和背景相同的颜色，并且设置成左往右的渐变消失，盖住文字就可以，于是就有了这样的效果。\n\n![图片.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c7fecd233ad4192a0b4aa9117d4d953~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n这里的expand下面盖住的是一块渐变的盒子\n\n```\n.mask {\n		width:500px;\n		height: 36px;\n		position: absolute;\n		background: linear-gradient(90deg, transparent 10%, rgba(84, 105, 136) 70%);\n		right: 0;\n		bottom: 107px;\n		font-size: 22px;\n		font-weight: 700;\n		z-index: 332;\n}\n复制代码\n```\n\n 看起来好像比较完美的实现了，但是有个问题，渐变盒子之所以能完美覆盖最后一行文段，是因为它的颜色和背景完全相同，如果背景是渐变的，或者是一张图片，就会有问题，比如像这样。\n\n![图片.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab558e9d912b40b580b9051ff03eb574~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n这里我其实还想过，既然背景不能融合会导致渐变盒子浮出文段，那么我可以直接在文段对应位置切出一块能融合的背景，或者说设置对应的渐变色，这样就能够解决浮层。\n\n但是产品告诉我，父级渐变背景是有滚动条的，所以文段的背景色还会改变，所以不能写死这块的颜色，还是需要对应的获取。\n\n## 行内元素的渐变背景\n\n 我们在给行内元素设置背景时，它不会像块级元素一样，直接获取到背景，行内元素获取背景，是默认先让整个DOM不换行，获取到背景色之后，再默认换行，所以如果对其设置渐变背景的话，就会有这种效果。\n\n![图片.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e9351286de448f987fb856fdc16532c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n利用这个效果，我们可以在文段的上方覆盖一层文字内容和大小相同的行内元素，将其文字颜色设置为透明，然后设置一个渐变的背景色，通过调整背景色的区域来实现文段的尾行渐变，效果如下。\n\n![图片.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c4bbe7c4ee9441ba99a62dc2710f55a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n核心代码如下\n\n```\n span {\n			background: linear-gradient(90deg, transparent 80%, orange);\n			background-size: 100% 100%;\n			background-repeat: no-repeat;\n			background-position: 100% 100%;\n			cursor: pointer;\n\n			color: transparent;\n			font-size: 24px;\n			z-index: 4;\n\n		}\n		span::before {\n			content: \"Mollitia nostrum placeat consequatur deserunt velit ducimus possimus commodi      temporibus debitis quam commodi temporibus debitis quam debitis\";\n			position: absolute;\n			top: 0;\n			left: 0;\n			color: #000;\n			z-index: -1;\n		}\n复制代码\n```\n\n  其实可以看到，这里的效果就会比前面的遮罩的方法要好一点，但是即使这里的颜色控制的与背景很接近，也依然会有一点浮层的感觉。\n\n除此之外，我们用来遮罩的盒子，为了和底层文段大小一致，需要填入相同的内容，这其实看起来非常的冗余，最致命的是，这个方法直对横向的渐变起作用，所以我们需要寻求更合适的方法。\n\n## 遮罩mask\n\n Css的mask属性是个啥呢，MDN给出的介绍是：Css 属性 **`mask`** 允许使用者通过遮罩或者裁切特定区域的图片的方式来隐藏一个元素的部分或者全部可见区域。简言之，我们可以通过在元素上设置这个属性，来隐藏该元素的一部分。\n\n如果我们直接用在文段上，就可以得到这样的效果。\n\n![图片.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5c242b0ab89442897a7e761fffddecf~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n有了这个属性，顿时感觉问题解决了一大半，在使用的时候，我们就不再需要再去添加一个用于蒙层的盒子，而是只需要在文段上使用mask加上一层遮罩。\n\n但是mask在单独使用的时候，会默认设置100%的宽高，所以这里需要多定义一个来将另一个遮罩来占据剩下的位置，所以这里一共定义了两个遮罩，一个在上方，一个在末行。\n\n最终的效果:\n\n![图片.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15f972240d7243e1972b95a18edf95f2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n最终的代码：\n\n```\np {\n	margin: auto;\n	width: 450px;\n	line-height: 36px;\n	font-size: 20px;\n	-webkit-mask:linear-gradient(270deg, transparent, transparent 30%, #000),\n	linear-gradient(270deg, #000, #000);\n	-webkit-mask-size: 100% 66px, 100% calc(100% - 46px);\n	-webkit-mask-position: bottom, top;\n	-webkit-mask-repeat: no-repeat;\n}\n复制代码\n```\n\n 由于支持性不够完善，所以这里在编写的时候还需要加上前缀，这里一共定义了两个遮罩，一个在上方，一个在末行，原因是mask在单独使用的时候，会默认设置100%的宽高，所以这里需要多定义一个来将另一个遮罩推到我们需要的位置。\n\n当然，有关于Mask，还有很多非常不错的用法\n\n*   比如丝滑的融合两张图片\n\n![图片.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be2ff9e57a2d457192c47428733cb335~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n*   制作渐变过渡\n\n![608782-20200706102148459-453233707.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/626ff86535e04bfb8e07af4aa2f17280~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n有有兴趣的可以去看看这篇文档：[www.cnblogs.com/coco1s/p/13…](https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fcoco1s%2Fp%2F13253423.html \"https://www.cnblogs.com/coco1s/p/13253423.html\")\n\n## 最后\n\n虽然有几种方法没能解决问题，不过倒是带给我一些场景的实现灵感，也然我学习到了一些新的css知识，本文到这里就结束了，希望我解决问题的过程对你能有所帮助，关于文本末行渐变消失的问题，如果你有比较好的方法，欢迎在评论区留言讨论\n\n参考链接：\n\n[github.com/chokcoco/iC…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fchokcoco%2FiCSS \"https://github.com/chokcoco/iCSS\")','2022-07-26 09:33:00',0000000004,'前端',0),(0000000006,'适合初学者的 10 个JavaScript 代码整洁技巧','什么是整洁的代码呢？答案可能因人而异，个人提倡以函数式风格编写代码，如果做得正确的话，代码将更容易阅读、分解和测试。在开始函数式编程之前，学习一些小的技巧有助于编写整洁的代码。','> 什么是整洁的代码呢？答案可能因人而异，个人提倡以函数式风格编写代码，如果做得正确的话，代码将更容易阅读、分解和测试。在开始函数式编程之前，学习一些小的技巧有助于编写整洁的代码。最好的方式是阅读开源项目，学习别人的方式。对于JavaScript，ES6 引入了许多新的特性，也使得写代码多一种更加优雅的方式。\n\n阅读代码，可以站在巨人的肩膀上快速成长的有效方法，GitHub 是程序员学习的首选资源站。\n\n### 1\\. 数组合并\n\n```\n// 常规逻辑\nconst apples = [\"?\", \"?\"];\nconst fruits = [\"?\", \"?\", \"?\"].concat(apples);\n\nconsole.log(fruits); // [\"?\", \"?\", \"?\", \"?\", \"?\"];\n\n// 优雅写法 1\nconst apples = [\"?\", \"?\"];\nconst fruits = [\"?\", \"?\", \"?\", ...apples];\n\nconsole.log(fruits); //  [\"?\", \"?\", \"?\", \"?\", \"?\"];\n\n// 优雅写法 2\nconst apples = [\"?\", \"?\"];\nconst fruits = [...apples, \"?\", \"?\", \"?\"];\nconsole.log(fruits); // [\"?\", \"?\", \"?\", \"?\", \"?\"];\n\n// 优雅去重\nconst apples = [\"?\", \"?\", \"?\"];\nconst fruits = [...new Set([\"?\", \"?\", \"?\", \"?\", ...apples])];\nconsole.log(fruits); // [ \'?\', \'?\', \'?\', \'?\', \'?\' ]\n复制代码\n```\n\n### 2\\. 数组中取值\n\n```\n// 常规逻辑\nconst apples = [\"?\", \"?\"];\nconst redApple = apples[0];\nconst greenApple = apples[1];\n\nconsole.log(redApple); // ?\nconsole.log(greenApple); // ?;\n\n// 优雅写法\nconst apples = [\"?\", \"?\"];\nconst [redApple, greenApple] = apples; // 使用解构赋值\n\nconsole.log(redApple); // ?\nconsole.log(greenApple); // ?;\n复制代码\n```\n\n### 3\\. 对象取值\n\n```\n// 常规逻辑\nconst user = {\n    name: \"DevPoint\",\n    age: 30,\n};\n\nconst name = user.name; // DevPoint\nconst age = user.age; // 30\nconsole.log(name);\nconsole.log(age);\n\n// 优雅写法\nconst user = {\n    name: \"DevPoint\",\n    age: 30,\n};\n\nconst { name, age } = user;\n\nconsole.log(name); // DevPoint\nconsole.log(age); // 30\n复制代码\n```\n\n### 4\\. 数组循环\n\n数组循环的方法有 `.forEach()` 与 `for...of`，在使用上各有特色，但在效率上，`for...of` 比 `.forEach()` 快。因此推荐使用 `for...of`。\n\n```\n// 常规逻辑\nconst fruits = [\"?\", \"?\", \"?\", \"?\"];\n\nfor (let i = 0; i < fruits.length; i++) {\n    console.log(fruits[i]);\n}\n\n// 优雅写法\nconst fruits = [\"?\", \"?\", \"?\", \"?\"];\n\nfor (fruit of fruits) {\n    console.log(fruit);\n}\n复制代码\n```\n\n### 5\\. 箭头函数作为回调\n\n箭头函数是 ES6 中引入新的语法，除了让代码变得优雅的同时，可以避免 `this` 带来的问题。\n\n```\n// 常规逻辑\nconst fruits = [\"?\", \"?\", \"?\", \"?\"];\n\nfruits.forEach(function (fruit) {\n    console.log(fruit);\n});\n\n// 优雅写法\nconst fruits = [\"?\", \"?\", \"?\", \"?\"];\nfruits.forEach((fruit) => console.log(fruit));\n复制代码\n```\n\n### 6\\. 数组搜索\n\n数组操作，在前端开发中是比较常见的功能，为了提高开发效率降低重复代码，可以考虑写一个通用的数组操作的脚本库。\n\n假设需要通过一个对象的属性从一个对象数组中查找一个对象，通常使用 for 循环：\n\n```\n// 常规逻辑\nconst inventory = [\n    { name: \"Bananas\", quantity: 5 },\n    { name: \"Apples\", quantity: 10 },\n    { name: \"Grapes\", quantity: 2 },\n];\n\n// Get the object with the name `Apples` inside the array\nfunction getApples(arr, value) {\n    for (let index = 0; index < arr.length; index++) {\n        if (arr[index].name === \"Apples\") {\n            return arr[index];\n        }\n    }\n}\n\nconst result = getApples(inventory);\nconsole.log(result); // { name: \'Apples\', quantity: 10 }\n\n// 优雅写法\nconst inventory = [\n    { name: \"Bananas\", quantity: 5 },\n    { name: \"Apples\", quantity: 10 },\n    { name: \"Grapes\", quantity: 2 },\n];\n\nfunction getApples(arr, value) {\n    return arr.find((obj) => obj.name === \"Apples\");\n}\n\nconst result = getApples(inventory);\nconsole.log(result);\n复制代码\n```\n\n### 7.字符串转换为数字\n\n```\n// 常规逻辑\nconst num = parseInt(\"10\");\n\nconsole.log(num); // 10\nconsole.log(typeof num); // \"number\";\n\n// 优雅写法\nconst num = +\"10\";\nconsole.log(num); //=> 10\nconsole.log(typeof num); // \"number\"\nconsole.log(+\"10\" === 10); // true;\n复制代码\n```\n\n同样的方法可以用于判断是否为整数：\n\n```\nconst isInteger = (val) => Number.isInteger(+val);\nconsole.log(isInteger(\"DevPoint\")); // false\nconsole.log(isInteger(\"30\")); // true\nconsole.log(isInteger(30)); // true\n复制代码\n```\n\n### 8\\. null 值初始化\n\n```\n// 常规逻辑\nfunction getUserRole(role) {\n    let userRole;\n    if (role) {\n        userRole = role;\n    } else {\n        userRole = \"USER\";\n    }\n    return userRole;\n}\n\nconsole.log(getUserRole()); // \"USER\"\nconsole.log(getUserRole(\"ADMIN\")); // \"ADMIN\";\n\n// 优雅写法\nfunction getUserRole(role) {\n    return role || \"USER\"; // 默认值定义的常见方法\n}\n\nconsole.log(getUserRole()); // \"USER\"\nconsole.log(getUserRole(\"ADMIN\")); // \"ADMIN\";\n复制代码\n```\n\n### 9\\. 字符串拼接\n\n过去无尽的 `+` 号，再加上一些排版就更痛苦。\n\n```\n// 常规逻辑\nconst name = \"DevPoint\";\nconst message = \"Hi \" + name + \"!\";\nconsole.log(message); // Hi DevPoint!\n// 优雅写法\nconst name = \"DevPoint\";\nconst message = `Hi ${name}!`;\nconsole.log(message); // Hi DevPoint!\n复制代码\n```\n\n### 10 对象合并\n\n对象的合并，在ES6中，可以学习一些扩展运算符和解构赋值，这样有利于写出更加简洁的代码。\n\n```\n// 常规逻辑\nconst employee = { name: \"DevPoint\", age: 30 };\nconst salary = { grade: \"A\" };\nconst summary = salary;\nfor (const key in employee) {\n    summary[key] = employee[key];\n}\nconsole.log(summary); // { grade: \'A\', name: \'DevPoint\', age: 30 }\n// 优雅写法\nconst employee = { name: \"DevPoint\", age: 30 };\nconst salary = { grade: \"A\" };\nconst summary = { ...employee, ...salary };\nconsole.log(summary); // { name: \'DevPoint\', age: 30, grade: \'A\' }\n复制代码\n```','2022-06-20 12:46:00',0000000005,'前端',0),(0000000007,'一定要优雅，高端前端程序员都应该具备的基本素养','近来看到很多公司裁员，忽然惊醒，之前是站在项目角度考虑问题，却没站在咱们程序员本身看待问题，险些酿成大错，如果人人都能做到把项目维护得井井有条，无论什么人都能看明白都能快速接手，那咱们的竞争力在哪里呢？','之前写过几篇关于如何写出可维护项目的文章（[构建大型前端业务项目的一点经验](https://juejin.cn/post/7016948081321050148 \"https://juejin.cn/post/7016948081321050148\")、[编写可维护的现代化前端项目](https://juejin.cn/post/6844903996910485511 \"https://juejin.cn/post/6844903996910485511\")、[接手前端新项目？这里有些注意点你可能需要留意一下](https://juejin.cn/post/6844903678852202510 \"https://juejin.cn/post/6844903678852202510\")），近来看到很多公司裁员，忽然惊醒，之前是站在项目角度考虑问题，却没站在咱们程序员本身看待问题，险些酿成大错，如果人人都能做到把项目维护得井井有条，无论什么人都能看明白都能快速接手，那咱们的竞争力在哪里呢？这个时候我再看项目中那些被我天天骂的代码，顿时心中就无限景仰起来，原来屎山才是真能能够保护我们的东西，哪有什么岁月静好，只是有人替你负屎前行罢了\n\n为了能让更多人认识到这一点，站在前端的角度上，我在仔细拜读了项目中的那些暗藏玄机的代码后，决定写下此文，由于本人功力尚浅，且之前一直走在错误的道路上，所以本文在真正的高手看来可能有些班门弄斧，在此献丑了?\n\n## 用 TypeScript，但不完全用\n\n`TypeScript`大行其道，在每个团队中，总有那么些个宵小之辈想尽一切办法在项目里引入 `ts`，这种行为严重阻碍了屎山的成长速度，但同是打工人我们也不好阻止，不过就算如此，也无法阻止我们行使正义\n\n众所周知，`TypeScript` 别名 `AnyScript`，很显然，这就是`TypeScript`创始人`Anders Hejlsberg`给我们留下的暗示，我们有理由相信`AnyScript` 才是他真正的目的\n\n```\nconst list: any = []\nconst obj: any = {}\nconst a: any = 1\n复制代码\n```\n\n引入了 `ts`的项目，由于是在原可运行代码的基础上额外添加了类型注释，所以代码体积毫无疑问会增大，有调查显示，可能会增加 `30%`的代码量，如果充分发挥 `AnyScript` 的宗旨，意味着你很轻松地就让代码增加了 `30%` 毫无用处但也挑不出啥毛病的代码，这些代码甚至还会增加项目的编译时间（毕竟增加了`ts`校验和移除的成本嘛）\n\n你不仅能让自己写的代码用上 `AnyScript`，甚至还可以给那些支持 `ts` 的第三方框架/库一个大嘴巴子\n\n```\nexport default defineComponent({\n  props: {\n    // 现在 data 是 any 类型的啦\n    data: {\n      type: Number as PropType<any>,\n    },\n  },\n  setup(_, { emit }) {\n    // 现在 props 是 any 类型的啦\n    const props: any = _\n    ...\n  }\n})\n复制代码\n```\n\n当然了，全屏 `any`可能还是有点明显了，所以你可以适当地给部分变量加上具体类型，但是加上类型不意味着必须要正确使用\n\n```\nconst obj: number[] = []\n// ...\n// 虽然 obj 是个 number[]，但为了实现业务，就得塞入一些不是 number 的类型，我也不想的啊是不是\n// 至于编辑器会划红线报错？那是小问题，不用管它，别人一打开这个项目就是满屏的红线，想想就激动\nobj.push(\'2\')\nobj.push([3])\n复制代码\n```\n\n## 命名应该更自由\n\n命名一直是个困扰很多程序员的问题，究其原因，我们总想给变量找个能够很好表达意思的名称，这样一来代码的可阅读性就高了，但现在我们知道，这并不是件好事，所以我们应该放纵自我，既摆脱了命名困难症，又加速了屎山的堆积进度\n\n```\nconst a1 = {}\nconst a2 = {}\nconst a3 = 2\nconst p = 1\n复制代码\n```\n\n我必须强调一点，命名不仅是变量命名，还包含**文件名、类名、组件名**等，这些都是我们可以发挥的地方，例如类名\n\n```\n<div class=\"box\">\n  <div class=\"box1\"></div>\n  <div class=\"box2\"></div>\n<div>\n<div class=\"box3\"></div>\n复制代码\n```\n\n乍一看似乎没啥毛病，要说有毛病似乎也不值当单独挑出来说，没错，要的就是这个效果，让人单看一段代码不好说什么，但是如果积少成多，整个项目都是 `box`呢？全局搜索都给你废了！如果你某些组件再一不小心没用 `scoped` 呢？稍不留意就不知道把什么组件的样式给改了，想想就美得很\n\n关于 `css`我还想多说一点，鉴于其灵活性，我们还可以做得更多，总有人说什么 `BEM` 不 `BEM`的，他们敢用我们就敢写这样的代码\n\n```\n&-card {\n  &-btn {\n    &_link {\n      &--right {\n      }\n    }\n    &-nodata {\n      &_link {\n        &--replay {\n          &--create {}\n        }\n      }\n    }\n  }\n  &-desc {}\n}\n复制代码\n```\n\n好了，现在请在几百行（关于这一点下一节会说到）这种格式的代码里找出类名 `.xxx__item_current.mod-xxx__link` 对应的样式吧\n\n## 代码一定要长\n\n屎山一定是够高够深的，这就要求我们的代码应该是够长够多的\n\n大到一个文件的长度，小到一个类、一个函数，甚至是一个 `if` 的条件体，都是我们自由发挥的好地方。\n\n什么单文件最好不超过 `400`行，什么一个函数不超过 `100`行，简直就是毒瘤，\n\n![1.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/605301677ade4f8da68a8c80d70cfa8f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n所以这就要求我们要具备将十行代码就能解决的事情写成一百行的能力，最好能给人一种多即是少的感觉\n\n```\ndata === 1\n  ? \'img\'\n  : data === 2\n    ? \'video\'\n    : data === 3\n      ? \'text\'\n      : data === 4\n        ? \'picture\'\n        : data === 5\n          ? \'miniApp\'\n复制代码\n```\n\n三元表达式可以优雅地表达逻辑，像诗一样，虽然这段代码看起来比较多，但逻辑就是这么多，我还专门用了三元表达式优化，不能怪我是不是？什么`map`映射枚举优化听都没听过\n\n你也可以选择其他一些比较容易实现的思路，例如，多写一些废话\n\n```\nif (a > 10) {\n  // 虽然下面几个 if 中对于 a 的判断毫无用处，但不仔细看谁能看出来呢？看出来了也不好说什么，毕竟也没啥错\n  // 除此之外，多级 if 嵌套也是堆屎山的一个小技巧，什么提前 return 不是太明白\n  if (a > 5) {\n    if (a > 3 && b) {\n\n    }\n  }\n  if (a > 4) {\n\n  }\n}\n复制代码\n```\n\n除此之外，你还可以写一些中规中矩的方法，但重点在于这些方法根本就没用到，这种发挥的地方就更多了，简直就是扩充代码体积的利器，毕竟单看这些方法没啥毛病，但谁能想到根本就用不到呢？就算有人怀疑了，但你猜他敢随便从运行得好好的业务项目里删掉一些没啥错的代码吗？\n\n## 组件、方法多多滴耦合\n\n为了避免其他人复用我的方法或组件，那么在写方法或组件的时候，一定要尽可能耦合，提升复用的门槛\n\n例如明明可以通过 `Props`传参解决的事情，我偏要从全局状态里取，例如`vuex`，独一份的全局数据，想传参就得改 `store`数据，但你猜你改的时候会不会影响到其他某个页面某个组件的正常使用呢？如果你用了，那你就可能导致意料之外的问题，如果你不用你就得自己重写一个组件\n\n组件不需要传参？没关系，我直接把组件的内部变量给挂到全局状态上去，虽然这些内部变量确实只有某一个组件在用，但我挂到全局状态也没啥错啊是不是\n\n嘿，明明一个组件就能解决的事情，现在有了倆，后面还可能有仨，这代码量不就上来了吗？\n\n方法也是如此，明明可以抽取参数，遵循函数式编程理念，我偏要跟外部变量产生关联\n\n```\n// 首先这个命名就很契合上面说的自由命名法\nfunction fn1() {\n  // ...\n  // fn1 的逻辑比较长，且解决的是通用问题，\n  // 但 myObj 偏偏是一个外部变量，这下看你怎么复用\n  window.myObj.name = \'otherName\'\n  window.myObj.children.push({ id: window.myObj.children.length })\n  // ...\n}\n复制代码\n```\n\n## 魔术字符串是个好东西\n\n实际上，据我观察，排除掉某些居心不轨的人之外，大部分人还是比较喜欢写魔术字符串的，这让我很欣慰，看着满屏的不知道从哪里冒出来也不知道代表着什么的硬编码字符串，让人很有安全感\n\n```\nif (a === \'prepare\') {\n  const data = localStorage.getItem(\'HOME-show_guide\')\n  // ...\n} else if (a === \'head\' && b === \'repeating-error\') {\n  switch(c) {\n    case \'pic\':\n      // ...\n      break\n    case \'inDrawer\':\n      // ...\n      break\n  }\n}\n复制代码\n```\n\n基于此，我们还可以做得更多，比如用变量拼接魔术字符串，`debug`的时候直接废掉全局搜索\n\n```\nif (a === query.name + \'_head\') {\n\n}\n复制代码\n```\n\n大家都是中国人，为什么不试试汉字呢？\n\n```\nif (data === \'正常\') {\n\n} else if (data === \'错误\') {\n\n} else if (data === \'通过\') {\n\n}\n复制代码\n```\n\n## 轮子就得自己造才舒心\n\n众所周知，造轮子可以显著提升我们程序员的技术水平，另外由于轮子我们已经自己造了，所以减少了对社区的依赖，同时又增加了项目体积，有力地推动了屎山的成长进程，可以说是一鱼两吃了\n\n例如我们可能经常在项目中使用到时间格式化的方法，一般人都是直接引入 `dayjs`完事，太肤浅了，我们应该自己实现，例如，将字符串格式日期格式化为时间戳\n\n```\nfunction format(str1: any, str2: any) {\n  const num1 = new Date(str1).getTime()\n  const num2 = new Date(str2).getTime()\n  return (num2 - num1) / 1000\n}\n复制代码\n```\n\n多么精简多么优雅，至于你说的什么格式校验什么 `safari`下日期字符串的特殊处理，等遇到了再说嘛，就算是`dayjs`不也是经过了多次 `fixbug`才走到今天的嘛，多一些宽松和耐心好不好啦\n\n如果你觉得仅仅是 `dayjs`这种小打小闹难以让你充分发挥，你甚至可以造个 `vuex`，`vue`官网上写明了`eventBus`可以充当全局状态管理的，所以我们完全可以自己来嘛，这里就不举例了，这是自由发挥的地方，就不局限大家的思路了\n\n## 借助社区的力量-轮子还是别人的好\n\n考虑到大家都只是混口饭吃而已，凡事都造轮子未免有些强人所难，所以我们可以尝试走向另外一个极端——凡事都用轮子解决\n\n判断某个变量是字符串还是对象，[kind-of](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fkind-of \"https://www.npmjs.com/package/kind-of\")拿来吧你；获取某个对象的 `key`，[object-keys](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fobject-keys \"https://www.npmjs.com/package/object-keys\")拿来吧你；获取屏幕尺寸，[vue-screen-size](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fvue-screen-size \"https://www.npmjs.com/package/vue-screen-size\")拿来吧你……等等，就不一一列举了，需要大家自己去发现\n\n先甭管实际场景是不是真的需要这些库，也甭管是不是杀鸡用牛刀，要是大家听都没听过的轮子那就更好了，这样才能彰显你的见多识广，总之能解决问题的轮子就是好问题，\n\n在此我得特别提点一下 `lodash`，这可是解决很多问题的利器，但是别下载错了，得是 [commonjs版本](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Flodash \"https://www.npmjs.com/package/lodash\")的那个，量大管饱还正宗，[es module](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Flodash-es \"https://www.npmjs.com/package/lodash-es\")版本是不行滴，太小家子气\n\n```\nimport _ from \'lodash\'\n复制代码\n```\n\n## 多尝试不同的方式来解决相同的问题\n\n世界上的路有很多，很多路都能通往同一个目的地，但大多数人庸庸碌碌，只知道沿着前人的脚步，没有自己的思想，别人说啥就是啥，这种行为对于我们程序员这种高端的职业来说，坏处很大，任何一个有远大理想的程序员都应该避免\n\n落到实际上来，就是尝试使用不同的技术和方案解决相同的问题\n\n*   搞个`css`模块化方案，什么`BEM`、`OOCSS`、`CSS Modules`、`CSS-in-JS` 都在项目里引入，紧跟潮流扩展视野\n*   `vue`项目只用 `template`？逊啦你，`render`渲染搞起来\n*   之前看过什么前端依赖注入什么反射的文章，虽然对于绝大多数业务项目而言都是水土不服，但问题不大，能跑起来就行，引入引入\n*   还有那什么 `rxjs`，人家都说好，虽然我也不知道好在哪里，但胜在门槛高一般人搞不清楚所以得试试\n*   `Pinia` 是个好东西，什么，我们项目里已经有 `vuex`了？`out`啦，人家官网说了 `vue2`也可以用，我们一定要试试，紧跟社区潮流嘛，一个项目里有两套状态管理有什么值得大惊小怪的！\n\n## 做好自己，莫管他人闲事\n\n看过一个小故事，有人问一个年纪很大的老爷爷的长寿秘诀是什么，老爷爷说是从来不管闲事\n\n这个故事对我们程序员来说也很有启发，写好你自己的代码，不要去关心别人能不能看得懂，不要去关心别人是不是会掉进你写的坑里\n\n```\nmounted() {\n  setTimeout(() => {\n    const width = this.$refs.box.offsetWidth\n    const itemWidth = 50\n    // ...\n  }, 200)\n}\n复制代码\n```\n\n例如对于上述代码，为什么要在 `mounted`里写个 `setTimeout`呢？为什么这个 `setTimeout`的时间是 `200`呢？可能是因为 `box` 这个元素大概会在 `mounted`之后的 `200ms`左右接口返回数据就有内容了，就可以测量其宽度进行其他一系列的逻辑了，至于有没有可能因为网络等原因超过 `200ms`还是没有内容呢？这些不需要关心，你只要保证在你开发的时候 `200ms`这个时间是没问题的就行了； `itemWidth`代表另外一个元素的宽度，在你写代码的时候，这个元素宽度就是 `50`，所以没必要即时测量，你直接写死了，至于后面其他人会不会改变这个元素的宽度导致你这里不准了，这就不是你要考虑的事情了，你开发的时候确实没问题，其他人搞出来问题其他人负责就行，管你啥事呢？\n\n## 代码自解释\n\n高端的程序员，往往采用最朴素的编码方式，高手从来不写注释，因为他们写的代码都是自解释的，什么叫自解释？就是你看代码就跟看注释一样，所以不需要注释\n\n我觉得很有道理，代码都在那里搁着了，逻辑写得清清楚楚，为啥还要写注释呢，直接看代码不就行了吗？\n\n乍一看，似乎这一条有点阻碍堆屎山的进程，实则不然\n\n一堆注定要被迭代无数版、被无数人修改、传承多年的代码，其必定是逻辑错综复杂，难免存在一些不可名状的让人说不清道不明的逻辑，没有注释的加成，这些逻辑大概率要永远成为黑洞了，所有人看到都得绕着走，相当于是围绕着这些黑洞额外搭起了一套逻辑，这代码体积和复杂度不就上来了吗？\n\n如果你实在手痒，倒也可以写点注释，我这里透露一个既能让你写写注释过过瘾又能为堆屎山加一把力的方法，那就是：在注释里撒谎！\n\n没错，谁说注释只能写对的？我理解不够，所以注释写得不太对有什么奇怪的吗？我又没保证注释一定是对的，也没逼着你看注释，所以你看注释结果被注释误导写了个bug，这凭啥怪我啊\n\n```\n// 计算 data 是否可用\n//（实际上，这个方法的作用是计算 data 是否 不可用）\nfunction isDisabledData(data: any) {\n  // ...\n}\n复制代码\n```\n\n上述这个例子只能说是小试牛刀，毕竟多调试一下很容易被发现的，但就算被发现了，大家也只会觉得你只是个小粗心鬼罢了，怎么好责怪你呢，这也算是给其他人的一个小惊喜了，况且，万一真有人不管不顾就信了，那你就赚大了\n\n## 编译问题坚决不改\n\n为了阻碍屎山的成长速度，有些阴险的家伙总想在各种层面上加以限制，例如加各种`lint`，在编译的时候，命令行中就会告诉你你哪些地方没有按照规则来，但大部分是 `waring` 级别的，即你不改项目也能正常运行，这就是我们的突破点了。\n\n尽管按照你的想法去写代码，`lint`的事情不要去管，`waring`报错就当没看到，又不是不能用？在这种情况下，如果有人不小心弄了个 `error`级别的错误，他面对的就是从好几屏的 `warning` 中找他的那个 `error` 的场景了，这就相当于是提前跟屎山来了一次面对面的拥抱\n\n根据破窗理论，这种行为将会影响到越来越多的人，大家都将心照不宣地视 `warning`于无物（从好几屏的 `warning`中找到自己的那个实在是太麻烦了），所谓的 `lint`就成了笑话\n\n## 小结\n\n一座历久弥香的屎山，必定是需要经过时间的沉淀和无数人的操练才能最终成型，这需要我们所有人的努力，多年之后，当你看到你曾经参与堆砌的屎山中道崩殂轰然倒塌的时候，你就算是真的领悟了我们程序员所掌控的恐怖实力！?','2022-06-09 06:12:00',0000000006,'前端',0),(0000000008,'有了这些前端css工具，我下班都更早了！','你是不是还在手写按钮、文本字体等简单样式？这些工具就可以帮你解决以上种种难题，从此下班你将快人一步，赶快用起来吧！','![有了这些前端css工具，我下班都更早了！](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef55988104ac43e293ba09e7f3b684ea~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n> 你是不是还在手写按钮、文本字体等简单样式？这些工具就可以帮你解决以上种种难题，从此下班你将快人一步，赶快用起来吧！\n\n### 01 CSS Button Generator\n\n**地址：[cssbuttongenerator.com/](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fcssbuttongenerator.com%2F \"https://link.zhihu.com/?target=https%3A//cssbuttongenerator.com/\")**\n\n**推荐：★★★★★**\n\n**简介**：CSS Button Generator是一个免费的在线工具，可让您创建跨浏览器的 HTML 和CSS 按钮样式，您不必学习任何复杂的CSS规则。只需单击并滑动即可制作CSS 3按钮。很多漂亮的按钮样本。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35d3d608571d44c7bedec0dafdd914b7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 02 花式边界半径\n\n**地址：[9elements.github.io/fancy-borde…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2F9elements.github.io%2Ffancy-border-radius%2F \"https://link.zhihu.com/?target=https%3A//9elements.github.io/fancy-border-radius/\")**\n\n**推荐：★★★★★**\n\n**简介**：通过拖拽的形式生成需要的border-radius！\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2076b1cb259497098af199a9b06ee68~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 03 平滑阴影\n\n**地址：[shadows.brumm.af/](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fshadows.brumm.af%2F \"https://link.zhihu.com/?target=https%3A//shadows.brumm.af/\")**\n\n**推荐：★★★★★**\n\n**简介**：可以生成多个分层阴影，提供非常酷的效果，你也可以自定义颜色。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3d80836cdc14d919e54719ae66d6f0f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 04 阴影生成器\n\n**地址：[neumorphism.io/](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fneumorphism.io%2F \"https://link.zhihu.com/?target=https%3A//neumorphism.io/\")**\n\n**推荐：★★★★★**\n\n**简介**：此网站通过 选择颜色：或大小：半径：距离：强度：模糊：形状：复制边框半径：50px;背景，生成非常nice的阴影，让你的界面更加的美观自然。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/771daf260cd1446aa877298b85d81786~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 05 css在线工具\n\n**地址：** [tool.lu/css/](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Ftool.lu%2Fcss%2F \"https://link.zhihu.com/?target=https%3A//tool.lu/css/\")\n\n**推荐：★★★★**\n\n**简介**：美化：格式化代码，使之容易阅读。净化：将代码单行化，并去除注释。整理：按照一定的顺序，重新排列css的属性。优化：将css的长属性值优化为简写的形式。压缩：将代码最小化，加快加载速度！\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8a705ab3e6046b0a3db88b0c79b6b2c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 06 cssgradient\n\n**地址：[cssgradient.io/](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fcssgradient.io%2F \"https://link.zhihu.com/?target=https%3A//cssgradient.io/\")**\n\n**推荐：★★★★**\n\n**简介**：CSS Gradient 是一个快乐的小网站和免费工具，可让您为网站创建渐变背景。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e85e342d7594600a737e3796836abbe~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 07 css网格生成器\n\n**地址：[cssgrid-generator.netlify.app/](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fcssgrid-generator.netlify.app%2F \"https://link.zhihu.com/?target=https%3A//cssgrid-generator.netlify.app/\")**\n\n**推荐：★★★★★**\n\n**简介**：您可以设置行和列的数字还有单位，我将为您生成一个 CSS Grid 网格布局！在方框中拖动来创建 div 放置在网格内。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7a6189cca4142a292b0f63d9c3ef104~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 08 过渡动画\n\n**地址：[www.transition.style/](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fwww.transition.style%2F \"https://link.zhihu.com/?target=https%3A//www.transition.style/\")**\n\n**推荐：★★★★**\n\n**简介**：各种各样的css动画合集！\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b0c858ced164eb597e90f19e5ab5755~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 09 加载动画\n\n**地址：[loading.io/](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Floading.io%2F \"https://link.zhihu.com/?target=https%3A//loading.io/\")**\n\n**推荐：★★★★★**\n\n**简介**：在这里你可以生成多个加载动画并将其下载为SVG、GIF、PNG和其他格式，但它最棒的特点是你可以将这些动画自定义到一个新的水平。值得尝试。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5c30ded40974730ab65458915c12530~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 10 波浪生成器\n\n**地址：[getwaves.io/](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgetwaves.io%2F \"https://link.zhihu.com/?target=https%3A//getwaves.io/\")**\n\n**推荐：★★★★★**\n\n**简介**：通过一些自定义生成简单的波纹。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdafea469e4f4546b30859876548e50e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 11 我可以用这个css吗？\n\n**地址：[caniuse.com/?search=cli…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fcaniuse.com%2F%253Fsearch%253Dclip-path \"https://link.zhihu.com/?target=https%3A//caniuse.com/%3Fsearch%3Dclip-path\")**\n\n**推荐：★★★★★**\n\n**简介**：不要问我，得问它！css浏览器兼容性查询工具\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fe05743d732454389a47ba2446b2a5c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 12 零代码工具箱\n\n**地址：[www.lingdaima.com/](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fwww.lingdaima.com%2F \"https://link.zhihu.com/?target=https%3A//www.lingdaima.com/\")**\n\n**推荐：★★★★★**\n\n**简介**：各种前端实用的好工具，杜绝造轮子，每款工具都经过精心打磨，帮助所有程序员提高前端开发效率！\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/027583369cf74941ad133e5afe749a59~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n### 13 css技巧\n\n**地址：[lhammer.cn/You-need-to…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Flhammer.cn%2FYou-need-to-know-css%2F \"https://link.zhihu.com/?target=https%3A//lhammer.cn/You-need-to-know-css/\")**\n\n**推荐：★★★★★**\n\n**简介**：css小技巧合集，一直在更新！\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd51f386de2446bfac0786d11f49dd70~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)','2022-07-07 01:12:00',0000000007,'前端',0),(0000000009,'知识点整理： vue一些高级概念','混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。','![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf111c39bc8742218da6ffaf54a81f70~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n## 混入mixins\n\n### 官方解释\n\n> 混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\n\n简单的来说就是 Mixins 是我们`可以重用`的代码块，在实际开发中，如果有些代码重复性比较高，这时候可以考虑 Mixins 这个特性。\n\n简单的mixin示例\n\n```\nexport default {\n  data() {\n    return {\n      name: \'来自mixin的name\',\n      arr: [\n        1,\n        {\n          arrName: \'来自mixin\',\n          arrMixin: \'来自mixin\'\n        },\n        1233\n      ],\n      obj: { name: \'来自mixin\', value: \'来自mixin\', mixin: \'只有mixin才有的字段\' }\n    }\n  },\n  created() {\n    console.log(\'我是mixin的created---\')\n  },\n  mounted() {\n    console.log(\'我是mixin的mounted---\')\n    this.getInfo()\n  },\n  methods: {\n    getInfo() {\n      console.log(\'我是mixin, getInfo:\', this.name)\n      console.log(\'我是mixin的obj:\', this.obj)\n      console.log(\'我是mixin的arr:\', this.arr)\n    }\n  }\n}\n\n复制代码\n```\n\n组件中使用\n\n```\nimport mixinDemo from \'./mixin.js\'\nexport default {\n  name: \'\',\n  mixins: [mixinDemo],\n  components: {},\n  data() {\n    return {\n      name: \'组件中的name\',\n      arr: [\n        2,\n        {\n          arrName: \'来自组件的arrName\',\n          title: \'来自组件的独有字段title\'\n        }\n      ],\n      obj: { name: \'来自组件name\', value: \'来自组件value\', title: \'只有组件才有的title字段\' }\n    }\n  },\n  computed: {},\n  watch: {},\n  created() {\n    console.log(\'---我是组件的created---\')\n  },\n  mounted() {\n    console.log(\'---我是组件的mounted---\')\n\n    this.getInfo()\n  },\n  methods: {\n    getInfo() {\n      console.log(\'我是组件的, getInfo:\', this.name)\n      console.log(\'我是组件的obj:\', this.obj)\n      console.log(\'我是组件的arr:\', this.arr)\n    }\n  }\n}\n复制代码\n```\n\n控制台结果\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7ba6545f4ce466b904c6a1bc6452a6a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n通过以上结果可以发现\n\n*   生命周期钩子函数会`合并`起来，`都会执行`。**先执行mixins的钩子函数 再 执行组件的钩子函数**。\n\n*   data 的同名数据，要分情况讨论\n\n\n> 如果是基本类型，会用组件的同名数据覆盖mixin的数据。\n>\n> 但是如果是对象，数据对象在内部会进行`递归`合并，并在发生冲突时以**组件数据优先**。类似 `Object.assign(mixinObj, componentObj)`;\n>\n> 数组的话则直接以`组件`中的数据优先\n\n*   methods的方法也是一样，会用组件的方法覆盖mixin的同名方法。\n\n*   除了上面这些，还有例如 `methods`、`components` 和 `directives`，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对，**同名的会覆盖，以组件的为优先**。\n\n\n### 全局混入\n\n混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响**每一个**之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑。\n\n### 混入造成的问题\n\n用得太多的话，容易混乱。后期维护的时候，不容易查找变量或者方法。\n\n## 自定义指令 directive\n\n### 简介\n\n除了核心功能默认内置的指令 (`v-model` 和 `v-show`)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。\n\n比如项目中常用的水印功能。我们对一个 div 范围内添加水印样式。可以用到自定义指令。\n\n首先看看效果图\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fca9143907544d649f2dd573a78924d9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\n\n生成水印有许多方法。我们现在通过自定义指令的方式来操作，以便熟悉自定义指令的使用。\n\n先上代码\n\n#### 方法文件\n\n```\nfunction addWaterMarker(str, parentNode, font, textColor) {\n  // 水印文字生成方法 略\n}\n\nconst waterMarker = {\n  name: \'waterMarker\',\n  bind: function(el, binding) {\n    addWaterMarker(binding.value, el)\n  },\n  update: function(el, binding) {\n    if (binding.oldValue !== binding.value) {\n      addWaterMarker(binding.value, el)\n    }\n  }\n}\n\nexport default waterMarker\n复制代码\n```\n\n##### 注册自定义指令\n\n```\nimport Vue from \'vue\'\nimport waterMarker from \'./watermark.js\'\nVue.directive(waterMarker.name, waterMarker)\n复制代码\n```\n\n##### main.js全局调用\n\n```\nimport \'./directive.js\'\n复制代码\n```\n\n##### 组件中使用\n\n指令需要用 `v- + 指令名` 方式引用\n\n```\n<div v-waterMarker=\"\'我是水印\'\" class=\"wrapper\"></div>\n复制代码\n```\n\n#### 指令的钩子函数\n\n一个指令定义对象可以提供如下几个钩子函数 (均为可选)：\n\n*   `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\n\n*   `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\n\n*   `update`：所在组件的 VNode 更新时调用，**但是可能发生在其子 VNode 更新之前**。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。\n\n*   `componentUpdated`：指令所在组件的 VNode **及其子 VNode** 全部更新后调用。\n\n*   `unbind`：只调用一次，指令与元素解绑时调用。\n\n\n#### 指令钩子函数会被传入以下参数：\n\n*   `el`：指令所绑定的元素，可以用来直接操作 DOM。\n\n*   `binding`：一个对象，包含以下 property：\n\n    *   `name`：指令名，不包括 `v-` 前缀。\n    *   `value`：指令的绑定值，例如：`v-my-directive=\"1 + 1\"` 中，绑定值为 `2`。\n    *   `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。\n    *   `expression`：字符串形式的指令表达式。例如 `v-my-directive=\"1 + 1\"` 中，表达式为 `\"1 + 1\"`。\n    *   `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `\"foo\"`。\n    *   `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`。\n*   `vnode`：Vue 编译生成的虚拟节点。移步 [VNode API](https://link.juejin.cn?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%23VNode-%25E6%258E%25A5%25E5%258F%25A3 \"https://cn.vuejs.org/v2/api/#VNode-%E6%8E%A5%E5%8F%A3\") 来了解更多详情。\n\n*   `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用。\n\n\n### 组件中局部自定义指令\n\n```\nexport default {\n  directives: {\n    waterMarker: {\n      // 当前指令的钩子函数 略\n      bind() {}\n    }\n  }\n}\n复制代码\n```\n\n## 过滤器 filter\n\nVue过滤器本质上是一个函数，它接受一个值，处理它，然后返回处理过的值。\n\n过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道 ( | ) ”符号指示\n\n##### 组件中使用\n\n```\n<div class=\"btn-list\">\n  {{ btn | btnFilter }}\n</div>\n<div class=\"btn-list\" :id=\"btn2 | btnFilter\">id</div>\n复制代码\n```\n\n##### 组件中定义过滤器\n\n```\nconst filterList = [\n  { key: 1, text: \'提交\' },\n  { key: 2, text: \'查看\' },\n  { key: 3, text: \'编辑\' },\n  { key: 4, text: \'删除\' }\n]\nexport default {\n  filters: {\n    btnFilter(val) {\n      return filterList.find(item => item.key === val).text\n    }\n  },\n  data() {\n    return {\n      btn: 1,\n      btn2: 3\n    }\n  }\n}\n复制代码\n```\n\n全局定义过滤器\n\n```\nimport Vue from \'vue\'\nVue.filter(\'btnFilter\', function (value) {\n    // 逻辑代码...\n})\n\n\n--------\n// 再到main.js引用即可\n复制代码\n```\n\n过滤器可以 **串联** 使用\n\n```\n{{ btn | btnFilter | newBtnFilter}}\n复制代码\n```\n\n上述 `btn` 作为参数传入到 `btnFilter` 中，然后继续调用 `newBtnFilter`，此时将以 `btnFilter` 的结果作为参数使用\n\n过滤器是 JavaScript 函数，因此可以 **接收参数**\n\n```\n{{ btn | btnFilter(\'arg1\', \'arg2\')}}\n复制代码\n```\n\n这里的 btnFilter 相当于是接收三个参数的函数，其中 btn 为第一个参数， \'arg1\' 为第二个参数， \'arg2\' 为第三个参数。\n\n## 过渡\n\nVue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具：\n\n*   在 CSS 过渡和动画中自动应用 class\n*   可以配合使用第三方 CSS 动画库，如 Animate.css\n*   在过渡钩子函数中使用 JavaScript 直接操作 DOM\n*   可以配合使用第三方 JavaScript 动画库，如 Velocity.js\n\nVue 提供了 `transition` 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡\n\n*   条件渲染 (使用 `v-if`)\n*   条件展示 (使用 `v-show`)\n*   动态组件\n*   组件根节点\n\n示例\n\n```\n<div class=\"btn-list\" @click=\"show\">\n  {{ btn | btnFilter }}\n</div>\n<transition name=\"a\">\n  <p v-if=\"isShow\">过渡动画呀</p>\n</transition>\n复制代码\n```\n```\nexport default {\n  data() {\n    return {\n      isShow: true\n    }\n  },\n   methods: {\n    show() {\n      this.isShow = !this.isShow\n    }\n  }\n}\n复制代码\n```\n```\n.a-enter-active,\n.a-leave-active {\n  transition: opacity 0.5s;\n}\n.a-enter,\n.a-leave-to {\n  opacity: 0;\n}\n复制代码\n```\n\n当插入或删除包含在 `transition` 组件中的元素时，Vue 将会做以下处理：\n\n1.  自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。\n2.  如果过渡组件提供了 [JavaScript 钩子函数](https://link.juejin.cn?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Ftransitions.html%23JavaScript-%25E9%2592%25A9%25E5%25AD%2590 \"https://cn.vuejs.org/v2/guide/transitions.html#JavaScript-%E9%92%A9%E5%AD%90\")，这些钩子函数将在恰当的时机被调用。\n3.  如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和 Vue 的 `nextTick` 概念不同)\n\n### 过渡的类名\n\n在进入/离开的过渡中，会有 6 个 class 切换。\n\n1.  `v-enter`：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。\n2.  `v-enter-active`：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。\n3.  `v-enter-to`：**2.1.8 版及以上**定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 `v-enter` 被移除)，在过渡/动画完成之后移除。\n4.  `v-leave`：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。\n5.  `v-leave-active`：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。\n6.  `v-leave-to`：**2.1.8 版及以上**定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 `v-leave` 被删除)，在过渡/动画完成之后移除。\n\n`<transition>` 中的 name 对应上述类名的 v , 如： `name=\"a\"` 则对应类名为 `a-enter` 等。如果你使用一个没有名字的 `<transition>`则 `v-` 是这些类名的默认前缀。\n\n如此，我们就可以通过编写不同的 css 动画样式，配合`<transition>`来达到不同的效果。\n\n### JavaScript 钩子\n\n```\n <transition\n      v-on:before-enter=\"beforeEnter\"\n      v-on:enter=\"enter\"\n      v-on:after-enter=\"afterEnter\"\n      v-on:enter-cancelled=\"enterCancelled\"\n      v-on:before-leave=\"beforeLeave\"\n      v-on:leave=\"leave\"\n      v-on:after-leave=\"afterLeave\"\n      v-on:leave-cancelled=\"leaveCancelled\"\n    >\n      <!-- ... -->\n    </transition>\n复制代码\n```\n\n此时可以在不同的钩子中，使用 `Velocity` 等动画库来实现我们需要的动画效果。','2022-07-27 07:51:00',0000000006,'前端',0),(0000000010,'最详细的 Vue3 + TypeScript 使用教程【值得收藏】','','> 哈喽,大家好 我是`xy`??‍?。最近技术栈刚刚由之前的 `React` 转向 `Vue3`了，由于之前多多少少也接触过 `Vue`，所以这次只用了一个上午的时间就上手 `Vue3` 了，如果大家有关于`vue`或者`react`上的问题，欢迎来滴滴我，一起交流学习 ?\n\n至于技术栈为什么由 `react` 转向 `vue3`，也是因为今年换了新工作，公司技术栈以`vue3`为主，刚好前段时间又接手了一个项目，就直接采用 `Vue3` `script setup` `typescript` 开发，于是今天就想给大家分享下 `script setup` 结合 `typescript` 使用的一些技巧，如果这些技巧能够帮助到你，记得给我点个赞呦 ?\n\n## 环境搭建\n\n环境搭建这里就不详细介绍了，可以直接使用官方的方式创建\n\n```\nnpm init vue@latest\n复制代码\n```\n\n这一指令将会安装并执行 `create-vue`，它是 `Vue` 官方的项目脚手架工具。你将会看到一些诸如 `TypeScript` 和`测试`支持之类的可选功能提示：\n\n```\n✔ Project name: … <your-project-name>\n✔ Add TypeScript? … No / Yes\n✔ Add JSX Support? … No / Yes\n✔ Add Vue Router for Single Page Application development? … No / Yes\n✔ Add Pinia for state management? … No / Yes\n✔ Add Vitest for Unit testing? … No / Yes\n✔ Add Cypress for both Unit and End-to-End testing? … No / Yes\n✔ Add ESLint for code quality? … No / Yes\n✔ Add Prettier for code formatting? … No / Yes\n\nScaffolding project in ./<your-project-name>...\nDone.\n复制代码\n```\n\n如果不确定是否要开启某个功能，你可以直接按下回车键选择 `No`。在项目被创建后，通过以下步骤安装依赖并启动开发服务器：\n\n```\ncd <your-project-name>\nnpm install\nnpm run dev\n复制代码\n```\n\n想看更多的`详细配置`的同学，可以移步到我之前的一篇文章中：\n\n[![Vite2＋Vue3.x＋TypeScript 搭建一套企业级的开发脚手架](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a43d7e731f6f439f968e0c628a7cb4b7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FBcxeuh8fUoRIF2DNnPj5HA \"https://mp.weixin.qq.com/s/Bcxeuh8fUoRIF2DNnPj5HA\")\n\n这里就不做过多的讲解了，这篇文章的重点还是在 `script setup` `typescript` 结合使用上\n\n## ref()\n\n`ref()`接受一个内部值，返回一个响应式的、可更改的 `ref` 对象，此对象只有一个指向其内部值的 `property .value`。\n\n### 类型定义\n\n```\nfunction ref<T>(value: T): Ref<UnwrapRef<T>>\ninterface Ref<T> {\n  value: T\n}\n复制代码\n```\n\n### 为 ref() 标注类型\n\n`ref()` 标注类型有三种方式：\n\n1.  通过泛型参数的形式来给 `ref()`增加类型\n\n```\nimport { ref } from \'vue\'\n\nconst initCode = ref<string | number>(\'200\')\n复制代码\n```\n\n2.  如果是遇到复杂点的类型，可以自定义 `interface` 然后泛型参数的形式传入\n\n```\nimport { ref } from \'vue\'\n\ninterface User {\n  name: string\n  age: string | number\n}\n\nconst user = ref<User>({\n  name:\'前端开发爱好者\',\n  age: 20\n})\n复制代码\n```\n\n3.  通过使用 `Ref` 这个类型为 `ref` 内的值指定一个更复杂的类型\n\n```\nimport { ref } from \'vue\'\nimport type { Ref } from \'vue\'\n\nconst initCode: Ref<string | number> = ref(\'200\')\n复制代码\n```\n\n### 三种方式推荐\n\n比较推荐使用`前两种`方式，前两种方式其实都是以`泛型`的形式来标注类型的\n\n第三种方式需要额外的引入：\n\n```\nimport type { Ref } from \'vue\'\n复制代码\n```\n\n所以不是很推荐(本着能少写一行是一行原则)\n\n## reactive()\n\n`reactive()` 返回一个对象的响应式代理。\n\n### 类型定义\n\n```\nfunction reactive<T extends object>(target: T): UnwrapNestedRefs<T>\n复制代码\n```\n\n### 为 reactive() 标注类型\n\n`reactive()`标注类型有两种方式：\n\n1.  直接给声明的变量添加类型\n\n```\nimport { reactive } from \'vue\'\n\ninterface User {\n  name: string\n  age: string | number\n}\n\nconst user:User = reactive({\n  name:\"前端开发爱好者\",\n  age:\'20\'\n})\n复制代码\n```\n\n2.  通过泛型参数的形式来给 `reactive()`增加类型\n\n```\nimport { reactive } from \'vue\'\n\ninterface User {\n  name: string\n  age: string | number\n}\n\nconst user = reactive<User>({\n  name:\"前端开发爱好者\",\n  age:\'20\'\n})\n复制代码\n```\n\n### 两种方式推荐\n\n`不推荐`使用 `reactive()` 的泛型参数,因为处理了深层次 ref 解包的返回值与泛型参数的类型不同。`推荐直接给声明的变量添加类型`。\n\n## computed ()\n\n接受一个 `getter` 函数，返回一个只读的响应式 `ref` 对象，即 `getter` 函数的返回值。它也可以接受一个带有 `get` 和 `set` 函数的对象来创建一个可写的 `ref` 对象。\n\n### 类型定义\n\n```\n// 只读\nfunction computed<T>(\n  getter: () => T,\n  debuggerOptions?: DebuggerOptions\n): Readonly<Ref<Readonly<T>>>\n\n// 可写的\nfunction computed<T>(\n  options: {\n    get: () => T\n    set: (value: T) => void\n  },\n  debuggerOptions?: DebuggerOptions\n): Ref<T>\n复制代码\n```\n\n### 为 computed() 标注类型\n\n`computed()`标注类型有两种方式：\n\n1.  从其计算函数的返回值上推导出类型\n\n```\nimport { ref, computed } from \'vue\'\n\nconst count = ref<number>(0)\n\n// 推导得到的类型：ComputedRef<string>\nconst user = computed(() => count.value + \'前端开发爱好者\')\n复制代码\n```\n\n2.  通过泛型参数显式指定 `computed()` 类型\n\n```\nconst user = computed<string>(() => {\n  // 若返回值不是 string 类型则会报错\n  return \'前端开发爱好者\'\n})\n复制代码\n```\n\n### 两种方式推荐\n\n自动推导类型虽然简单快捷，但是还是希望`手动`的去`指定`其类型，这样更加利于代码的可维护性，所以这里推荐大家使用通过泛型参数显式指定 `computed()` 类型\n\n## defineProps()\n\n为了在声明 `props` 选项时获得完整的类型推断支持，我们可以使用 `defineProps` API，它将自动地在 `script setup` 中使用\n\n### 为 defineProps() 标注类型\n\n1.  从它的参数中推导类型:\n\n```\nconst props = defineProps({\n  name: { type: String, required: true },\n  age: Number\n})\n复制代码\n```\n\n2.  通过泛型参数来定义 `props` 的类型\n\n```\nconst props = defineProps<{\n  name: string\n  age?: number\n}>()\n复制代码\n```\n\n当然了,我们也可以吧以上的泛型参数定义成一个单独的 `interface`\n\n```\ninterface Props {\n  name: string\n  age?: number\n}\n\nconst props = defineProps<Props>()\n复制代码\n```\n\n> 以上的两种方式虽然都可以很方便的`标注类型`, 但是失去了对 `props` 定义默认值的能力\n\n目前官方也给出了解决方案,但是目前这个方案还处于实验性,并且需要`显式地选择开启`。\n\n```\n// vite.config.js\nexport default {\n  plugins: [\n    vue({\n      reactivityTransform: true\n    })\n  ]\n}\n复制代码\n```\n\n通过对 `defineProps()` 的响应性解构来添加默认值:\n\n```\n<script setup lang=\"ts\">\ninterface Props {\n  name: string\n  age?: number\n}\n\nconst { name = \'前端开发爱好者\', age = 100 } = defineProps<Props>()\n</script>\n复制代码\n```\n\n## defineEmits()\n\n为了在声明 `emits` 选项时获得完整的类型推断支持，我们可以使用 `defineEmits` API，它将自动地在 `script setup` 中使用\n\n### 为 defineEmits() 标注类型\n\n`defineEmits()` 标注类型直接推荐`泛型`形式\n\n```\nimport type { GlobalTheme } from \'naive-ui\'\n\nconst emit = defineEmits<{\n  (e: \'setThemeColor\', val: GlobalTheme): void\n}>()\n复制代码\n```\n\n虽然官方还推荐了`运行时`自动推导的一种形式,但是本人不是很推荐\n\n## defineExpose()\n\n`defineExpose()` 编译器宏来显式指定在 `script setup` 组件中要暴露出去的 `property`,使得父组件通过`模板ref`的方式获取到当前组件的实例\n\n### 为 defineExpose() 标注类型\n\n`defineExpose()` 类型推导直接使用参数类型自动推到即可\n\n```\n<script setup>\nimport { ref } from \'vue\'\n\nconst name = ref<string>(\'前端开发爱好者\')\n\ndefineExpose({\n  name\n})\n复制代码\n```\n\n## provide()\n\n`provide()`供给一个值，可以被后代组件注入\n\n### 类型定义\n\n```\nfunction provide<T>(key: InjectionKey<T> | string, value: T): void\n复制代码\n```\n\n### 为 provide() 标注类型\n\n为 `provide()` 标注类型, Vue 提供了一个 `InjectionKey` 接口，它是一个继承自 `Symbol` 的泛型类型，可以用来在提供者和消费者之间同步注入值的类型\n\n```\nimport type { InjectionKey } from \'vue\'\n\n// 建议声明 key (name) 放到公共的文件中\n// 这样就可以在 inject 的时候直接导入使用\nconst name = Symbol() as InjectionKey<string>\n\nprovide(name, \'前端开发爱好者\') // 若提供的是非字符串值会导致错误\n复制代码\n```\n\n以上方式是通过定义 key 的类型来标注类型的,还有一种方式直接 `key` 采用`字符串`的形式添加\n\n```\nprovide(\'name\', \'前端开发爱好者\')\n复制代码\n```\n\n## inject()\n\n`inject()`注入一个由祖先组件或整个应用供给的值\n\n### 类型定义\n\n```\n// 没有默认值\nfunction inject<T>(key: InjectionKey<T> | string): T | undefined\n\n// 带有默认值\nfunction inject<T>(key: InjectionKey<T> | string, defaultValue: T): T\n\n// 使用工厂函数\nfunction inject<T>(\n  key: InjectionKey<T> | string,\n  defaultValue: () => T,\n  treatDefaultAsFactory: true\n): T\n复制代码\n```\n\n### 为 inject() 标注类型\n\n`provide()` 的 `key` 的类型是声明式提供的话(provide()类型标注的第一种形式)\n\n`inject()` 可以直接导入声明的 `key` 来获取父级组件提供的值\n\n```\n// 由外部导入\nconst name = Symbol() as InjectionKey<string>\n\nconst injectName = inject(name)\n复制代码\n```\n\n如果 `provide()` 的 `key` 直接使用的`字符串`形式添加的, 需要通过泛型参数声明\n\n```\nconst injectName = inject<string>(\'name\')\n复制代码\n```\n\n## 模板 ref\n\n模板 `ref` 需要通过一个显式指定的`泛型参数`和一个`初始值 null` 来创建：\n\n```\n<img ref=\"el\" class=\"logo\" :src=\"Logo\" alt=\"\" />\n\nconst el = ref<HTMLImageElement | null>(null)\n复制代码\n```\n\n## 组件 ref\n\n有时，你可能需要为一个子组件添加一个模板 ref，以便调用它公开的方法\n\n```\n<!-- Child.vue -->\n<script setup lang=\"ts\"> const handleLog = () => console.log(\'前端开发爱好者\')\n\ndefineExpose({\n  open\n}) </script>\n复制代码\n```\n\n为了获取 `MyModal` 的类型，我们首先需要通过 `typeof` 得到其类型，再使用 `TypeScript` 内置的 `InstanceType` 工具类型来获取其实例类型：\n\n```\n<!-- parent.vue -->\n<script setup lang=\"ts\"> import Child from \'./Child.vue\'\n\n// 为子组件 ref 声明类型\nconst child = ref<InstanceType<typeof Child> | null>(null)\n\n// 调用子组件中的方法\nconst getChildHandleLog = () => {\n  child.value?.handleLog()\n} </script>\n复制代码\n```\n\n## 事件处理器\n\n原生的 DOM 事件标注类型\n\n```\n<template>\n  <input type=\"text\" @change=\"handleChange\" />\n</template>\n\n<script setup lang=\"ts\"> function handleChange(event: Event) {\n  console.log((event.target as HTMLInputElement).value)\n} </script>\n复制代码\n```','2022-07-17 08:19:00',0000000005,'前端',0),(0000000011,'ES2022新规发布，8个实用新功能','JavaScript 不是一种开源语言，它是一种需要遵循 ECMAScript 标准规范编写的语言，TC39 委员会负责讨论和批准新功能的发布， 那TC39他们是谁？','![ES2022新规发布，8个实用新功能](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46d108b60511497a9ec4115ffb1ed29d~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n**新的 ES13 规范终于发布了。**\n\nJavaScript 不是一种开源语言，它是一种需要遵循 ECMAScript 标准规范编写的语言，TC39 委员会负责讨论和批准新功能的发布， 那TC39他们是谁？\n\n“ECMA International 的 TC39 是一群 JavaScript 开发人员、实施者、学者等，他们与社区合作维护和发展 JavaScript 的定义。” — TC39.es\n\n他们的发布过程由五个阶段组成，自 2015 年以来，他们一直在进行年度发布，它们通常发生在春天举行发布。\n\n有两种方法可以引用任何 ECMAScript 版本：\n\n*   按年份：这个新版本将是 ES2022。\n*   按其迭代次数：这个新版本将是第 13 次迭代，所以它可以被称为 ES13。\n\n那么这次这个版本有什么新东西呢？我们可以对哪些功能感到兴奋？\n\n**01、正则表达式匹配索引**\n\n目前，在 JavaScript 中使用 JavaScript Regex API 时，仅返回匹配的开始索引。但是，对于一些特殊的高级场景，这还不够。\n\n作为这些规范的一部分，添加了一个特殊的标志 d。通过使用它，正则表达式 API 将返回一个二维数组作为名索引的键。它包含每个匹配项的开始和结束索引。如果在正则表达式中捕获了任何命名组，它将在 indices.groups 对象中返回它们的开始/结束索引， 命名的组名将是它的键。\n\n```\n// ✅ a regex with a \'B\' named group capture\nconst expr = /a+(?<B>b+)+c/d;\n\nconst result = expr.exec(\"aaabbbc\")\n\n// ✅ shows start-end matches + named group match\nconsole.log(result.indices);\n// prints [Array(2), Array(2), groups: {…}]\n\n// ✅ showing the named \'B\' group match\nconsole.log(result.indices.gr\noups[\'B\'])\n// prints [3, 6]\n复制代码\n```\n\n查看原始提案，[github.com/tc39/propos…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Ftc39%2Fproposal-regexp-match- \"https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-regexp-match-\") indices\n\n**02、Top-level await**\n\n在此提案之前，不接受Top-level await，但有一些变通方法可以模拟这种行为，但其有缺点。\n\nTop-level await 特性让我们依靠模块来处理这些 Promise。这是一个直观的功能。\n\n但是请注意，它可能会改变模块的执行顺序， 如果一个模块依赖于另一个具有Top-level await 调用的模块，则该模块的执行将暂停，直到 promise 完成。\n\n让我们看一个例子：\n\n```\n// users.js\nexport const users = await fetch(\'/users/lists\');\n\n// usage.js\nimport { users } from \"./users.js\";\n// ✅ the module will wait for users to be fullfilled prior to executing any code\nconsole.log(users);\n复制代码\n```\n\n在上面的示例中，引擎将等待用户完成操作，然后，再执行 usage.js 模块上的代码。\n\n总之，这是一个很好且直观的功能，需要小心使用，我们不要滥用它。\n\n在此处查看原始提案。[github.com/tc39/propos…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Ftc39%2Fproposal-top-level-await \"https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-top-level-await\")\n\n**03、.at( )**\n\n长期以来，一直有人要求 JavaScript 提供类似 Python 的数组负索引访问器。而不是做 array\\[array.length-1\\] 来做简单的 array\\[-1\\]。这是不可能的，因为 \\[\\] 符号也用于 JavaScript 中的对象。\n\n被接受的提案采取了更实际的方法。Array 对象现在将有一个方法来模拟上述行为。\n\n```\nconst array = [1,2,3,4,5,6]\n\n// ✅ When used with positive index it is equal to [index]\narray.at(0) // 1\narray[0] // 1\n\n// ✅ When used with negative index it mimicks the Python behaviour\narray.at(-1) // 6\narray.at(-2) // 5\narray.at(-4) // 3\n复制代码\n```\n\n查看原始提案，[github.com/tc39/propos…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Ftc39%2Fproposal-relative-indexing-method \"https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-relative-indexing-method\")\n\n顺便说一句，既然我们在谈论数组，你知道你可以解构数组位置吗？\n\n```\nconst array = [1,2,3,4,5,6];\n\n// ✅ Different ways of accessing the third position\nconst {3: third} = array; // third = 4\narray.at(3) // 4\narray[3] // 4\n复制代码\n```\n\n**04、可访问的 Object.prototype.hasOwnProperty**\n\n以下只是一个很好的简化， 已经有了 hasOwnProperty。但是，它需要在我们想要执行的查找实例中调用。因此，许多开发人员最终会这样做是很常见的：\n\n```\nconst x = { foo: \"bar\" };\n\n// ✅ grabbing the hasOwnProperty function from prototype\nconst hasOwnProperty = Object.prototype.hasOwnProperty\n\n// ✅ executing it with the x context\nif (hasOwnProperty.call(x, \"foo\")) {\n  ...\n}\n复制代码\n```\n\n通过这些新规范，一个 hasOwn 方法被添加到 Object 原型中，现在，我们可以简单地做：\n\n```\nconst x = { foo: \"bar\" };\n\n// ✅ using the new Object method\nif (Object.hasOwn(x, \"foo\")) {\n  ...\n}\n复制代码\n```\n\n查看原始提案，[github.com/tc39/propos…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Ftc39%2Fproposal-accessible-object-hasownproperty \"https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-accessible-object-hasownproperty\")\n\n**05、Error Cause**\n\n错误帮助我们识别应用程序的意外行为并做出反应，然而，理解深层嵌套错误的根本原因，正确处理它们可能会变得具有挑战性，在捕获和重新抛出它们时，我们会丢失堆栈跟踪信息。\n\n没有关于如何处理的明确协议，考虑到任何错误处理，我们至少有 3 个选择：\n\n```\nasync function fetchUserPreferences() {\n  try {\n    const users = await fetch(\'//user/preferences\')\n      .catch(err => {\n        // What is the best way to wrap the error?\n        // 1. throw new Error(\'Failed to fetch preferences \' + err.message);\n        // 2. const wrapErr = new Error(\'Failed to fetch preferences\');\n        //    wrapErr.cause = err;\n        //    throw wrapErr;\n        // 3. class CustomError extends Error {\n        //      constructor(msg, cause) {\n        //        super(msg);\n        //        this.cause = cause;\n        //      }\n        //    }\n        //    throw new CustomError(\'Failed to fetch preferences\', err);\n      })\n    }\n}\nfetchUserPreferences();\n复制代码\n```\n\n作为这些新规范的一部分，我们可以构造一个新错误并保留获取的错误的引用。我们只需将对象 {cause: err} 传递给 Errorconstructor。\n\n这一切都变得更简单、标准且易于理解深度嵌套的错误， 让我们看一个例子：\n\n```\nasync function fetcUserPreferences() {\n  try {\n    const users = await fetch(\'//user/preferences\')\n      .catch(err => {\n        throw new Error(\'Failed to fetch user preferences, {cause: err});\n      })\n    }\n}\nfetcUserPreferences();\n复制代码\n```\n\n了解有关该提案的更多信息，[github.com/tc39/propos…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Ftc39%2Fproposal-error-cause \"https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-error-cause\")\n\n**06、Class Fields**\n\n在此版本之前，没有适当的方法来创建私有字段， 通过使用提升有一些方法可以解决它，但它不是一个适当的私有字段。但现在很简单， 我们只需要将 # 字符添加到我们的变量声明中。\n\n```\nclass Foo {\n  #iteration = 0;\n\n  increment() {\n    this.#iteration++;\n  }\n\n  logIteration() {\n    console.log(this.#iteration);\n  }\n}\n\nconst x = new Foo();\n\n// ❌ Uncaught SyntaxError: Private field \'#iteration\' must be declared in an enclosing class\nx.#iteration\n\n// ✅ works\nx.increment();\n\n// ✅ works\nx.logIteration();\n复制代码\n```\n\n拥有私有字段意味着我们拥有强大的封装边界， 无法从外部访问类变量，这表明 class 关键字不再只是糖语法。\n\n我们还可以创建私有方法：\n\n```\nclass Foo {\n  #iteration = 0;\n\n  #auditIncrement() {\n    console.log(\'auditing\');\n  }\n\n  increment() {\n    this.#iteration++;\n    this.#auditIncrement();\n  }\n}\n\nconst x = new Foo();\n\n// ❌ Uncaught SyntaxError: Private field \'#auditIncrement\' must be declared in an enclosing class\nx.#auditIncrement\n\n// ✅ works\nx.increment();\n复制代码\n```\n\n该功能与私有类的类静态块和人体工程学检查有关，我们将在接下来的内容中看到。\n\n了解有关该提案的更多信息，[github.com/tc39/propos…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Ftc39%2Fproposal-class-fields \"https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-class-fields\")\n\n**07、Class Static Block**\n\n作为新规范的一部分，我们现在可以在任何类中包含静态块，它们将只运行一次，并且是装饰或执行类静态端的某些字段初始化的好方法。\n\n我们不限于使用一个块，我们可以拥有尽可能多的块。\n\n```\n// ✅ will output \'one two three\'\nclass A {\n  static {\n      console.log(\'one\');\n  }\n  static {\n      console.log(\'two\');\n  }\n  static {\n      console.log(\'three\');\n  }\n}\n复制代码\n```\n\n他们有一个不错的奖金，他们获得对私有字段的特权访问， 你可以用它们来做一些有趣的模式。\n\n```\nlet getPrivateField;\n\nclass A {\n  #privateField;\n  constructor(x) {\n    this.#privateField = x;\n  }\n  static {\n    // ✅ it can access any private field\n    getPrivateField = (a) => a.#privateField;\n  }\n}\n\nconst a = new A(\'foo\');\n// ✅ Works, foo is printed\nconsole.log(getPrivateField(a));\n复制代码\n```\n\n如果我们尝试从实例对象的外部范围访问该私有变量，我们将得到无法从类未声明它的对象中读取私有成员#privateField。\n\n了解有关该提案的更多信息，[github.com/tc39/propos…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Ftc39%2Fproposal-class-static-block \"https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-class-static-block\")\n\n**08、Private Fields**\n\n新的私有字段是一个很棒的功能，但是，在某些静态方法中检查字段是否为私有可能会变得很方便。\n\n尝试在类范围之外调用它会导致我们之前看到的相同错误。\n\n```\nclass Foo {\n  #brand;\n\n  static isFoo(obj) {\n    return #brand in obj;\n  }\n}\n\nconst x = new Foo();\n\n// ✅ works, it returns true\nFoo.isFoo(x);\n\n// ✅ works, it returns false\nFoo.isFoo({})\n\n// ❌ Uncaught SyntaxError: Private field \'#brand\' must be declared in an enclosing class\n#brand in x\n复制代码\n```\n\n了解有关该提案的更多信息。[github.com/tc39/propos…](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Ftc39%2Fproposal-private-fields-in-in \"https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-private-fields-in-in\")\n\n**最后的想法**\n\n这是一个有趣的版本，它提供了许多小而有用的功能，例如 at、private fields和error cause。当然，error cause会给我们的日常错误跟踪任务带来很多清晰度。\n\n一些高级功能，如top-level await，在使用它们之前需要很好地理解。它们可能在你的代码执行中产生不必要的副作用。\n\n我希望这篇文章能让你和我一样对新的 ES2022 规范感到兴奋，请记得点赞我，关注我。\n\n**\\- End -**\n','2022-07-12 02:37:00',0000000004,'前端',0),(0000000012,'js中关于递归与回溯',' 递归作为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。','![js中关于递归与回溯](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6f8dcd4c39043c581d0a89475bbe412~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n## 何为递归\n\n> 递归作为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。需要注意的是，递归必须要用边界条件，否则很容易导致死循环\n\n## 构成递归条件\n\n1.  子问题须与原始问题为同样的事，且更为简单\n2.  不能无限制地调用本身，须有个出口，化简为非递归状况处理\n\n但是递归函数并不容易一下子就能想的出来，所以我们可以先通过一个子问题来逐步延申。\n\n**问题一：** 假设我们需要求1+2+3+...+100的值，我们很容易想出下面的代码\n\n```\n function calcNum(n) {\n      let sum = 0\n      for (let i = 0; i <= 100; i++) {\n        sum += i\n      }\n      return sum\n    }\n    console.log(calcNum()) // 5050\n复制代码\n```\n\n这样的代码是不满足于递归中，直接或者间接调用本身的定义。那么如何变成递归版本呢？(**任何的循环，都可以写成递归**)\n\n1.  寻找相同的子问题 该题目相同的子问题很明显是sum+=i，该过程是重复调用的过程。\n2.  寻找终止条件 寻找递归的终止条件，该问题的终止条件是i>100的情况\n\n**这两大要素都找到了，就很容易写出下面的递归版本**\n\n```\nfunction calcNum(n) {\n      let sum = 0\n      function dfs(n) {\n        if (n > 100) {\n          return\n        }\n        sum += n\n        n++\n        dfs(n)\n      }\n      dfs(n)\n      return sum\n    }\n    console.log(calcNum(1)) // 5050\n复制代码\n```\n\n## 关于回溯\n\n递归一定伴随着回溯，那么什么是回溯呢？以上面的代码为例子，我们分别在这两处地方输出n的值\n\n```\nfunction calcNum(n) {\n      let sum = 0\n      function dfs(n) {\n        if (n > 100) {\n          return\n        }\n        sum += n\n        n++\n        console.log(n, \'递归前的n\')\n        dfs(n)\n        console.log(n, \'递归后的n\')\n      }\n      dfs(n)\n      return sum\n    }\n复制代码\n```\n\n毫无疑问，\"递归前的n\"会按照1-100输出，而\"递归后的n\"则会100-1输出，这就说明了一个很重要的知识点，**递归函数是类似一个栈迭代的过程，它的值输出的顺序为先进后出**。通俗一点说，递归函数后面的参数，会反转输出。\n\n要想理解回溯的含义，最为经典的还是二叉树的遍历。二叉树的遍历，又分为**前序遍历，中序遍历，后序遍历**，分别通过代码来感受一下这三种遍历的方式。 前序遍历\n\n```\n// 基本结构\n const treeNode = {\n      val: 1,\n      left: null,\n      right: {\n        val: 2,\n        left: {\n          val: 3,\n          left: null,\n          right: null\n        },\n        right: null\n      }\n    }\n复制代码\n```\n\n来看下leetcode [前序遍历](https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fbinary-tree-inorder-traversal%2F \"https://leetcode.cn/problems/binary-tree-inorder-traversal/\")原题 ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9edcd4f3071e439a9535b117c5e8b993~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n```\nconst root = {\n      val: 5,\n      left: {\n        val: 4,\n        left: {\n          val: 1,\n          right: null,\n          left: null\n        },\n        right: {\n          val: 2,\n          right: null,\n          left: null\n        }\n      },\n      right: {\n        val: 6,\n        left: {\n          val: 7,\n          left: null,\n          right: null\n        },\n        right: {\n          val: 8,\n          left: null,\n          right: null\n        }\n      }\n    }\n    function getRoot(root) {\n      const res = []\n      function dfs(root) {\n        if (!root) {\n          return\n        }\n        res.push(root.val)\n        dfs(root.left)\n        dfs(root.right)\n      }\n      dfs(root)\n      return res\n    }\n    console.log(getRoot(root)) // 5 4 1 2 6 7 8\n复制代码\n```\n\n中序遍历\n\n```\nfunction getRoot(root) {\n      const res = []\n      function dfs(root) {\n        if (!root) {\n          return\n        }\n        dfs(root.left)\n        res.push(root.val)\n        dfs(root.right)\n      }\n      dfs(root)\n      return res\n    }\n    console.log(getRoot(root)) // 1 4 2 5 6 7 8\n复制代码\n```\n\n后续遍历\n\n```\nfunction getRoot(root) {\n      const res = []\n      function dfs(root) {\n        if (!root) {\n          return\n        }\n        dfs(root.left)\n        dfs(root.right)\n        res.push(root.val)\n      }\n      dfs(root)\n      return res\n    }\n    console.log(getRoot(root)) // 1 2 4 7 8 6 5\n复制代码\n```\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7de29ee35b24ce798f74f95f54fd614~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) 在写递归的时候，时刻都要注意边界，以上场景的边界，则是找不到节点（节点为null）的时候，就退出。\n\n通过输出的结果可以得知以下规律：\n\n1.  前序遍历：中左右\n2.  中序遍历：左中右\n3.  后序遍历：左右中\n\n而实现该规律的主要依据，是通过递归的回溯导致，我们以中序遍历为例子：\n\n```\n dfs(root.left)\n res.push(root.val)\n dfs(root.right)\n复制代码\n```\n\n当第一个dfs(root.left)递归结束后，就会弹出\'1\'的节点，然后就进了dfs(root.right)的节点，发现是个null，说明这个dfs(root.right)递归结束，那么此时则回到了\'4\'的节点，然后就进入了dfs(root.right)节点...\n\n## 实际业务\n\n二叉树的遍历，其实类比于我们常见操作菜单树，或着树形结构的操作...\n\n```\nlet tree = [\n  {\n    id: \'1\',\n    title: \'节点1\',\n    children: [\n      {\n        id: \'1-1\',\n        title: \'节点1-1\'\n      },\n      {\n        id: \'1-2\',\n        title: \'节点1-2\'\n      }\n    ]\n  },\n  {\n    id: \'2\',\n    title: \'节点2\',\n    children: [\n      {\n        id: \'2-1\',\n        title: \'节点2-1\'\n      }\n    ]\n  }\n]\n复制代码\n```\n\n当我们要寻找遍历每个节点的时候，同样需要注意边界，当我们操作的数据没有的时候或者不存在的时候，则退出当次遍历。\n\n```\n function getRootData(tree) {\n      const res = []\n      function dfs(tree) {\n        if (!tree || tree.length === 0) {\n          return res\n        }\n        for (let i = 0; i < tree.length; i++) {\n          const t = tree[i]\n          if (t.children && t.children.length > 0) {\n            dfs(t.children) // 开始递归\n          } else {\n            res.push(t.title) //  [\'节点1-1\', \'节点1-2\', \'节点2-1\']\n          }\n        }\n      }\n      dfs(tree)\n      return res\n    }\n复制代码\n```\n\n可能有人会有疑问，这也没有利用到回溯的操作啊，那么我就换个场景，假如**我给个你节点的id，你帮我找出他所有的父节点**，那么你可能会怎么操作呢？\n\n```\n const tree = [\n      {\n        id: \'1\',\n        title: \'节点1\',\n        children: [\n          {\n            id: \'1-1\',\n            title: \'节点1-1\'\n          },\n          {\n            id: \'1-2\',\n            title: \'节点1-2\'\n          }\n        ]\n      },\n      {\n        id: \'2\',\n        title: \'节点2\',\n        children: [\n          {\n            id: \'2-1\',\n            title: \'节点2-1\',\n            children: [\n              {\n                id: \'2-1-1\',\n                title: \'节点2-1-1\'\n              }\n            ]\n          }\n        ]\n      }\n    ]\n    function pathTree(tree, id) {\n      const res = []\n      function dfs(tree, path) {\n        if (!tree || tree.length === 0) {\n          return\n        }\n        for (let i = 0; i < tree.length; i++) {\n          const t = tree[i]\n          path.push(t.id)\n          if (path.includes(id)) {\n            res.push(path.slice())\n          }\n          if (t.children && t.children.length > 0) {\n            dfs(t.children, path)\n          }\n          path.pop() // 路径回溯\n        }\n      }\n      dfs(tree, [])\n      return res\n    }\n    console.log(pathTree(tree, \'2-1-1\')) // [2,2-1,2-1-1]\n复制代码\n```\n\n其实以上核心的代码为path.pop()，为什么需要这句代码呢？我们可以通过leetcode上的排列组合问题来进行讨论。\n\n## 组合问题\n\n[经典的组合问题](https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fcombinations%2F \"https://leetcode.cn/problems/combinations/\") ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ead1ec3c1884466a8e8c56b2d80dba0e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n以上面题目为例子，从1-4(n)的数字中，排列2(k)个数的组合。解这个题目，可以使用暴力的做法，嵌套for循环来完成该功能。\n\n```\nfunction combine(n) {\n      const res = []\n      for (let i = 1; i <= n; i++) {\n        for (let j = i + 1; j <= n; j++) {\n          res.push([i, j])\n        }\n      }\n      return res\n    }\n\n  console.log(combine(4), \'res\') // [1,2][1,3][1,4][2,3][3,4][2,4]\n复制代码\n```\n\n细心朋友就会发现，它嵌套for次数则是等于它排列(k)的次数，那么我假如k的次数是10，或者20，那么岂不是要嵌套10个或者20个for循环。这套代码写下来，估计是个人都会晕了。在以上代码块中也可以发现**重复的子问题也就是for循环，它想要的结果则为当我们找个了k个数的时候就停止**。那么我们可以尝试通过递归来解决该问题（递归for循环），但是这样的过程还是很抽象的，需要借助图例理解。（任何的组合问题，都可以理解成为n叉树的遍历） ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c200c5d379784534bad684fff43203d8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\n\n```\n function combine(n, k) {\n      const res = []\n      function dfs(n, path, startIndex) {\n        if (path.length === k) {\n          res.push(path.slice())\n          return\n        }\n        for (let i = startIndex; i <= n; i++) {\n          path.push(i)\n          dfs(n, path, i + 1)\n          path.pop()\n        }\n      }\n      dfs(n, [], 1)\n      return res\n    }\n复制代码\n```\n\n当我们选择到了\\[1,2\\]之后，则需要回到1的位置，因为这个时候需要选择3选项，形成\\[1,3\\]，那么回到\'1\'的操作，就类似于二叉树遍历回到父节点的操作，如果此时我们不操作，path.pop()，那么此时就会形成了\\[1,2,3\\]，这样的结果明显不是我们想要，所以在操作push \"3\"的过程，需要先把2给pop掉。而递归的终止条件则为当路径的长度等于k的时候则退出。 另外在函数体中，还发现了startIndex的存在，这个是作为横向for循环开始的位置，我们结合上面两个for循环的代码，是不是发现了j = i + 1的操作，而这个startIndex则是还原了这个操作而已。\n\n关于回溯的问题，leetcode还有许多很好的题目：\n\n[组合总数](https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fcombination-sum%2F \"https://leetcode.cn/problems/combination-sum/\") [全排列](https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fpermutations%2F \"https://leetcode.cn/problems/permutations/\") [子集](https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fsubsets%2F \"https://leetcode.cn/problems/subsets/\") ...','2022-07-26 06:37:00',0000000003,'前端',0),(0000000019,'标题测试修改','序言测试修改','内容测试修改','2022-08-05 18:45:26',0000000027,'标签测试修改',0);
/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `people`
--

DROP TABLE IF EXISTS `people`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `people` (
  `id` int(10) unsigned zerofill NOT NULL AUTO_INCREMENT,
  `nickname` varchar(45) DEFAULT NULL,
  `password` varchar(80) DEFAULT NULL,
  `avatar` varchar(45) DEFAULT NULL,
  `sid` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `people`
--

LOCK TABLES `people` WRITE;
/*!40000 ALTER TABLE `people` DISABLE KEYS */;
INSERT INTO `people` VALUES (0000000001,'Yuzi','114',NULL,'Yuzi1141659770267589'),(0000000002,'Lionaom','8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92',NULL,NULL),(0000000003,'Xiao','8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92',NULL,NULL),(0000000004,'LiZiping','8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92',NULL,NULL),(0000000005,'Cai Molly','8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92',NULL,NULL),(0000000006,'SunChenglong','8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92',NULL,NULL),(0000000007,'PanJinhua','8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92',NULL,NULL),(0000000008,'test','123123',NULL,NULL),(0000000026,'yuzitest','114','11',NULL),(0000000027,'测试','1111111',NULL,NULL);
/*!40000 ALTER TABLE `people` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2022-08-10  9:18:35
